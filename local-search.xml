<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Enum使用</title>
    <link href="/2023/01/06/Enum%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/01/06/Enum%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Enum使用"><a href="#Enum使用" class="headerlink" title="Enum使用"></a>Enum使用</h1><p>统一枚举的操作，枚举类实现该接口</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EnumOperate</span> &#123;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据枚举类型和code获取对应的枚举</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> c 枚举类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 枚举code</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 枚举值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EnumOperate</span>&gt; T <span class="hljs-title function_">valueOfEnum</span><span class="hljs-params">(Class&lt;T&gt; c, <span class="hljs-type">int</span> code)</span> &#123;<br>        EnumOperate[] enums = c.getEnumConstants();<br>        Optional&lt;EnumOperate&gt; optional = Arrays.stream(enums)<br>                .filter(baseCode -&gt; baseCode.getCode().equals(code)).findAny();<br>        <span class="hljs-keyword">if</span> (optional.isPresent()) &#123;<br>            <span class="hljs-keyword">return</span> (T) optional.get();<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(String.format(<span class="hljs-string">&quot;[%s]没有对应枚举值: [%s]&quot;</span>, c.getName(), code));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OpenApiStatueCode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EnumOperate</span> &#123;<br><br>    FORBIDDEN(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;没有该open api 接口的请求权限&quot;</span>),<br><br>    COUNTRY_EXPIRED(<span class="hljs-number">401</span>, <span class="hljs-string">&quot;对该open api接口请求的权限已到期&quot;</span>),<br><br>    REQUEST_TIMEOUT(<span class="hljs-number">408</span>, <span class="hljs-string">&quot;X-Timestamp超时&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> Integer code;<br><br>    <span class="hljs-keyword">private</span> String description;<br><br>    OpenApiStatueCode(Integer code, String description) &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.description = description;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.code;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.description;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>filter和interceptor</title>
    <link href="/2022/12/28/filter%E5%92%8Cinterceptor/"/>
    <url>/2022/12/28/filter%E5%92%8Cinterceptor/</url>
    
    <content type="html"><![CDATA[<h1 id="Filter和Interceptor的使用"><a href="#Filter和Interceptor的使用" class="headerlink" title="Filter和Interceptor的使用"></a>Filter和Interceptor的使用</h1><h2 id="Filter和Interceptor的不同点"><a href="#Filter和Interceptor的不同点" class="headerlink" title="Filter和Interceptor的不同点"></a>Filter和Interceptor的不同点</h2><ol><li>Filter是Servlet的，它主要用于对用户的请求进行预处理，也可以对ServletResponse进行后置处理.</li><li>Interceptor拦截器，在AOP中用于某个方法或字段被访问前，进行拦截，然后在之前或者之后做一些拦截操作，比如日志。</li><li>从前两点就可以看出来，Filter和Interceptor的作用时机是不同的，Filter都没有机会进到方法那里，所以如果我们想做一些权限的校验我们可以采用过滤器，如果我们想对方法做一些加强，比如方法前后做一些日志，那我们就可以使用Interceptor拦截器了</li></ol><h2 id="Filter实践"><a href="#Filter实践" class="headerlink" title="Filter实践"></a>Filter实践</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.ruoyi.common.core.redis.RedisCache;<br><span class="hljs-keyword">import</span> com.ruoyi.common.utils.StringUtils;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Optional;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenApiFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisCache redisCache;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        log.warn(<span class="hljs-string">&quot;开始 进行 open api filter&quot;</span>);<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestURI</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">xClientId</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;x-Client-id&quot;</span>);<br><br>        <span class="hljs-comment">// 判断是否存在xClientId, 不存在说明不是请求open api 继续下个节点过滤，存在继续校验</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(xClientId)) &#123;<br>            <span class="hljs-comment">// 从redis中获取xClientId对应的open api 接口</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">openApiStr</span> <span class="hljs-operator">=</span> Optional.ofNullable(redisCache.getCacheObject(xClientId))<br>                    .map(item -&gt; &#123;<br>                        <span class="hljs-keyword">return</span> item.toString();<br>                    &#125;)<br>                    .orElse(<span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (StringUtils.isNotNull(openApiStr)) &#123;<br>                String[] split = openApiStr.split(<span class="hljs-string">&quot;;&quot;</span>);<br>                List&lt;String&gt; openApiList = Arrays.stream(split).collect(Collectors.toList());<br>                <span class="hljs-comment">// 判断当前uri是否包含在资源里面 包含通过 不包含不通过</span><br>                <span class="hljs-keyword">if</span> (openApiList.contains(requestURI)) &#123;<br>                    filterChain.doFilter(servletRequest, servletResponse);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    log.warn(<span class="hljs-string">&quot;IP：&#123;&#125;不存在该open api &#123;&#125;的访问权限&quot;</span>, request.getRemoteAddr(), requestURI);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                log.warn(<span class="hljs-string">&quot;IP：&#123;&#125;不存在该open api &#123;&#125;的访问权限, 请检查x-Client-id的正确性&quot;</span>, request.getRemoteAddr(), requestURI);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            log.warn(<span class="hljs-string">&quot;IP：&#123;&#125;不存在该open api &#123;&#125;的访问权限&quot;</span>, request.getRemoteAddr(), requestURI);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.ruoyi.openapi.core.filter.OpenApiFilter;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.filter.DelegatingFilterProxy;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenApiFilterConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(name = &quot;openApiFilter&quot;)</span><br>    <span class="hljs-keyword">public</span> OpenApiFilter <span class="hljs-title function_">getOpenApiFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenApiFilter</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title function_">registerMyFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">FilterRegistrationBean</span> <span class="hljs-variable">registrationBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>&lt;&gt;();<br>        registrationBean.setOrder(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 正常Filter里面是注入不了Bean的，前面也说过Filter更靠前，Filter比Bean先加载</span><br>        <span class="hljs-comment">// 是属于Servlet的，他还没有进入spring所以无法使用spring的注入</span><br>        <span class="hljs-comment">// 我们可以采用filter配置文件&lt;filter&gt;和Bean的配置文件来解决</span><br>        <span class="hljs-comment">// 这里我们使用DelegatingFilterProxy来解决</span><br>        registrationBean.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingFilterProxy</span>(<span class="hljs-string">&quot;openApiFilter&quot;</span>));<br>        registrationBean.setUrlPatterns(Arrays.asList(<span class="hljs-string">&quot;/aiot/openapi/*&quot;</span>));<br>        <span class="hljs-comment">// 因为我们已经通过DelegatingFilterProxy来实现了所以我们可以把这个filter设置为false，</span><br>        <span class="hljs-comment">// 默认为true，如果为true会导致一个请求filter两次</span><br>        registrationBean.setEnabled(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span> registrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过测试发现，正常的接口也被过滤了，，，这是为什么？我也不知道，心想着我在setFilter的时候既然用的是DelegatingFilterProxy那我为什么不直接使用<code>DelegatingFilterProxyRegistrationBean</code>呢, 于是改为下面的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.ruoyi.openapi.core.filter.OpenApiFilter;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.DelegatingFilterProxyRegistrationBean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> javax.servlet.DispatcherType;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenApiFilterConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(name = &quot;openApiFilter&quot;)</span><br>    <span class="hljs-keyword">public</span> OpenApiFilter <span class="hljs-title function_">getOpenApiFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenApiFilter</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DelegatingFilterProxyRegistrationBean <span class="hljs-title function_">delegatingFilterProxyRegistrationBean</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DelegatingFilterProxyRegistrationBean</span> <span class="hljs-variable">filterProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingFilterProxyRegistrationBean</span>(<span class="hljs-string">&quot;openApiFilter&quot;</span>);<br>        filterProxy.addUrlPatterns(<span class="hljs-string">&quot;/aiot/openapi/*&quot;</span>);<br>        filterProxy.addInitParameter(<span class="hljs-string">&quot;targetFilterLifecycle&quot;</span>,<span class="hljs-string">&quot;true&quot;</span>);<br>        filterProxy.addInitParameter(<span class="hljs-string">&quot;exclusions&quot;</span>, <span class="hljs-string">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico&quot;</span>);<br>        filterProxy.setDispatcherTypes(DispatcherType.REQUEST);<br>        <span class="hljs-keyword">return</span> filterProxy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次测试通过，只过滤了我们想要过滤的接口。至于上面那种方式不行还有待探索。参考连接<a href="https://zhuanlan.zhihu.com/p/102273651">参考</a></p><blockquote><p>FilterRegistrationBean和DelegatingFilterProxyRegistrationBean区别：</p></blockquote><ul><li>FilterRegistrationBean通过onStartup方法直接注册filter。</li><li>DelegatingFilterProxyRegistrationBean是将DelegatingFilterProxy注册到Servlet3.0+的容器中，同时实现了ApplicationContextAware接口，实例ApplicationContext通过通过传入自定义filter的名称查找对应的bean，并生成相应bean的代理对象。</li></ul><h3 id="DelegatingFilterProxy"><a href="#DelegatingFilterProxy" class="headerlink" title="DelegatingFilterProxy"></a>DelegatingFilterProxy</h3><p>DelegatingFilterProxy就是一个对于servlet filter的代理，用这个类的好处就是<code>可以通过spring容器来管理servlet filter的生命周期。</code></p><p>还有就是如果filter中需要一些spring容器的实例，可以通过spring直接注入，另外读取一些配置文件这些便利的操作也可以通过spring来配置实现</p><p>Spring web在设计的时候考虑到某些功能的实现是通过Filter来拦截进行实现的，如果直接的简单的实现几个Filter好像也不是不可以（平时我们就是这么用的），但是Spring框架最核心的是IOC容器，和Spring框架最好的实现就是将要实现的Filter功能注册到IOC容器的一个Bean，这样就可以和Spring IOC容器进行完美的融合，所以Spring Web设计了DelegatingFilterProxy。</p><blockquote><p>本质上来说DelegatingFilterProxy就是一个Filter，其间接实现了Filter接口，但是<strong>在doFilter中其实调用的从Spring 容器中获取到的代理Filter的实现类delegate。</strong></p></blockquote><h3 id="DelegatingFilterProxy原理"><a href="#DelegatingFilterProxy原理" class="headerlink" title="DelegatingFilterProxy原理"></a>DelegatingFilterProxy原理</h3><ol><li><p>DelegatingFilterProxy根据targetBeanName从Spring 容器中获取被注入到Spring 容器的Filter实现类，<strong>在DelegatingFilterProxy配置时一般需要配置属性targetBeanName</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFilterBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.delegateMonitor) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.delegate == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// If no target bean name specified, use filter name.</span><br>            <span class="hljs-comment">// 当Filter配置时如果没有设置targentBeanName属性，则直接根据Filter名称来查找</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.targetBeanName == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.targetBeanName = getFilterName();<br>&#125;<br><span class="hljs-comment">// Fetch Spring root application context and initialize the delegate early,</span><br><span class="hljs-comment">// if possible. If the root application context will be started after this</span><br><span class="hljs-comment">// filter proxy, we&#x27;ll have to resort to lazy initialization.</span><br><span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span> findWebApplicationContext();<br><span class="hljs-keyword">if</span> (wac != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 从Spring容器中获取注入的Filter的实现类</span><br><span class="hljs-built_in">this</span>.delegate = initDelegate(wac);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">protected</span> Filter <span class="hljs-title function_">initDelegate</span><span class="hljs-params">(WebApplicationContext wac)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><span class="hljs-comment">//从Spring 容器中获取注入的Filter的实现类</span><br><span class="hljs-type">Filter</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> wac.getBean(getTargetBeanName(), Filter.class);<br><span class="hljs-keyword">if</span> (isTargetFilterLifecycle()) &#123;<br>delegate.init(getFilterConfig());<br>&#125;<br><span class="hljs-keyword">return</span> delegate;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在DelegatingFilterProxy的实现方法doFilter中，其实最终调用的是委派的类delegate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFilterBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.delegateMonitor) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.delegate == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// If no target bean name specified, use filter name.</span><br>            <span class="hljs-comment">// 当Filter配置时如果没有设置targentBeanName属性，则直接根据Filter名称来查找</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.targetBeanName == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.targetBeanName = getFilterName();<br>&#125;<br><span class="hljs-comment">// Fetch Spring root application context and initialize the delegate early,</span><br><span class="hljs-comment">// if possible. If the root application context will be started after this</span><br><span class="hljs-comment">// filter proxy, we&#x27;ll have to resort to lazy initialization.</span><br><span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span> findWebApplicationContext();<br><span class="hljs-keyword">if</span> (wac != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 从Spring容器中获取注入的Filter的实现类</span><br><span class="hljs-built_in">this</span>.delegate = initDelegate(wac);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">protected</span> Filter <span class="hljs-title function_">initDelegate</span><span class="hljs-params">(WebApplicationContext wac)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><span class="hljs-comment">// 从Spring 容器中获取注入的Filter的实现类</span><br><span class="hljs-type">Filter</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> wac.getBean(getTargetBeanName(), Filter.class);<br><span class="hljs-keyword">if</span> (isTargetFilterLifecycle()) &#123;<br>delegate.init(getFilterConfig());<br>&#125;<br><span class="hljs-keyword">return</span> delegate;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Interceptor的使用"><a href="#Interceptor的使用" class="headerlink" title="Interceptor的使用"></a>Interceptor的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.ruoyi.aiot.webconfig.annotation.DeviceAuth;<br><span class="hljs-keyword">import</span> com.ruoyi.common.utils.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.web.method.HandlerMethod;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeviceAuthTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br><span class="hljs-comment">//    public static final String NY_AIOT_TOKEN_KEY = &quot;NY_DEVICE_TOKEN&quot;;</span><br><br>    <span class="hljs-meta">@Value(&quot;$&#123;emq.value&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String emqToken;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;emq.header&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String header;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 如果不是映射到方法直接通过</span><br>        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">handlerMethod</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> handlerMethod.getMethod();<br>        <span class="hljs-type">DeviceAuth</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> method.getAnnotation(DeviceAuth.class);<br>        <span class="hljs-keyword">if</span> (StringUtils.isNull(annotation))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断token的合法性</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(header);<br>        <span class="hljs-keyword">return</span> emqToken.equals(token);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.ruoyi.aiot.webconfig.Interceptor.DeviceAuthTokenInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设备token认证</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> DEAN</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebDeviceAuthConfigurer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DeviceAuthTokenInterceptor <span class="hljs-title function_">getDeviceAuthTokenInterceptor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeviceAuthTokenInterceptor</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// addInterceptor这里如果是通过new DeviceAuthTokenInterceptor()的话</span><br>        <span class="hljs-comment">// 我们在DeviceAuthTokenInterceptor 里面注入的Bean都会为null, </span><br>        <span class="hljs-comment">// 因为new出来的是不归spring容器管理的</span><br>        <span class="hljs-comment">// 所以我们好像DeviceAuthTokenInterceptor里面注入的Bean不为null，这里就要是一个Bean</span><br>        <span class="hljs-comment">// 我们就通过@Bean注解的方式获得一个Bean然后add进去就好了 [参考这篇博客](https://cloud.tencent.com/developer/article/1640210)</span><br>        <span class="hljs-comment">// 通过new的方式创建的拦截器是没有交给spring进行管理的，没有被spring管理的实例，是无法注入的，所以为null</span><br>       registry.addInterceptor(getDeviceAuthTokenInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/aiot/device/state&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RestTemplate</title>
    <link href="/2022/12/07/RestTemplate/"/>
    <url>/2022/12/07/RestTemplate/</url>
    
    <content type="html"><![CDATA[<h1 id="RestTemplate的使用"><a href="#RestTemplate的使用" class="headerlink" title="RestTemplate的使用"></a>RestTemplate的使用</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestTemplateConfig</span> &#123;<br><span class="hljs-comment">//    @Value(&quot;$&#123;emq.username&#125;&quot;)</span><br><span class="hljs-comment">//    private String username;</span><br><span class="hljs-comment">//    @Value(&quot;$&#123;emq.password&#125;&quot;)</span><br><span class="hljs-comment">//    private String password;</span><br><span class="hljs-comment">//    @Bean</span><br><span class="hljs-comment">//    public RestTemplate restTemplate(RestTemplateBuilder builder)&#123;</span><br><span class="hljs-comment">//        return builder.basicAuthentication(username,password).build();</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ClientHttpRequestFactory <span class="hljs-title function_">simpleClientHttpRequestFactory</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">SimpleClientHttpRequestFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleClientHttpRequestFactory</span>();<br>        factory.setReadTimeout(<span class="hljs-number">5000</span>);<br>        factory.setConnectTimeout(<span class="hljs-number">15000</span>);<br>        <span class="hljs-comment">// 设置代理</span><br>        <span class="hljs-comment">//factory.setProxy(null);</span><br><br>        <span class="hljs-keyword">return</span> factory;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">(ClientHttpRequestFactory factory)</span> &#123;<br><br>        <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>(factory);<br><br>        <span class="hljs-keyword">return</span> restTemplate;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以通过RestTemplateBuilder来设置一些参数，比如验证、超时时间等。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">requestHeaders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>();<br>        requestHeaders.setContentType(MediaType.APPLICATION_JSON);<br>        HttpEntity&lt;String&gt; requestEntity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpEntity</span>&lt;String&gt;(jsonString, requestHeaders);<br>        ResponseEntity&lt;String&gt; res = restTemplate.postForEntity(url, requestEntity, String.class);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wait和notify</title>
    <link href="/2022/11/09/wait%E5%92%8Cnotify/"/>
    <url>/2022/11/09/wait%E5%92%8Cnotify/</url>
    
    <content type="html"><![CDATA[<h1 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h1><ul><li><p>Object的wait方法会导致当前线程进入阻塞，直到有其他线程调用notify或者notifyAll将其唤醒，或者阻塞时间到达timeout而自动唤醒</p><blockquote><p>调用notify唤醒线程时不同的JVM实现是不同的， 官方的JVM是按照进入wait set的顺序进行唤醒的（将线程从wait set中进行弹出），如果是notifyAll则是将wait set中所有的唤醒</p></blockquote><blockquote><p>唤醒过后线程不会立马接着执行，唤醒过后线程会继续竞争CPU，竞争到后会继续沿着wait执行，所以这里虽说有同步机制还是会有可能产生数据一致性问题，所以在并发编程里不建议使用if判断，建议改为while，因为在你第一次进入执行单元的时候你可能是满足if里面的条件的，但是当你被唤醒后你是接着从wait开始执行的，这时候你是不一定还满足条件的，但是if只会判断那一次，所以会出问题，while的话唤醒后会重新判断条件</p></blockquote></li><li><p>wait方法必须拥有该对象的monitor所有权， 也就是必须在同步方法中使用</p></li><li><p>当前线程执行了该对象的wait方法后，就会放弃该对象的monitor，进入到wait set中。其他线程开始继续争抢该对象的所有权</p></li><li><p>同步代码的monitor必须和调用notify和wait的monitor一致，简单来说就是用哪个对象的monitor进行同步， 就要使用哪个对象的monitor进行wait，notify操作</p></li></ul><blockquote><p>wait 和 sleep</p></blockquote><ol><li>wait 和 sleep 都可以使线程进入阻塞状</li><li>wait 和 sleep 都是可中断方法，被中断后都会抛出中断异常并擦除interrupt标志</li><li>wait是object的方法，sleep是Thread的方法</li><li>wait必须在同步代码块中使用，sleep则不需要</li><li>线程在同步方法中执行sleep方法时并不会释放monitor的锁，而wait会释放掉</li><li>sleep短暂休眠后会自动结束阻塞，wait方法在没有指定timeout的时候会一直处于阻塞状态知道被其他线程调用notify或者notifyAll才能退出阻塞</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>构造者模式</title>
    <link href="/2022/11/09/%E6%9E%84%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/11/09/%E6%9E%84%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="构造者模式"><a href="#构造者模式" class="headerlink" title="构造者模式"></a>构造者模式</h1><h2 id="可以解决什么问题"><a href="#可以解决什么问题" class="headerlink" title="可以解决什么问题"></a>可以解决什么问题</h2><p>可以一定程度上保证原子性，原理是在中间加了一层，相比之前一个一个set可以防止在set过程中被其他线程拿去使用，但是这时候它并不是完整的所有会存在问题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> io.quarkiverse.seata.design;<br><br><span class="hljs-keyword">import</span> cn.hutool.core.collection.CollectionUtil;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChainNode</span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Tuple&lt;Object,Object&gt;&gt; params;<br><br>    ChainNode(List&lt;Tuple&lt;Object,Object&gt;&gt; params)&#123;<br><br>        <span class="hljs-built_in">this</span>.params  = params;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> List&lt;Tuple&lt;Object,Object&gt;&gt; <span class="hljs-title function_">getParams</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.params;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChainNode.ChainNodeBuilder <span class="hljs-title function_">builder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainNode</span>.ChainNodeBuilder();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChainNodeBuilder</span>&#123;<br>        <span class="hljs-keyword">private</span> List&lt;Tuple&lt;Object,Object&gt;&gt; params;<br><br>        <span class="hljs-keyword">public</span> ChainNode.ChainNodeBuilder <span class="hljs-title function_">params</span><span class="hljs-params">(Tuple&lt;Object,Object&gt;... params)</span>&#123;<br>            <span class="hljs-keyword">return</span> params != <span class="hljs-literal">null</span> &amp;&amp; params.length&gt;<span class="hljs-number">0</span> ? <span class="hljs-built_in">this</span>.params(<br>            (Arrays.stream(params)·<br>            .collect(Collectors.toList())<br>            )<br>            ):<span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> ChainNode.ChainNodeBuilder <span class="hljs-title function_">params</span><span class="hljs-params">(Collection&lt;Tuple&lt;Object,Object&gt;&gt; params)</span>&#123;<br>            <span class="hljs-keyword">if</span> (params != <span class="hljs-literal">null</span> &amp;&amp; params.size()&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">this</span>.params = params.stream().filter(Objects::nonNull).collect(Collectors.toList());<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        ChainNodeBuilder()&#123;&#125;<br><br><br>        <span class="hljs-keyword">public</span> ChainNode <span class="hljs-title function_">build</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainNode</span>(<span class="hljs-built_in">this</span>.params);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java内存模型</title>
    <link href="/2022/11/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/11/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解Java内存模型"><a href="#深入理解Java内存模型" class="headerlink" title="深入理解Java内存模型"></a>深入理解Java内存模型</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><strong>处理器 2 GHz Intel Core i5</strong></p><p>现在的CPU基本是多核的，而且CPU 运算速度远比主存（内存）读写速度快，并且速度相差了几个数量级。所以CPU 大部分时间都在等数据从主存读取，运算完数据写回内存。</p><p>所以现代计算机在CPU和主存之间加了一层读写速度尽可能接近CPU运算速率的高速缓存来做缓冲。而且CPU还有内置的寄存器存放一些计算结果。如果cpu每次需要的数据都不在缓存中，那么还不是要去主存中读取，放入缓存，岂不是多此一举？</p><p>由于长期的实验显示：程序 80% 的时间在执行 20% 的代码，所以只要把这 20% 的数据和代码放入缓存中，系统性能将会大大提升。</p><p>而且CPU访问主存时存在两个局部性现象：</p><ul><li><p>时间局部性现象</p><p>如果一个主存数据正在被访问，那么近期它再次被访问的可能性也很大</p></li><li><p>空间局部性</p><p>如果某块内存被访问了，这块内存区域临近的数据也很有可能会被访问到，比如数组</p></li></ul><h2 id="局部性原理对编程的影响"><a href="#局部性原理对编程的影响" class="headerlink" title="局部性原理对编程的影响"></a>局部性原理对编程的影响</h2><ol><li>反复引用同一个变量具有良好的时间局部性</li><li>对于步长为k的引用模式的程序，步长越短空间局部性越好，例如数组操作</li><li>对于取指令来说。循环有好的时间和空间局部性。循环体越小，循环次数越多，局部性越好</li></ol><p><img src="image-20221109111222811.png" alt="image-20221109111222811"></p><p><img src="D:\personalcode\hexo-blog\hexo-blog\source_posts\assets\image-20221109111222811-16679635684892.png" alt="image-20221109111222811"></p><h2 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h2><p>多核cpu且有各自的高速缓存，这就会出现缓存数据不一致的问题，两个核心的线程都读取了主存中的同一个共享变量，并且都对其进行了操作，比如都读取了一个整型数据i = 0，两个线程都对其 i++，写回主存中，主存中 i 的值变为了 1，但是这是错误的，因为执行了两次++操作，i 应该为2。</p><blockquote><p>如何解决缓存一致性问题</p></blockquote><p>早期的做法是锁住总线，因为所有的CPU都是通过总线来操作主存的，当一个CPU访问主存中的共享变量时，其它CPU都无法访问，这样就不会有数据不一致的问题了，但是这大大降低了CPU的性能。</p><p><img src="image-20221109111412806.png" alt="image-20221109111412806"></p><p><img src="D:\personalcode\hexo-blog\hexo-blog\source_posts\assets\image-20221109111412806-16679636648975.png" alt="image-20221109111412806"></p><blockquote><p>缓存一致性协议</p></blockquote><p>缓存一致性协议有很多种，用的最多的是<code>MESI协议(Modified修改状态、Exclusive独占状态、share共享状态、invalid无效状态)</code></p><p><strong>缓存行： <code>高速缓存</code>中存储数据的最小单位</strong></p><p>MESI协议可以理解为缓存行锁，定义了缓存中的数据状态只有四种，MESI是四种状态的首字母，当CPU读取某一个缓存行时，先识别缓存行的状态：</p><ul><li><strong>失效缓存行invalid：</strong>要么已经不在缓存中，要么内容已经过时了，这种状态的行将会被忽略。相当于从来没有加载到缓存中</li><li><strong>共享缓存行share：</strong> 说明该cache line是内存中某一段数据的拷贝，该状态下的cache line只能被读取不能被写入，不同的CPU的缓存都可以拥有这段数据的拷贝</li><li><strong>独占缓存段exclusive：</strong> 和share状态一样，说明该cache line是内存中某一段数据的拷贝。区别在于，该cache Line独占该内存地址，如果其他CPU也持有同一份cache line，那么会变成invalid状态</li><li><strong>修改缓存段modified：</strong> 表明该cache line已经被修改，当前的CPU要修改某个数据，就会发送通知给其他CPU，如果有该cache line就把该数据修改为invalid状态，如果其他CPU已经将cache line修改为修改状态，就把该数据最新值返回，并把cache line状态修改为invalid，当前CPU就收到所有通知后，获得独占权数据状态变为exclusive，开始修改数据，将数据状态修改为modified， <code>注意此时主存中的数据仍然是旧的</code>。</li></ul><p>modified已经修改状态cache line，如果被丢弃或替换或标记为invalid状态时， 要把该cache line的内容先写到主存中</p><blockquote><p>如果CPU每次修改缓存数据，都要等待其它CPU的答复，这种等待同步的方式会不会太浪费CPU性能了</p></blockquote><p>CPU 做了优化，采用异步的方式，把最新修改的数据写到【store buffer】中，并通知其它CPU记得更改状态，然后CPU可以继续运行，执行其它的指令。收到其它CPU的答复后，再将【store buffer】中的新数据移到 cache line。</p><p>其它CPU接收到 Invalid通知后，也会把该消息放入消息队列中，从队列取消息执行后，再通知CPU已经将状态置为 I 无效状态了。</p><blockquote><p>【store buffer】可能导致破坏程序顺序的问题</p></blockquote><p>如果CPU修改完A值，写到【store buffer】中，CPU去干别的事了，但是又收到指令需要修改A值，但是上一次的修改的值还在【store buffer】中，没更新至cache line。</p><p>硬件工程师在store buffer的基础上，又实现了【store forwarding】技术，CPU 在读取操作时，需要先去【store buffer】里查看一下是不是有自己更新过的数据，支持将CPU</p><p>存入【store buffer】的数据传递（forwarding）给后续的操作，而不经过 Cache 高速缓存。</p><p>这种异步机制对于多核CPU的情况，还是会有问题：</p><p>问题1 【store buffer】不及时更新到内存导致：<br>如果CPU1改了某个值，但是还没有更新到主存中，CPU2 就算收到了Invalid 指 令，也发送了应答，但是CPU2再次读取该数据时，由于是Invalid 状态，从内存 中读取到的数据仍然是旧值。</p><p>问题2【invalid queue】不及时读取队列中的消息导致：</p><p>如果CPU1更改了某个数据，CPU2也收到了消息并且放在了【invalid queue】中， 但是CPU2这时还没执行到处理【invalid queue】中的消息，就对该数据进行了读取，导致读到的是旧值。</p><p>由于这种异步优化机制，导致后面的指令不知道前面指令的执行结果，指令执行的顺序不是代码执行的顺序，导致了【CPU乱序执行】。</p><h2 id="如何解决CPU乱序执行问题（可见性问题）"><a href="#如何解决CPU乱序执行问题（可见性问题）" class="headerlink" title="如何解决CPU乱序执行问题（可见性问题）"></a>如何解决CPU乱序执行问题（可见性问题）</h2><p>要保证指令执行顺序的一致性，硬件优化不了了，我们在软件层面提供支持。</p><p>这个问题的关键是CPU修改完数据放入【store buffer】后，没有及时更新到主存，那我们如果给它一个指令强行把缓存区【store buffer】的数据更新到主存，强行把【invalid queue】的消息都处理掉。通过这些操作，保持当前CPU的缓存状态是一致的。读到的数据一定是最新的。</p><p>这种指令（操作系统层面）就是内存屏障，save fence【写屏障】、load fence【读屏障】，mfence【读写屏障】简单的理解就是：</p><p>【写屏障】：CPU执行到写屏障指令时，会把该指令之前存在于【store buffer】所有的数据刷入高速缓存中。</p><p>【读屏障】：CPU执行到读屏障指令时，把该指令之前存在于【invalid queue】所有的指令都处理掉，及时把已经被别的CPU修改过的数据置为无效 Invalid 状态。</p><blockquote><p>多核CPU下我们有了缓存一致性协议如 MESI 和各种内存屏障，解决了多核CPU的缓存一致性，为什么还需要 java 关键字 volatile ？</p></blockquote><p>为了优化程序性能，对原有的指令顺序进行优化【重排序】，但是【重排序】可能发生在多个阶段，并不只是操作系统层面的CPU指令重排序，也有可能是编译阶段的重排序，比如 java 的字节码指令重排序，所以需要一个更高层面—语言层面的支持，来保证内存可见性。</p><p>volatile 是java语言层面来定义的，实现 volatile 底层也需要依靠 MESI，但是有的CPU是单核的，通过锁总线实现内存可见性，Volatile 屏蔽了这些硬件差异，Java 程序员需要使用共享变量，让该变量的修改对于其它线程可见时，只需要使用 volatile 关键字就行，而不用去担心底层操作系统是什么，硬件是如何实现内存可见性的。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><blockquote><p><strong>为什么需要Java内存模型 （Java Memory Model</strong></p></blockquote><p>Java 内存模型，简称JMM，是java并发编程的核心，是java定义的一套协议或者规范，用来屏蔽各种硬件和操作系统的内存访问差异，让java程序在各个平台都有一致的运行效果。</p><p>目的是解决多线程存在的原子性、可见性（缓存一致性）、有序性。</p><p>Java内存模型规定：所有的变量都存储在主内存中，每个线程有自己的工作内存，线程的工作内存保存了该线程执行使用到的变量（主内存的拷贝），线程对变量的所有操作都必须在工作内存中执行，不能直接读写主内存的变量，线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递需要在主内存中完成。</p><p><img src="image-20221109111523210.png" alt="image-20221109111523210"></p><p><img src="D:\personalcode\hexo-blog\hexo-blog\source_posts\assets\image-20221109111523210-16679637331528.png" alt="image-20221109111523210"></p><p>【工作内存】和 【主内存】是对计算机存储的抽象概念模型，并不是指单一的内存</p><p><a href="https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020">JVM</a>内存划分中的堆和栈，堆是线程共享的，栈是线程私有的，实际上堆可能包括CPU寄存器、CPU高速缓存、主存，本地线程栈空间也可能包括这些。</p><p><img src="image-20221109111608285.png" alt="image-20221109111608285"></p><p><img src="D:\personalcode\hexo-blog\hexo-blog\source_posts\assets\image-20221109111608285-166796377749611.png" alt="image-20221109111608285"></p><p>线程本地内存和物理真实内存的关系</p><ul><li>初始变量首先存储在主内存中；</li><li>线程操作变量需要从主内存拷贝到线程本地内存中；</li><li>线程的<strong>本地工作内存</strong>是一个抽象概念，包括了缓存、寄存器、store buffer(CPU内的缓存区域)等。</li></ul><h2 id="变量如何从主存拷贝到工作内存"><a href="#变量如何从主存拷贝到工作内存" class="headerlink" title="变量如何从主存拷贝到工作内存"></a>变量如何从主存拷贝到工作内存</h2><p>一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作（单一操作都是原子的）来完成：</p><ul><li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量解除锁定，解除锁定后的变量才可以被其他线程锁定</li><li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（有的指令是save/存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li>如果要把一个变量从主内存中复制到工作内存，需要顺序执行read 和load 操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store 和write 操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行，也就是操作不是原子的，一组操作可以中断。</li><li>不允许read和load、store和write操作之一单独出现，必须成对出现。</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。<br>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><p>学习参考资料</p><p>《深入理解java虚拟机》</p><p><a href="https://www.cnblogs.com/jzssuanfa/p/7388066.html">https://www.cnblogs.com/jzssuanfa/p/7388066.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/125549632">https://zhuanlan.zhihu.com/p/125549632</a></p><p><a href="https://mp.weixin.qq.com/s/3qYwgERmyKUqQI-_BwAJVg">https://mp.weixin.qq.com/s/3qYwgERmyKUqQI-_BwAJVg</a></p><p><a href="https://juejin.cn/post/7023532967553138701">https://juejin.cn/post/7023532967553138701</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS--线程</title>
    <link href="/2022/11/09/OS-%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/11/09/OS-%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线程详解"><a href="#线程详解" class="headerlink" title="线程详解"></a>线程详解</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li><strong>在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。</strong></li><li>不过，在许多情况下，<code>经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。</code></li></ul><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答：<br>•多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的<br>•线程要比进程更轻量级，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统 中，创建一个线程要比创建一个进程快10-100倍。<br>•第三个原因可能是性能方面的探讨，如果多个线程都是CPU密集型的，那么并不能获得性能上的 增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程能在这些活动中彼此重叠进 行，从而会加快应用程序的执行速度</p><h3 id="多线程解决方案"><a href="#多线程解决方案" class="headerlink" title="多线程解决方案"></a><a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>解决方案</h3><ul><li>现在考虑一个线程使用的例子：一个万维网服务器，对页面的请求发送给服务器，而所请求的页面发送 回客户端。</li><li>在多数web站点上，<code>某些页面较其他页面相比有更多的访问</code>。</li><li><strong><code>Web服务器可以把获得大量访问的页面集合保存在内存中，避 免到磁盘去调入这些页面，从而改善性能。</code></strong></li><li><strong>这种页面的集合称为<code>高速缓存(cache),</code>高速缓存也应用 在许多场合中，比如说CPU缓存。</strong></li></ul><p><img src="D:\personalcode\hexo-blog\hexo-blog\source_posts\OS-线程\image-20221109110721367.png" alt="image-20221109110721367"></p><p><img src="image-20221109110721367.png" alt="image-20221109110721367"></p><p>编程其实是跟生活息息相关的，编程是可以映射到生活的，比如java是一种面向对象的编程语言，什么是对象，对象是对一组事物的特征抽象和行为抽象，每一个类都有自己的职责跟特点，对应到生活中就是不同职位上的工人，我们程序员对应的是什么角色呢？我们是这个抽象世界的领导者，我们要做的就是按照业务的规则让他们协调有序的工作。</p><p>上面这张图理解起来其实很简单。进程间通信的方式有其中，其中一种就是套接字，套接字通信要依赖于端口号，所以基于套接字来说这个服务容器对外的暴漏的入口就是这个端口号。调度线程跟工作线程的关系就是领导者跟员工的关系，网络请求就相当于是客户来了需求，调度线程相当于就是项目经理，工作线程相当于就是程序员，项目经理将各个需求分到各个开发组，分工完成合作。</p><ul><li><strong>上面是一个web服务器的组织方式，一个叫做 <code>调度线程(dispatcher thread)的线程从网络中读 入工作请求，在调度线程检查完请求后，它会选择一个空闲的(阻塞的)工作线程来处理请求</code>，通常是 将消息的指针写入到每个线程关联的特殊字中。</strong></li><li>然后<code>调度线程会唤醒正在睡眠中的工作线程，把工作线 程的状态从阻塞态变为就绪态。</code></li><li><strong>当工作线程启动后，它会检查请求是否在web页面的高速缓存中存在，这个高速缓存是所有线程都可 以访问的。</strong></li><li><code>如果高速缓存不存在这个web页面的话，它会调用一个read操作从磁盘中获取页面并且 阻塞线程直到磁盘操作完成</code>。</li><li><strong><code>当线程阻塞在硬盘操作的期间，为了完成更多的工作，调度线程可能挑选 另一个线程运行，也可能把另一个当前就绪的工作线程投入运行。</code></strong></li><li>这种模型允许将服务器编写为顺序线程的集合，在分派线程的程序中包含一个死循环，该循环用来获得 工作请求并且把请求派给工作线程。</li><li><code>每个工作线程的代码包含一个从调度线程接收的请求，并且检查 web高速缓存中是否存在所需页面，如果有，直接把该页面返回给客户，接着工作线程阻塞，等待一个 新请求的到达。如果没有，工作线程就从磁盘调入该页面，将该页面返回给客户机，然后工作线程阻 塞，等待一个新请求</code>。</li></ul><h3 id="单线程解决方案"><a href="#单线程解决方案" class="headerlink" title="单线程解决方案"></a>单线程解决方案</h3><p>现在考虑没有多线程的情况下，如何编写Web服务器。</p><ul><li>我们很容易的就想象为单个线程了，Web服务 器的主循环获取请求并检查请求，并争取在下一个请求之前完成工作</li><li><strong>在等待磁盘操作时，服务器空 转，并且不处理任何到来的其他请求。结果会导致每秒中只有很少的请求被处理</strong></li></ul><p>所以这个例子能够说 明多线程提高了程序的并行性并提高了程序的性能</p><h2 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h2><p>理解进程的另一个角度是，用某种方法把相关资源集中在一起。</p><ol><li>进程有存放程序正文和数据以及其他资源的地址空间。这些资源包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等。把这些信息放在进程里比较好管理</li><li>另一个概念是，线程中拥有一个执行的线程，通常简写为线程</li><li>线程会有计数器，用来记录这要执行哪一条指令。线程还拥有寄存器，用来保存线程当前正在使用的变量。线程还会有堆栈，用来记录程序的执行路径</li><li>尽管线程必须在某个进程内执行，但是进程和线程是完全不同的概念，并且他们可以分开处理。</li><li>进程用于把资源集中在一起，而线程则是CPU上调度执行的实体</li><li>线程给进程模型增加了一项内容，即在同一个进程中，允许彼此之间有较大的独立性且互不干扰</li><li>在一 个进程中并行运行多个线程类似于在一台计算机上运行多个进程。</li><li><strong><code>在多个线程中，各个线程共享同一地 址空间和其他资源。在多个进程中，进程共享物理内存、磁盘、打印机和其他资源。</code></strong></li><li>因为线程会包含有一些进程的属性，所以线程被称为轻量的进程(lightweight processes)</li><li>多线程 (multithreading) 一词还用于描述在同一进程中多个线程的情况。</li></ol><p>下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行</p><p><img src="D:\personalcode\hexo-blog\hexo-blog\source_posts\OS-线程\image-20221109110523130.png" alt="image-20221109110523130"></p><p><img src="image-20221109110523130.png" alt="image-20221109110523130"></p><ul><li><strong>线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味 着它们也共享同样的全局变量。</strong></li><li><code>由于每个线程都可以访问进程地址空间内每个内存地址，因此一个线程 可以读取、写入甚至擦除另一个线程的堆栈。</code></li></ul><p>线程之间除了共享同一内存空间外，还具有如下不同的内 容</p><p><img src="D:\personalcode\hexo-blog\hexo-blog\source_posts\OS-线程\image-20221109110602117.png" alt="image-20221109110602117"></p><p><img src="image-20221109110602117.png" alt="image-20221109110602117"></p><ul><li>上图左边的是同一个进程中每个线程共享的内容，上图右边是每个线程中的内容。也就是说左边的列 表是进程的属性，右边的列表是线程的属性。</li><li><strong>和进程一样，线程可以处于下面这几种状态：<code>运行中、阻塞、就绪和终止</code>（进程图中没有画）</strong></li><li><strong><code>正在运 行的线程拥有CPU时间片并且状态是运行中。一个被阻塞的线程会等待某个释放它的事件。</code></strong></li><li>例如，当 一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到有输入为止。线程通常会被阻塞，直 到它等待某个外部事件的发生或者有其他线程来释放它。线程之间的状态转换和进程之间的状态转换是 —样的。</li></ul><p>每个线程都会有自己的堆栈，如下图所示：</p><p><img src="D:\personalcode\hexo-blog\hexo-blog\source_posts\OS-线程\image-20221109110626261.png" alt="image-20221109110626261"></p><p><img src="image-20221109110626261.png" alt="image-20221109110626261"></p><h2 id="线程系统调用"><a href="#线程系统调用" class="headerlink" title="线程系统调用"></a>线程系统调用</h2><ul><li>进程通常会从当前的某个单线程开始，然后这个<code>线程通过调用一个库函数（比如thread.create ） 创建新的线程。</code></li><li>线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识 符，该标识符就是新线程的名字。</li><li>当一个线程完成工作后，可以通过调用一个函数（比如thread_exit ）来退出</li><li><strong>紧接着线程消失，状 态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如thread_join , 表示一个线程可以等待另一个线程退出</strong></li><li>这个过程阻塞调用线程直到等待特定的线程退出。在这种情况 下，线程的创建和终止非常类似于进程的创建和终止。</li><li><strong>另一个常见的线程是调用thread-yield ,它允许线程自动放弃CPU从而让另一个线程运行。</strong></li><li><strong><code>这样 一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出CPU的。</code></strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于事件驱动发送email、短信</title>
    <link href="/2022/11/09/%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%8F%91%E9%80%81email%E3%80%81%E7%9F%AD%E4%BF%A1/"/>
    <url>/2022/11/09/%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%8F%91%E9%80%81email%E3%80%81%E7%9F%AD%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>基于事件驱动发送email、短信<br>发送邮件就发送邮件呗，为什么说是基于事件驱动呢？因为发送邮件是一个相对耗时的操作，我们基于事件驱动可以异步解耦，</p><p>同时通过@Async做一步操作降低接口的耦合性和响应时间。</p><p>spring事件驱动组成<br>spring事件驱动由3个部分组成</p><p>1、ApplicationEvent：表示事件本身，自定义事件需要继承该类。用来定义事件</p><p>2、ApplicationEventPublisherAware：事件发送器，需要实现该接口。主要用来发布事件.ApplicationContext 也实现了该接口，可以用于发布事件.</p><p>Spring4.2之后，ApplicationEventPublisher自动被注入到容器中，采用Autowired即可获取。</p><p>3、ApplicationListener：事件监听器接口。监听类实现ApplicationListener 里onApplicationEvent方法即可.</p><p>在spring4.2以后我们可以以更加简洁的方式来监听event的发布，监听事件我们不必再实现ApplicationListener接口了，只要在方法上添加注解@EventListener即可.</p><p>如果要监听多个事件类型的发布，可以在@EventListener(classes = {FaceEvent.class,ArmEvent.class})指定，spring会多次调用此方法来处理多个事件。但是注意此时，方法参数不能有多个，否则会发生转换异常，可以将使用多个事件的父类作为唯一的方法参数来接收处理事件，但除非必要否则并不推荐监听多个事件的发布。</p><p>如果有多个监听器监听同一事件，我们可以在方法上使用spring的@order注解来定义多个监听器的顺序,order越小,优先级越高.</p><p>@EventListener还有一个属性，condition（）里可以使用SPEL表达式来过滤监听到事件，即只有符合某种条件的才进行接收处理。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EventListener(condition = &quot;event.message == &#x27;message&#x27;&quot;)</span><br></code></pre></td></tr></table></figure><p>监听多个事件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EventListener(&#123;FaceEvent.class,ArmEvent.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent3</span><span class="hljs-params">(Object event)</span> &#123;<br><br>    <span class="hljs-keyword">if</span>(event <span class="hljs-keyword">instanceof</span> FaceEvent)&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;===&gt; B 收到人脸事件:  &#123;&#125;&quot;</span>,((FaceEvent) event).getEventData());<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(event <span class="hljs-keyword">instanceof</span> ArmEvent)&#123;<br>        <span class="hljs-type">ArmEvent</span> <span class="hljs-variable">armEvent</span> <span class="hljs-operator">=</span> (ArmEvent) event;<br>        LOGGER.info(<span class="hljs-string">&quot;===&gt; B 收到臂膀事件:  &#123;&#125;&quot;</span>,armEvent.getEventData());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><p>事件没要处理的监听器，就会被抛弃。</p></li><li><p>一个事件可以同时被多个监听处理类监听处理。</p></li><li><p>默认情况下事件是同步的，即事件被publish后会等待Listener的处理。如果发布事件处的业务存在事务，监听器处理也会在相同的事务中。</p></li><li><p>如果对于事件的处理不想受到影响，可以onApplicationEvent方法上加@Async支持异步或者在有@EventListener的注解方法上加上@Async。注：启动类上同时要加上@EnableAsync</p></li></ul><p><strong>利用@TransactionalEventListener实现监听事件时的事务隔离</strong><br>很多时候，只有事务提交之后我们才会发布相应的事件处理其他逻辑，比如用户注册之后，发送邮件或者短信。这时候就可以用注解@TransactionalEventListener。</p><p>@TransactionalEventListener和@EventListener都可以监听事件，但前者可以对发布事件和监听事件进行一些事务上的隔离。</p><p>@TransactionalEventListener是对@EventListener的一个扩展，允许将事件的监听器绑定到事务的某个阶段。可以绑定到以下事务阶段：</p><ul><li>AFTER_COMMIT （默认），事务提交后</li><li>AFTER_ROLLBACK ，事务回滚后</li><li>AFTER_COMPLETION ，事务完成，包括提交后和回滚后</li><li>BEFORE_COMMIT ，事务提交前****<br>@TransactionalEventListener指不和发布事件的方法在同一个事务内，发布事件的方法事务结束后才会执行本监听方法，监听逻辑内发生异常不会回滚发布事件方法的事务。</li></ul><p>@TransactionalEventListener有一个属性为fallbackExecution，默认为false，指发布事件的方法没有事务控制时，监听器不进行监听事件，此为默认情况！fallbackExecution=true，则指发布事件的方法没有事务控制时，监听方法仍可以监听事件进行处理。</p><p><strong>整合邮件功能</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-email<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.mail<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailInfo</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮件标题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String title;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮件内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String content;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮件主题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String subject;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 收件者账号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String destination;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 附件地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String attachmentPath;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 附件描述</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String attachmentDescription;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 附件名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String attachmentName;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * smtp地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String smtpAddr;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器端口号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer mailPort;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮箱登陆用户名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第三方登陆授权码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * https是否开启(0:开启  1：关闭)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer sslFlag;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮件发送时间的限制，单位毫秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long sendTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 连接时间，单位毫秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long connectTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮件接收时间限制，单位毫秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long receiveTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送者账号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String senderAccount;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮件最大发送值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer maxQuantity;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Date modifyTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 账户状态（0：启用，1：禁用）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer status;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 描述</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String remark;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义Event</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.email.EmailInfo;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.email.EmailServer;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationEvent;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendSimpleEmailEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span> &#123;<br><br>    <span class="hljs-keyword">private</span> EmailServer emailServer;<br><br>    <span class="hljs-keyword">private</span> EmailInfo emailInfo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SendSimpleEmailEvent</span><span class="hljs-params">(Object source)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SendSimpleEmailEvent</span><span class="hljs-params">(Object source, EmailServer emailServer, EmailInfo emailInfo)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>        <span class="hljs-built_in">this</span>.emailServer = emailServer;<br>        <span class="hljs-built_in">this</span>.emailInfo = emailInfo;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> EmailServer <span class="hljs-title function_">getEmailServer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> emailServer;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmailServer</span><span class="hljs-params">(EmailServer emailServer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.emailServer = emailServer;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> EmailInfo <span class="hljs-title function_">getEmailInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> emailInfo;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmailInfo</span><span class="hljs-params">(EmailInfo emailInfo)</span> &#123;<br>        <span class="hljs-built_in">this</span>.emailInfo = emailInfo;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>发送Event</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.json.JSONObject;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.email.EmailInfo;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.email.EmailServer;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.event.SendAttachmentEmailEvent;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.event.SendSimpleEmailEvent;<br><span class="hljs-keyword">import</span> com.ruoyi.common.utils.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationEventPublisher;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NotifyHandler</span>&#123;<br><br>    <span class="hljs-comment">//通知类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Email&quot;</span>;<br>    <span class="hljs-comment">//通知供应商</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;EmailProvider&quot;</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ApplicationEventPublisher applicationEventPublisher;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initClient</span><span class="hljs-params">(JSONObject initMessage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SendMessage</span><span class="hljs-params">(JSONObject sendMessage)</span> &#123;<br>        <span class="hljs-type">EmailServer</span> <span class="hljs-variable">emailServer</span> <span class="hljs-operator">=</span> sendMessage.get(<span class="hljs-string">&quot;emailServer&quot;</span>, EmailServer.class);<br>        <span class="hljs-type">EmailInfo</span> <span class="hljs-variable">emailInfo</span> <span class="hljs-operator">=</span> sendMessage.get(<span class="hljs-string">&quot;emailInfo&quot;</span>, EmailInfo.class);<br><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(emailInfo.getAttachmentPath()))&#123;<br>            <span class="hljs-type">SendSimpleEmailEvent</span> <span class="hljs-variable">sendSimpleEmailEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendSimpleEmailEvent</span>(<span class="hljs-built_in">this</span>, emailServer, emailInfo);<br>            applicationEventPublisher.publishEvent(sendSimpleEmailEvent);<br>        &#125;<br>        <span class="hljs-type">SendAttachmentEmailEvent</span> <span class="hljs-variable">sendAttachmentEmailEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendAttachmentEmailEvent</span>(<span class="hljs-built_in">this</span>, emailServer, emailInfo);<br>        applicationEventPublisher.publishEvent(sendAttachmentEmailEvent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson2.JSON;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.email.EmailInfo;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.email.EmailServer;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.event.SendAttachmentEmailEvent;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.event.SendSimpleEmailEvent;<br><span class="hljs-keyword">import</span> com.ruoyi.common.utils.StringUtils;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.apache.commons.mail.*;<br><span class="hljs-keyword">import</span> org.springframework.context.event.EventListener;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Async;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEmilUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CHARSET_UTF8</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UTF-8&quot;</span>;<br><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-meta">@EventListener</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushSimpleEmail</span><span class="hljs-params">(SendSimpleEmailEvent sendSimpleEmailEvent)</span> &#123;<br>        <span class="hljs-type">EmailServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> sendSimpleEmailEvent.getEmailServer();<br>        <span class="hljs-type">EmailInfo</span> <span class="hljs-variable">emailInfo</span> <span class="hljs-operator">=</span> sendSimpleEmailEvent.getEmailInfo();<br><br>        log.info(<span class="hljs-string">&quot;发送邮件：&#123;&#125;，至邮件服务器：&#123;&#125;&quot;</span>, JSON.toJSONString(emailInfo), JSON.toJSONString(server));<br>        <span class="hljs-type">Email</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleEmail</span>();<br>        email.setHostName(server.getSmtpAddr());<br>        email.setSmtpPort(server.getMailPort());<br>        <span class="hljs-comment">//用户名称和授权码</span><br>        email.setAuthentication(server.getUserName(), server.getPassword());<br>        email.setCharset(CHARSET_UTF8);<br>        <span class="hljs-keyword">try</span> &#123;<br>            email.addTo(emailInfo.getDestination());<br>            email.setFrom(server.getUserName(), server.getSenderAccount());<br>            email.setSubject(emailInfo.getSubject());<br>            email.setMsg(emailInfo.getContent());<br>            email.setSSLOnConnect(server.getSslFlag() == <span class="hljs-number">0</span>);<br>            Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(emailInfo.getTitle())) &#123;<br>                map.put(<span class="hljs-string">&quot;主题&quot;</span>, emailInfo.getTitle());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(<span class="hljs-string">&quot;主题&quot;</span>, emailInfo.getSubject());<br>            &#125;<br>            email.setHeaders(map);<br>            email.setSentDate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            email.send();<br>            log.info(<span class="hljs-string">&quot;邮件：&#123;&#125;,发送成功&quot;</span>, JSON.toJSONString(emailInfo));<br>        &#125; <span class="hljs-keyword">catch</span> (EmailException e) &#123;<br>            log.info(<span class="hljs-string">&quot;邮件发送失败message: &#123;&#125;&quot;</span>, e.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-meta">@EventListener</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushAttachmentEmail</span><span class="hljs-params">(SendAttachmentEmailEvent sendAttachmentEmailEvent)</span> &#123;<br>        <span class="hljs-type">EmailServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> sendAttachmentEmailEvent.getEmailServer();<br>        <span class="hljs-type">EmailInfo</span> <span class="hljs-variable">emailInfo</span> <span class="hljs-operator">=</span> sendAttachmentEmailEvent.getEmailInfo();<br><br>        log.info(<span class="hljs-string">&quot;发送带附件的邮件：&#123;&#125;，至邮件服务器：&#123;&#125;&quot;</span>, JSON.toJSONString(emailInfo), JSON.toJSONString(server));<br>        <span class="hljs-type">EmailAttachment</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmailAttachment</span>();<br>        attachment.setDescription(emailInfo.getAttachmentDescription());<br>        attachment.setDisposition(EmailAttachment.ATTACHMENT);<br>        attachment.setName(emailInfo.getAttachmentName());<br>        attachment.setPath(emailInfo.getAttachmentPath());<br><br>        <span class="hljs-type">MultiPartEmail</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MultiPartEmail</span>();<br>        email.setHostName(server.getSmtpAddr());<br>        email.setSmtpPort(server.getMailPort());<br>        <span class="hljs-comment">//用户名称和授权码</span><br>        email.setAuthentication(server.getUserName(), server.getPassword());<br>        email.setCharset(CHARSET_UTF8);<br>        <span class="hljs-keyword">try</span> &#123;<br>            email.addTo(emailInfo.getDestination());<br>            <span class="hljs-keyword">if</span> (server.getSslFlag() == <span class="hljs-number">0</span>) &#123;<br>                email.setSSLOnConnect(<span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                email.setSSLOnConnect(<span class="hljs-literal">false</span>);<br>            &#125;<br>            email.attach(attachment);<br>            email.setFrom(server.getUserName(), server.getSenderAccount());<br>            email.setSubject(emailInfo.getSubject());<br>            email.setMsg(emailInfo.getContent());<br>            Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            map.put(<span class="hljs-string">&quot;主题&quot;</span>, emailInfo.getTitle());<br>            email.send();<br>            email.setHeaders(map);<br>            log.info(<span class="hljs-string">&quot;带附件的邮件发送成功：&#123;&#125;&quot;</span>, JSON.toJSONString(attachment));<br>        &#125; <span class="hljs-keyword">catch</span> (EmailException e) &#123;<br>            log.info(<span class="hljs-string">&quot;邮件发送失败：&#123;&#125;,message:&#123;&#125;&quot;</span>, e, JSON.toJSONString(attachment));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>集成阿里云发送短信</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- aliyun sms SDK --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tea-openapi<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dysmsapi20170525<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>定义事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunSmsInfo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String signName;<br><br>    <span class="hljs-keyword">private</span> String phoneNumbers;<br><br>    <span class="hljs-keyword">private</span> String templateCode;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunSmsServer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String accessKeyId;<br><br>    <span class="hljs-keyword">private</span> String accessKeySecret;<br><br>    <span class="hljs-keyword">private</span> String orginId;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.aliyunSms.AliyunSmsInfo;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.aliyunSms.AliyunSmsServer;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationEvent;<br><br><span class="hljs-keyword">import</span> java.time.Clock;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义监听事件</span><br><span class="hljs-comment"> * 通过ApplicationContextAware我们可以把系统中所有ApplicationEvent传播给系统中所有的ApplicationListener。</span><br><span class="hljs-comment"> * 因此，我们只需要构造好我们自己的ApplicationEvent和ApplicationListener，就可以在系统中实现相应的监听器。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendAliyunSmsEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span> &#123;<br><br>    <span class="hljs-keyword">private</span> AliyunSmsInfo aliyunSmsInfo;<br><br>    <span class="hljs-keyword">private</span> AliyunSmsServer aliyunSmsServer;<br><br>    <span class="hljs-keyword">private</span> Map aliyunSmsParams;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SendAliyunSmsEvent</span><span class="hljs-params">(Object source, AliyunSmsServer aliyunSmsServer, AliyunSmsInfo aliyunSmsInfo ,Map map)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>        <span class="hljs-built_in">this</span>.aliyunSmsInfo = aliyunSmsInfo;<br>        <span class="hljs-built_in">this</span>.aliyunSmsServer = aliyunSmsServer;<br>        <span class="hljs-built_in">this</span>.aliyunSmsParams = map;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Map <span class="hljs-title function_">getAliyunSmsParams</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> aliyunSmsParams;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAliyunSmsParams</span><span class="hljs-params">(Map aliyunSmsParams)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aliyunSmsParams = aliyunSmsParams;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SendAliyunSmsEvent</span><span class="hljs-params">(Object source, Clock clock)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source, clock);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> AliyunSmsInfo <span class="hljs-title function_">getAliyunSmsInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> aliyunSmsInfo;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAliyunSmsInfo</span><span class="hljs-params">(AliyunSmsInfo aliyunSmsInfo)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aliyunSmsInfo = aliyunSmsInfo;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> AliyunSmsServer <span class="hljs-title function_">getAliyunSmsServer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> aliyunSmsServer;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAliyunSmsServer</span><span class="hljs-params">(AliyunSmsServer aliyunSmsServer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aliyunSmsServer = aliyunSmsServer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.json.JSONObject;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.aliyunSms.AliyunSmsInfo;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.aliyunSms.AliyunSmsServer;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.email.EmailServer;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.event.SendAliyunSmsEvent;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationEvent;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationEventPublisher;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> javax.jws.Oneway;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunSmsHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NotifyHandler</span>&#123;<br>    <span class="hljs-comment">//通知类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ShortMessage&quot;</span>;<br>    <span class="hljs-comment">//通知供应商</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ShortMessageAlibabaServer&quot;</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ApplicationEventPublisher applicationEventPublisher;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initClient</span><span class="hljs-params">(JSONObject initMessage)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SendMessage</span><span class="hljs-params">(JSONObject sendMessage)</span> &#123;<br>        <span class="hljs-type">AliyunSmsServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> sendMessage.getBean(<span class="hljs-string">&quot;configuration&quot;</span>, AliyunSmsServer.class);<br>        <span class="hljs-type">AliyunSmsInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> sendMessage.getBean(<span class="hljs-string">&quot;template&quot;</span>,AliyunSmsInfo.class);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">templateParam</span> <span class="hljs-operator">=</span> sendMessage.get(<span class="hljs-string">&quot;templateParam&quot;</span>);<br>        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(templateParam).toBean(Map.class);<br>        <span class="hljs-type">SendAliyunSmsEvent</span> <span class="hljs-variable">sendAliyunSmsEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendAliyunSmsEvent</span>(<span class="hljs-built_in">this</span>, server, info, map);<br>        applicationEventPublisher.publishEvent(sendAliyunSmsEvent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.json.JSONObject;<br><span class="hljs-keyword">import</span> com.aliyun.dysmsapi20170525.models.SendSmsResponse;<br><span class="hljs-keyword">import</span> com.aliyun.tea.TeaException;<br><span class="hljs-keyword">import</span> com.ruoyi.common.exception.ServiceException;<br><span class="hljs-keyword">import</span> lombok.NonNull;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 阿里云异步短信工具类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yecao</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunSmsUtils</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(AliyunSmsUtils.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> com.aliyun.dysmsapi20170525.Client instance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initClient</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String accessKeyId, <span class="hljs-meta">@NonNull</span> String accessKeySecret)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == instance)&#123;<br>            <span class="hljs-keyword">synchronized</span> (AliyunSmsUtils.class)&#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == instance)&#123;<br>                    com.aliyun.teaopenapi.models.<span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.aliyun.teaopenapi.models.Config()<br>                            <span class="hljs-comment">// 您的 AccessKey ID</span><br>                            .setAccessKeyId(accessKeyId)<br>                            <span class="hljs-comment">// 您的 AccessKey Secret</span><br>                            .setAccessKeySecret(accessKeySecret);<br>                    <span class="hljs-comment">// 访问的域名</span><br>                    config.endpoint = <span class="hljs-string">&quot;dysmsapi.aliyuncs.com&quot;</span>;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.aliyun.dysmsapi20170525.Client(config);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendSms</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String signName, <span class="hljs-meta">@NonNull</span> String phoneNumbers, <span class="hljs-meta">@NonNull</span> String templateCode,</span><br><span class="hljs-params">                               <span class="hljs-meta">@NonNull</span> Map templateParam)</span> &#123;<br>        com.aliyun.dysmsapi20170525.models.<span class="hljs-type">SendSmsRequest</span> <span class="hljs-variable">sendSmsRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.aliyun.dysmsapi20170525.models.SendSmsRequest();<br>        sendSmsRequest.setPhoneNumbers(phoneNumbers);<br>        sendSmsRequest.setTemplateCode(templateCode);<br>        sendSmsRequest.setTemplateParam(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(templateParam).toString());<br>        sendSmsRequest.setSignName(signName);<br>        com.aliyun.teautil.models.<span class="hljs-type">RuntimeOptions</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.aliyun.teautil.models.RuntimeOptions();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 复制代码运行请自行打印 API 的返回值</span><br>            <span class="hljs-type">SendSmsResponse</span> <span class="hljs-variable">sendSmsResponse</span> <span class="hljs-operator">=</span> instance.sendSmsWithOptions(sendSmsRequest, runtime);<br>            log.info(<span class="hljs-string">&quot;消息已发送至：&#123;&#125;，响应信息：&#123;&#125;&quot;</span>,phoneNumbers,sendSmsResponse.getBody().getMessage());<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;OK&quot;</span>.equals(sendSmsResponse.getBody().getMessage()))&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceException</span>(sendSmsResponse.getBody().getMessage());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (TeaException error) &#123;<br>            <span class="hljs-comment">// 如有需要，请打印 error</span><br>            com.aliyun.teautil.Common.assertAsString(error.message);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception errors) &#123;<br>            <span class="hljs-type">TeaException</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TeaException</span>(errors.getMessage(), errors);<br>            <span class="hljs-comment">// 如有需要，请打印 error</span><br>            com.aliyun.teautil.Common.assertAsString(error.message);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceException</span>(error.message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.aliyunSms.AliyunSmsInfo;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.aliyunSms.AliyunSmsServer;<br><span class="hljs-keyword">import</span> com.ruoyi.aiot.domain.event.SendAliyunSmsEvent;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.context.event.EventListener;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Async;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAliyunSmsUtils</span> &#123;<br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-meta">@EventListener</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendAliyunSms</span><span class="hljs-params">(SendAliyunSmsEvent sendAliyunSmsEvent)</span>&#123;<br>        <span class="hljs-type">AliyunSmsServer</span> <span class="hljs-variable">aliyunSmsServer</span> <span class="hljs-operator">=</span> sendAliyunSmsEvent.getAliyunSmsServer();<br>        <span class="hljs-type">AliyunSmsInfo</span> <span class="hljs-variable">aliyunSmsInfo</span> <span class="hljs-operator">=</span> sendAliyunSmsEvent.getAliyunSmsInfo();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">aliyunSmsParams</span> <span class="hljs-operator">=</span> sendAliyunSmsEvent.getAliyunSmsParams();<br>        <span class="hljs-keyword">try</span> &#123;<br>            AliyunSmsUtils.initClient(aliyunSmsServer.getAccessKeyId(),aliyunSmsServer.getAccessKeySecret());<br>            AliyunSmsUtils.sendSms(aliyunSmsInfo.getSignName(),<br>                    aliyunSmsInfo.getPhoneNumbers(),<br>                    aliyunSmsInfo.getTemplateCode(),<br>                    aliyunSmsParams);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最强分布式工具Redisson</title>
    <link href="/2022/11/05/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E5%85%B7Redisson/"/>
    <url>/2022/11/05/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E5%85%B7Redisson/</url>
    
    <content type="html"><![CDATA[<h1 id="最强分布式工具Redisson"><a href="#最强分布式工具Redisson" class="headerlink" title="最强分布式工具Redisson"></a>最强分布式工具Redisson</h1><h2 id="什么是Redisson？"><a href="#什么是Redisson？" class="headerlink" title="什么是Redisson？"></a><strong>什么是Redisson？</strong></h2><p>一个基于Redis实现的分布式工具，有基本分布式对象和高级又抽象的分布式服务，为每个试图再造分布式轮子的程序员带来了大部分分布式问题的解决办法。</p><h2 id="Redisson和Jedis、Lettuce有什么区别？"><a href="#Redisson和Jedis、Lettuce有什么区别？" class="headerlink" title="Redisson和Jedis、Lettuce有什么区别？"></a><strong>Redisson和Jedis、Lettuce有什么区别？</strong></h2><ul><li><p>Redisson和它俩的区别就像一个用鼠标操作图形化界面，一个用命令行操作文件。Redisson是更高层的抽象，Jedis和Lettuce是Redis命令的封装。</p></li><li><p>Jedis是Redis官方推出的用于通过Java连接Redis客户端的一个工具包，提供了Redis的各种命令支持</p></li><li><p>Lettuce是一种可扩展的线程安全的 Redis 客户端，通讯框架基于Netty，支持高级的 Redis 特性，比如哨兵，集群，管道，自动重新连接和Redis数据模型。 Spring Boot 2.x 开始 Lettuce 已取代 Jedis 成为首选 Redis 的客户端。</p></li><li><p>Redisson是架设在Redis基础上，通讯基于Netty的综合的、新型的中间件，企业级开发中使用Redis的最佳范本</p></li></ul><p>Jedis把Redis命令封装好，Lettuce则进一步有了更丰富的Api，也支持集群等模式。但是两者也都点到为止，只给了你操作Redis数据库的脚手架，而Redisson则是基于Redis、Lua和Netty建立起了成熟的分布式解决方案，甚至redis官方都推荐的一种工具集。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="分布式锁怎么实现"><a href="#分布式锁怎么实现" class="headerlink" title="分布式锁怎么实现"></a><strong>分布式锁怎么实现</strong></h3><p>分布式锁是并发业务下的刚需，虽然实现五花八门：ZooKeeper有Znode顺序节点，数据库有表级锁和乐/悲观锁，Redis有setNx，但是殊途同归，最终还是要回到互斥上来，本篇介绍Redisson，那就以redis为例。</p><h3 id="怎么写一个简单的Redis分布式锁？"><a href="#怎么写一个简单的Redis分布式锁？" class="headerlink" title="怎么写一个简单的Redis分布式锁？"></a><strong>怎么写一个简单的Redis分布式锁？</strong></h3><p>以Spring Data Redis为例，用RedisTemplate来操作Redis（setIfAbsent已经是setNx + expire的合并命令），如下</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加锁</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key, String value, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>    <span class="hljs-keyword">return</span> redisTemplate.opsForValue().setIfAbsent(key, value, timeout, unit);<br>&#125;<br><span class="hljs-comment">// 解锁，防止删错别人的锁，以uuid为value校验是否自己的锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String lockName, String uuid)</span> &#123;<br>    <span class="hljs-keyword">if</span>(uuid.equals(redisTemplate.opsForValue().get(lockName))&#123;        redisTemplate.opsForValue().del(lockName);    &#125;<br>&#125;<br><br><span class="hljs-comment">// 结构</span><br><span class="hljs-keyword">if</span>(tryLock)&#123;<br>    <span class="hljs-comment">// todo</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    unlock;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>简单1.0版本完成，聪明的小张一眼看出，这是锁没错，但get和del操作非原子性，并发一旦大了，无法保证进程安全。于是小张提议，用Lua脚本</p><h3 id="Lua脚本是什么？"><a href="#Lua脚本是什么？" class="headerlink" title="Lua脚本是什么？"></a><strong>Lua脚本是什么？</strong></h3><p>Lua脚本是redis已经内置的一种轻量小巧语言，其执行是通过redis的<strong>eval</strong>/<strong>evalsha</strong>命令来运行，把操作封装成一个Lua脚本，如论如何都是一次执行的原子操作。</p><p>于是2.0版本通过Lua脚本删除</p><p>lockDel.lua如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <br>    then <br>-- 执行删除操作<br>        <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <br>    <span class="hljs-keyword">else</span> <br>-- 不成功，返回<span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <br>end<br>Copy<br></code></pre></td></tr></table></figure><p>delete操作时执行Lua命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解锁脚本</span><br>DefaultRedisScript&lt;Object&gt; unlockScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>();<br>unlockScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;lockDel.lua&quot;</span>)));<br><br><span class="hljs-comment">// 执行lua脚本解锁</span><br>redisTemplate.execute(unlockScript, Collections.singletonList(keyName), value);<br>Copy<br></code></pre></td></tr></table></figure><p>2.0似乎更像一把锁，但好像又缺少了什么，小张一拍脑袋，synchronized和ReentrantLock都很丝滑，因为他们都是可重入锁，一个线程多次拿锁也不会死锁，我们需要可重入。</p><h3 id="怎么保证可重入？"><a href="#怎么保证可重入？" class="headerlink" title="怎么保证可重入？"></a><strong>怎么保证可重入？</strong></h3><p>重入就是，同一个线程多次获取同一把锁是允许的，不会造成死锁，这一点synchronized偏向锁提供了很好的思路，synchronized的实现重入是在JVM层面，JAVA对象头MARK WORD中便藏有线程ID和计数器来对当前线程做重入判断，避免每次CAS。</p><blockquote><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁标志是否设置成1：没有则CAS竞争；设置了，则CAS将对象头偏向锁指向当前线程。</p><p>再维护一个计数器，同个线程进入则自增1，离开再减1，直到为0才能释放</p></blockquote><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>仿造该方案，我们需改造Lua脚本：</p><p>1.需要存储 锁名称<strong>lockName</strong>、获得该锁的<strong>线程id</strong>和对应线程的<strong>进入次数count</strong></p><p>2.加锁</p><p>每次线程获取锁时，判断是否已存在该锁</p><ul><li><p>不存在</p></li><li><p>设置hash的key为线程id，value初始化为1</p></li><li><p>设置过期时间</p></li><li><p>返回获取锁成功true</p></li><li><p>存在</p></li><li><p>继续判断是否存在当前线程id的hash key，存在线程key的value + 1，重入次数增加1，设置过期时间</p><p>不存在，返回加锁失败</p></li></ul><p>3.解锁</p><p>每次线程来解锁时，判断是否已存在该锁</p><ul><li>存在</li><li>是否有该线程的id的hash key，有则减1，无则返回解锁失败</li><li>减1后，判断剩余count是否为0，为0则说明不再需要这把锁，执行del命令删除</li></ul><blockquote><h4 id="解锁的判断-当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除"><a href="#解锁的判断-当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除" class="headerlink" title="解锁的判断,当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除"></a>解锁的判断,当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除</h4></blockquote><p>加锁 lock.lua</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">local</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> KEYS[<span class="hljs-number">1</span>];<br><span class="hljs-type">local</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ARGV[<span class="hljs-number">1</span>];<br><span class="hljs-type">local</span> <span class="hljs-variable">releaseTime</span> <span class="hljs-operator">=</span> ARGV[<span class="hljs-number">2</span>];<br><br>-- lockname不存在<br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, key) == <span class="hljs-number">0</span>) then<br>    redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, key, threadId, <span class="hljs-string">&#x27;1&#x27;</span>);<br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, key, releaseTime);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end;<br><br>-- 当前线程已id存在<br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="hljs-number">1</span>) then<br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="hljs-string">&#x27;1&#x27;</span>);<br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, key, releaseTime);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>Copy<br></code></pre></td></tr></table></figure><p>解锁 unlock.lua</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">local</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> KEYS[<span class="hljs-number">1</span>];<br><span class="hljs-type">local</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ARGV[<span class="hljs-number">1</span>];<br><br>-- lockname、threadId不存在<br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="hljs-number">0</span>) then<br>    <span class="hljs-keyword">return</span> nil;<br>end;<br><br>-- 计数器-<span class="hljs-number">1</span><br><span class="hljs-type">local</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, key, threadId, -<span class="hljs-number">1</span>);<br><br>-- 删除lock<br><span class="hljs-title function_">if</span> <span class="hljs-params">(count == <span class="hljs-number">0</span>)</span> then<br>    redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, key);<br>    <span class="hljs-keyword">return</span> nil;<br>end;<br>Copy<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 原生redis实现分布式锁</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/2/6 10:51 下午</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> DefaultRedisScript&lt;Long&gt; lockScript;<br>    <span class="hljs-keyword">private</span> DefaultRedisScript&lt;Object&gt; unlockScript;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLock</span><span class="hljs-params">(RedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-comment">// 加载加锁的脚本</span><br>        lockScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.lockScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;lock.lua&quot;</span>)));<br>        <span class="hljs-built_in">this</span>.lockScript.setResultType(Long.class);<br>        <span class="hljs-comment">// 加载释放锁的脚本</span><br>        unlockScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.unlockScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>)));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String lockName, <span class="hljs-type">long</span> releaseTime)</span> &#123;<br>        <span class="hljs-comment">// 存入的线程信息的前缀</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br><br>        <span class="hljs-comment">// 执行脚本</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Long) redisTemplate.execute(<br>                lockScript,<br>                Collections.singletonList(lockName),<br>                key + Thread.currentThread().getId(),<br>                releaseTime);<br><br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span> &amp;&amp; result.intValue() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解锁</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String lockName, String key)</span> &#123;<br>        redisTemplate.execute(unlockScript,<br>                Collections.singletonList(lockName),<br>                key + Thread.currentThread().getId()<br>                );<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>严谨的小张觉得虽然当个普通互斥锁，已经稳稳够用，可是业务里总是又很多特殊情况的，<strong>比如A进程在获取到锁的时候，因业务操作时间太长，锁释放了但是业务还在执行，而此刻B进程又可以正常拿到锁做业务操作，两个进程操作就会存在依旧有共享资源的问题</strong>。</p><p>而且如果负责储存这个分布式锁的<strong>Redis节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态</strong>。</p><p>所以我们希望在这种情况时，可以延长锁的releaseTime延迟释放锁来直到完成业务期望结果，这种不断延长锁过期时间来保证业务执行完成的操作就是锁续约。</p><h2 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 原生，本章使用--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 另一种Spring集成starter，本章未使用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>Copy<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissionConfig</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String redisHost;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">6379</span>;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">getRedisson</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().<br>                setAddress(<span class="hljs-string">&quot;redis://&quot;</span> + redisHost + <span class="hljs-string">&quot;:&quot;</span> + port).<br>                setPassword(password);<br>        config.setCodec(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonJacksonCodec</span>());<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><h3 id="启用分布式锁"><a href="#启用分布式锁" class="headerlink" title="启用分布式锁"></a>启用分布式锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-type">RLock</span> <span class="hljs-variable">rLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(lockName);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLocked</span> <span class="hljs-operator">=</span> rLock.tryLock(expireTime, TimeUnit.MILLISECONDS);<br>    <span class="hljs-keyword">if</span> (isLocked) &#123;<br>        <span class="hljs-comment">// TODO</span><br>                &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            rLock.unlock();<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure><h2 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h2><p>RLock是Redisson分布式锁的最核心接口，继承了concurrent包的Lock接口和自己的RLockAsync接口，RLockAsync的返回值都是RFuture，是Redisson执行异步实现的核心逻辑，也是Netty发挥的主要阵地。</p><h3 id="RLock如何加锁？"><a href="#RLock如何加锁？" class="headerlink" title="RLock如何加锁？"></a><strong>RLock如何加锁？</strong></h3><p>从RLock进入，找到RedissonLock类，找到tryLock方法再递进到干事的tryAcquireOnceAsync方法，这是加锁的主要代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RFuture&lt;Boolean&gt; <span class="hljs-title function_">tryAcquireOnceAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>        <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1L</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            RFuture&lt;Boolean&gt; ttlRemainingFuture = <span class="hljs-built_in">this</span>.tryLockInnerAsync(waitTime, <span class="hljs-built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);<br>            ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (ttlRemaining) &#123;<br>                        <span class="hljs-built_in">this</span>.scheduleExpirationRenewal(threadId);<br>                    &#125;<br><br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>        &#125;<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure><p>此处出现leaseTime时间判断的2个分支，实际上就是加锁时是否设置过期时间，未设置过期时间（-1）时则会有<strong>watchDog</strong>的<strong>锁续约</strong>（下文），一个注册了加锁事件的续约任务。我们先来看有过期时间<strong>tryLockInnerAsync</strong>部分，</p><p>evalWriteAsync是eval命令执行lua的入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; RFuture&lt;T&gt; <span class="hljs-title function_">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalLockLeaseTime = unit.toMillis(leaseTime);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.commandExecutor.evalWriteAsync(<span class="hljs-built_in">this</span>.getName(), LongCodec.INSTANCE, command, <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, Collections.singletonList(<span class="hljs-built_in">this</span>.getName()), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-built_in">this</span>.internalLockLeaseTime, <span class="hljs-built_in">this</span>.getLockName(threadId)&#125;);<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure><p>这里揭开真面目，eval命令执行Lua脚本的地方，此处的Lua脚本展开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">-- 不存在该key时<br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>) then <br>  -- 新增该锁并且hash中该线程id对应的count置<span class="hljs-number">1</span><br>  redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>); <br>  -- 设置过期时间<br>  redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]); <br>  <span class="hljs-keyword">return</span> nil; <br>end; <br><br>-- 存在该key 并且 hash中线程id的key也存在<br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>) then <br>  -- 线程重入次数++<br>  redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>); <br>  redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]); <br>  <span class="hljs-keyword">return</span> nil; <br>end; <br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;pttl&#x27;</span>, KEYS[<span class="hljs-number">1</span>]);<br>Copy<br></code></pre></td></tr></table></figure><p>和前面我们写自定义的分布式锁的脚本几乎一致，看来redisson也是一样的实现，具体参数分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// keyName</span><br>KEYS[<span class="hljs-number">1</span>] = Collections.singletonList(<span class="hljs-built_in">this</span>.getName())<br><span class="hljs-comment">// leaseTime</span><br>ARGV[<span class="hljs-number">1</span>] = <span class="hljs-built_in">this</span>.internalLockLeaseTime<br><span class="hljs-comment">// uuid+threadId组合的唯一值</span><br>ARGV[<span class="hljs-number">2</span>] = <span class="hljs-built_in">this</span>.getLockName(threadId)<br>Copy<br></code></pre></td></tr></table></figure><p>总共3个参数完成了一段逻辑：</p><p>判断该锁是否已经有对应hash表存在，</p><p>• 没有对应的hash表：则set该hash表中一个entry的key为锁名称，value为1，之后设置该hash表失效时间为leaseTime</p><p>• 存在对应的hash表：则将该lockName的value执行+1操作，也就是计算进入次数，再设置失效时间leaseTime</p><p>• 最后返回这把锁的ttl剩余时间</p><p>既然如此，那解锁的步骤也肯定有对应的-1操作，再看unlock方法，同样查找方法名，一路到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> RFuture&lt;Boolean&gt; <span class="hljs-title function_">unlockInnerAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> threadId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.commandExecutor.evalWriteAsync(<span class="hljs-built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); if (counter &gt; 0) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); return 0; else redis.call(&#x27;del&#x27;, KEYS[1]); redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end; return nil;&quot;</span>, Arrays.asList(<span class="hljs-built_in">this</span>.getName(), <span class="hljs-built_in">this</span>.getChannelName()), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;LockPubSub.unlockMessage, <span class="hljs-built_in">this</span>.internalLockLeaseTime, <span class="hljs-built_in">this</span>.getLockName(threadId)&#125;);<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure><p>掏出Lua部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">-- 不存在key<br><span class="hljs-title function_">if</span> <span class="hljs-params">(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">3</span>])</span> == <span class="hljs-number">0</span>) then <br>  <span class="hljs-keyword">return</span> nil;<br>end;<br>-- 计数器 -<span class="hljs-number">1</span><br><span class="hljs-type">local</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">3</span>], -<span class="hljs-number">1</span>); <br><span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">0</span>) then <br>  -- 过期时间重设<br>  redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]); <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br><span class="hljs-keyword">else</span><br>  -- 删除并发布解锁消息<br>  redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]); <br>  redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>, KEYS[<span class="hljs-number">2</span>], ARGV[<span class="hljs-number">1</span>]); <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end; <br><span class="hljs-keyword">return</span> nil;<br>Copy<br></code></pre></td></tr></table></figure><p>该Lua KEYS有2个<code>Arrays.asList(getName(), getChannelName())</code></p><blockquote><p>name 锁名称 channelName，用于pubSub发布消息的channel名称</p></blockquote><p>ARGV变量有三个<code>LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId)</code></p><blockquote><p>LockPubSub.UNLOCK_MESSAGE，channel发送消息的类别，此处解锁为0 internalLockLeaseTime，watchDog配置的超时时间，默认为30s lockName 这里的lockName指的是uuid和threadId组合的唯一值</p></blockquote><p>步骤如下：</p><p>1.如果该锁不存在则返回nil；</p><p>2.如果该锁存在则将其线程的hash key计数器-1，</p><p>3.计数器counter&gt;0，重置下失效时间，返回0；否则，删除该锁，发布解锁消息unlockMessage，返回1；</p><p>其中unLock的时候使用到了Redis发布订阅PubSub完成消息通知。</p><p>而订阅的步骤就在RedissonLock的加锁入口的lock方法里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">ttl</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.tryAcquire(-<span class="hljs-number">1L</span>, leaseTime, unit, threadId);<br>        <span class="hljs-keyword">if</span> (ttl != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 订阅</span><br>            RFuture&lt;RedissonLockEntry&gt; future = <span class="hljs-built_in">this</span>.subscribe(threadId);<br>            <span class="hljs-keyword">if</span> (interruptibly) &#123;<br>                <span class="hljs-built_in">this</span>.commandExecutor.syncSubscriptionInterrupted(future);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.commandExecutor.syncSubscription(future);<br>            &#125;<br>            <span class="hljs-comment">// 省略</span><br>Copy<br></code></pre></td></tr></table></figure><p><strong>当锁被其他线程占用时，通过监听锁的释放通知（在其他线程通过RedissonLock释放锁时，会通过发布订阅pub/sub功能发起通知），等待锁被其他线程释放，也是为了避免自旋的一种常用效率手段。</strong></p><h3 id="解锁消息"><a href="#解锁消息" class="headerlink" title="解锁消息"></a>解锁消息</h3><p>为了一探究竟通知了什么，通知后又做了什么，进入LockPubSub。</p><p>这里只有一个明显的监听方法onMessage，其订阅和信号量的释放都在父类PublishSubscribe，我们只关注监听事件的实际操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(RedissonLockEntry value, Long message)</span> &#123;<br>        Runnable runnableToExecute;<br>        <span class="hljs-keyword">if</span> (message.equals(unlockMessage)) &#123;<br>            <span class="hljs-comment">// 从监听器队列取监听线程执行监听回调</span><br>            runnableToExecute = (Runnable)value.getListeners().poll();<br>            <span class="hljs-keyword">if</span> (runnableToExecute != <span class="hljs-literal">null</span>) &#123;<br>                runnableToExecute.run();<br>            &#125;<br>            <span class="hljs-comment">// getLatch()返回的是Semaphore，信号量，此处是释放信号量</span><br>            <span class="hljs-comment">// 释放信号量后会唤醒等待的entry.getLatch().tryAcquire去再次尝试申请锁</span><br>            value.getLatch().release();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.equals(readUnlockMessage)) &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                runnableToExecute = (Runnable)value.getListeners().poll();<br>                <span class="hljs-keyword">if</span> (runnableToExecute == <span class="hljs-literal">null</span>) &#123;<br>                    value.getLatch().release(value.getLatch().getQueueLength());<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                runnableToExecute.run();<br>            &#125;<br>        &#125;<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure><p>发现一个是<strong>默认解锁消息</strong>，一个是*<em>读锁解锁消息*</em>**，**因为redisson是有提供读写锁的，而读写锁读读情况和读写、写写情况互斥情况不同，我们只看上面的默认解锁消息unlockMessage分支</p><p>LockPubSub监听最终执行了2件事</p><ol><li>runnableToExecute.run() 执行监听回调</li><li>value.getLatch().release(); 释放信号量</li></ol><p>Redisson通过<strong>LockPubSub</strong>监听解锁消息，执行监听回调和释放信号量通知等待线程可以重新抢锁。</p><p>这时再回来看tryAcquireOnceAsync另一分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RFuture&lt;Boolean&gt; <span class="hljs-title function_">tryAcquireOnceAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>        <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1L</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            RFuture&lt;Boolean&gt; ttlRemainingFuture = <span class="hljs-built_in">this</span>.tryLockInnerAsync(waitTime, <span class="hljs-built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);<br>            ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (ttlRemaining) &#123;<br>                        <span class="hljs-built_in">this</span>.scheduleExpirationRenewal(threadId);<br>                    &#125;<br><br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>        &#125;<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure><p>可以看到，无超时时间时，在执行加锁操作后，还执行了一段费解的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (ttlRemaining) &#123;<br>                        <span class="hljs-built_in">this</span>.scheduleExpirationRenewal(threadId);<br>                    &#125;<br><br>                &#125;<br>            &#125;)<br>Copy<br></code></pre></td></tr></table></figure><p>此处涉及到Netty的Future/Promise-Listener模型（参考<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/rickiyang/p/12742091.html">Netty中的异步编程</a>），Redisson中几乎全部以这种方式通信（所以说Redisson是基于Netty通信机制实现的），理解这段逻辑可以试着先理解</p><blockquote><p>在 Java 的 Future 中，业务逻辑为一个 Callable 或 Runnable 实现类，该类的 call()或 run()执行完毕意味着业务逻辑的完结，在 Promise 机制中，可以在业务逻辑中人工设置业务逻辑的成功与失败，这样更加方便的监控自己的业务逻辑。</p></blockquote><p>这块代码的表面意义就是，在执行异步加锁的操作后，加锁成功则根据加锁完成返回的ttl是否过期来确认是否执行一段定时任务。</p><p>这段定时任务的就是watchDog的核心。</p><h3 id="锁续约"><a href="#锁续约" class="headerlink" title="锁续约"></a>锁续约</h3><p>查看RedissonLock.this.scheduleExpirationRenewal(threadId)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleExpirationRenewal</span><span class="hljs-params">(<span class="hljs-type">long</span> threadId)</span> &#123;<br>        RedissonLock.<span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedissonLock</span>.ExpirationEntry();<br>        RedissonLock.<span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">oldEntry</span> <span class="hljs-operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(<span class="hljs-built_in">this</span>.getEntryName(), entry);<br>        <span class="hljs-keyword">if</span> (oldEntry != <span class="hljs-literal">null</span>) &#123;<br>            oldEntry.addThreadId(threadId);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            entry.addThreadId(threadId);<br>            <span class="hljs-built_in">this</span>.renewExpiration();<br>        &#125;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renewExpiration</span><span class="hljs-params">()</span> &#123;<br>        RedissonLock.<span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ee</span> <span class="hljs-operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="hljs-built_in">this</span>.getEntryName());<br>        <span class="hljs-keyword">if</span> (ee != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Timeout</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.commandExecutor.getConnectionManager().newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    RedissonLock.<span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ent</span> <span class="hljs-operator">=</span> (RedissonLock.ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.<span class="hljs-built_in">this</span>.getEntryName());<br>                    <span class="hljs-keyword">if</span> (ent != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">Long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ent.getFirstThreadId();<br>                        <span class="hljs-keyword">if</span> (threadId != <span class="hljs-literal">null</span>) &#123;<br>                            RFuture&lt;Boolean&gt; future = RedissonLock.<span class="hljs-built_in">this</span>.renewExpirationAsync(threadId);<br>                            future.onComplete((res, e) -&gt; &#123;<br>                                <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                                    RedissonLock.log.error(<span class="hljs-string">&quot;Can&#x27;t update lock &quot;</span> + RedissonLock.<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; expiration&quot;</span>, e);<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    <span class="hljs-keyword">if</span> (res) &#123;<br>                                        RedissonLock.<span class="hljs-built_in">this</span>.renewExpiration();<br>                                    &#125;<br><br>                                &#125;<br>                            &#125;);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;, <span class="hljs-built_in">this</span>.internalLockLeaseTime / <span class="hljs-number">3L</span>, TimeUnit.MILLISECONDS);<br>            ee.setTimeout(task);<br>        &#125;<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure><p>拆分来看，这段连续嵌套且冗长的代码实际上做了几步</p><p>• 添加一个netty的Timeout回调任务，每（internalLockLeaseTime / 3）毫秒执行一次，执行的方法是renewExpirationAsync</p><p>• renewExpirationAsync重置了锁超时时间，又注册一个监听器，监听回调又执行了renewExpiration</p><p>renewExpirationAsync 的Lua如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> RFuture&lt;Boolean&gt; <span class="hljs-title function_">renewExpirationAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> threadId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.commandExecutor.evalWriteAsync(<span class="hljs-built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return 1; end; return 0;&quot;</span>, Collections.singletonList(<span class="hljs-built_in">this</span>.getName()), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-built_in">this</span>.internalLockLeaseTime, <span class="hljs-built_in">this</span>.getLockName(threadId)&#125;);<br>    &#125;<br><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>) then <br>  redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]); <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>end; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>Copy<br></code></pre></td></tr></table></figure><p>重新设置了超时时间。</p><p><strong>Redisson加这段逻辑的目的是什么？</strong></p><p>目的是为了某种场景下保证业务不影响，如任务执行超时但未结束，锁已经释放的问题。</p><p><strong>当一个线程持有了一把锁，由于并未设置超时时间leaseTime，Redisson默认配置了30S，开启watchDog，每10S对该锁进行一次续约，维持30S的超时时间，直到任务完成再删除锁。</strong></p><p>这就是Redisson的<strong>锁续约</strong>，也就是<strong>WatchDog</strong>实现的基本思路。</p><h3 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h3><p>通过整体的介绍，流程简单概括：</p><ol><li>A、B线程争抢一把锁，A获取到后，B阻塞</li><li>B线程阻塞时并非主动CAS，而是PubSub方式订阅该锁的广播消息</li><li>A操作完成释放了锁，B线程收到订阅消息通知</li><li>B被唤醒开始继续抢锁，拿到锁</li></ol><p>详细加锁解锁流程总结如下图：</p><p><img src="image-20221109112420546.png" alt="image-20221109112420546"></p><p><img src="D:\personalcode\hexo-blog\hexo-blog\source_posts\assets\image-20221109112420546-16679642714553.png" alt="image-20221109112420546"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redisson整体实现分布式加解锁流程的实现稍显复杂，作者Rui Gu对Netty和JUC、Redis研究深入，利用了很多高级特性和语义，值得深入学习，本次介绍也只是单机Redis下锁实现，Redisson也提供了多机情况下的联锁（<a href="https://link.juejin.cn/?target=https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8%2381-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81reentrant-lock">MultiLock</a>)和官方推荐的红锁（<a href="https://link.juejin.cn/?target=https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8%2384-%E7%BA%A2%E9%94%81redlock">RedLock</a>），下一章再详细介绍。</p><p>所以，当你真的需要分布式锁时，不妨先来Redisson里找找。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引用</title>
    <link href="/2022/10/14/%E5%BC%95%E7%94%A8/"/>
    <url>/2022/10/14/%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="强、弱引用"><a href="#强、弱引用" class="headerlink" title="强、弱引用"></a>强、弱引用</h1><p>强引用就是我们经常使用的引用，其写法如下</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br></code></pre></td></tr></table></figure><p>这句话的意思是：</p><ol><li>通过new StringBuffer创建了一个对象并在内存中开辟了一段存储空间</li><li>创建一个StringBuffer创建一个变量buffer并且指向new StringBuffer</li><li>我们可以通过buffer来使用new 的 StringBuffer</li></ol><p>这时我们称buffer是new StringBuiffer的强引用，强引用是不会被jvm回收的</p><blockquote><p>强引用是造成内存泄露的主要原因之一，为什么这么说呢？因为有强引用指向new StringBuffer所以Java认为他还在被使用，所以不会给我回收掉。经常使用idea做开发的同学可能会注意到，idea有时会给我们一个警告在变量上，说 xxx never be used,某某变量从未被使用过。这时候并不会被回收掉，但是会造成内存浪费。当引用被置空时，GC运行时才会被回收掉，因此想要被回收需要满足什么条件呢</p></blockquote><ol><li><p>没有任何引用指向它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>c=<span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure></li><li><p>GC运行时</p></li></ol><p>但是手动置空是非常繁琐且不符合常理的，对于简单的情况，这些是不需要程序员来做的，因为在Java中，对于简单对象，当调用他的方法执行完毕后，指向它的引用就会被从stack中popup,所以在下一次GC运行时就可以把它回收掉。可以使用<code>java -verbose:gc</code>来观察gc的行为。怎么知道调用他的方法执行完了嘛，有一个计数器。</p><p>但是也有特殊情况，当使用cache的时候，由于cache是程序行所需要的，那么程序只要在运行cache就不应该被GC回收掉，那么随着程序的运行这样的object会越来越多，这些Object的回收就要靠程序员自己来维护了。所以这时候引入了弱引用 <code>weak reference</code>相对于前面举例中的strong reference:</p><h2 id="weak-reference"><a href="#weak-reference" class="headerlink" title="weak reference"></a>weak reference</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(); <span class="hljs-comment">//只要c还指向car object, car object就不会被回收</span><br></code></pre></td></tr></table></figure><p>当一个对象只被weak reference指向时而没有任何Strong reference 如果GC运行，那么这个对象就会被回收掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">WeakRefernce&lt;Car&gt; weakCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;Car&gt;(car);<br></code></pre></td></tr></table></figure><p>当需要获得weak reference 引用的Object时，首先需要判断是否被回收掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">weakCar.get();<br></code></pre></td></tr></table></figure><p>如果为空说明weakCar指向的对象已经被回收掉了。</p><p>看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> weakreference; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span> price;<br><span class="hljs-keyword">private</span> String colour;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">double</span> price, String colour)</span>&#123;<br><span class="hljs-built_in">this</span>.price = price;<br><span class="hljs-built_in">this</span>.colour = colour;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> price;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span> &#123;<br><span class="hljs-built_in">this</span>.price = price;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColour</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> colour;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColour</span><span class="hljs-params">(String colour)</span> &#123;<br><span class="hljs-built_in">this</span>.colour = colour;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> colour +<span class="hljs-string">&quot;car costs $&quot;</span>+price;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> weakreference;<br><br><span class="hljs-keyword">import</span> java.lang.ref.WeakReference; <span class="hljs-comment">/** * <span class="hljs-doctag">@author</span> wison */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestWeakReference</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-number">22000</span>,<span class="hljs-string">&quot;silver&quot;</span>);<br>WeakReference&lt;Car&gt; weakCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;Car&gt;(car);<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">if</span>(weakCar.get()!=<span class="hljs-literal">null</span>)&#123;<br>i++;<br>System.out.println(<span class="hljs-string">&quot;Object is alive for &quot;</span>+i+<span class="hljs-string">&quot; loops - &quot;</span>+weakCar);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Object has been collected.&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码执行一段时间后，会输出<code>Object has been collected.</code>说明weak reference已经被回收了，值得注意的即使有car指向对象，且是强引用，weak reference指向的对象还是被回收了，这是因为进入while循环后，Java发现car再没有被使用过了，所以进行了优化（置空？）将代码修改一下;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> weakreference;<br><br><span class="hljs-keyword">import</span> java.lang.ref.WeakReference; <span class="hljs-comment">/** * <span class="hljs-doctag">@author</span> wison */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestWeakReference</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-number">22000</span>,<span class="hljs-string">&quot;silver&quot;</span>);<br>WeakReference&lt;Car&gt; weakCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;Car&gt;(car);<br><br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>System.out.println(<span class="hljs-string">&quot;here is the strong reference &#x27;car&#x27; &quot;</span>+car);<br><span class="hljs-keyword">if</span>(weakCar.get()!=<span class="hljs-literal">null</span>)&#123;<br>i++;<br>System.out.println(<span class="hljs-string">&quot;Object is alive for &quot;</span>+i+<span class="hljs-string">&quot; loops - &quot;</span>+weakCar);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Object has been collected.&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候weak reference指向的就不会被回收，因为他的一个strong reference被使用了。</p><blockquote><p>weak reference的一个特点就是它何时被回收是不确定的，因为这是由于GC的不确定性决定的。所以一般用weak reference引用的对象是有价值被cache的，而且很容易被重新构建，且很消耗内存的对象</p></blockquote><h2 id="reference-queen"><a href="#reference-queen" class="headerlink" title="reference queen"></a>reference queen</h2><p>在weak reference指向的对象被回收后，weak reference本身也没什么用了，Java提供了一个reference queen来保存那些所指向的对象已经被回收了的reference，用法是在定义WeakReference的时候将一个ReferenceQueen的对象作为参数传入构造函数</p><h2 id="softreference"><a href="#softreference" class="headerlink" title="softreference"></a>softreference</h2><p>soft reference和weak reference一样，但是在被GC回收的时候多了一个条件，当内存不足时，soft reference指向的object才会被回收，soft reference比weak reference更适合做cache object的reference，因为它尽可能的retain cached objects减少重建他们的消耗  </p><h2 id="Autowried-Map"><a href="#Autowried-Map" class="headerlink" title="Autowried Map"></a>Autowried Map</h2><p>spring boot的自动注入大家知道吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowried</span><br><span class="hljs-keyword">private</span> Map&lt;String, UserService&gt; map; <span class="hljs-comment">// UserService用@Component注解标注</span><br></code></pre></td></tr></table></figure><p>这种注入方式不知道大家有没有用过，通过这种方式会把所有实例化的UserService注入到这个Map中，然后key为这个这个Bean的id或者name。</p><p>那么问题来了，现在这些实例化的Bean被存储到了map里面，他的key是这个Bean的name,如果这个Bean被销毁了，也就是不需要了，但是这时候这个map里面仍然存着他的相关数据，这样可能就会造成内存泄漏。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>我们知道每个线程都有自己的私有变量，线程在操作的时候他不能直接操作元数据，他是拷贝一份到自己这里来，然后再来操作的。ThreadLocal就是用来存放这个线程的数据的，ThreadLocal在项目中的应用通常用来存储当前登陆者的个人信息，在数据库连接中用来存放session。</p><p>怎么存储的呢？</p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocal内部有一个静态内部类ThreadLocalMap，里面定义了Entry来保存数据，而且继承的是弱引用。在Entry的使用ThreadLocal来作为Map的key。</p><p>那么问题来了，线程是有他的生命周期的，在它用完后他被销毁了也就是没有这个线程了，那么他的id啥的都没了，ThreadLocalMap又是使用线程作为key的，那现在key都没了，我们就没办法来拿到这个map里面的value了，这也就造成了内存的泄漏。</p><p>那么ThreadLocal是怎么解决这个问题的呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ThreadLocalMap is a customized hash map suitable only for</span><br><span class="hljs-comment">     * maintaining thread local values. No operations are exported</span><br><span class="hljs-comment">     * outside of the ThreadLocal class. The class is package private to</span><br><span class="hljs-comment">     * allow declaration of fields in class Thread.  To help deal with</span><br><span class="hljs-comment">     * very large and long-lived usages, the hash table entries use</span><br><span class="hljs-comment">     * WeakReferences for keys. However, since reference queues are not</span><br><span class="hljs-comment">     * used, stale entries are guaranteed to be removed only when</span><br><span class="hljs-comment">     * the table starts running out of space.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * The entries in this hash map extend WeakReference, using</span><br><span class="hljs-comment">         * its main ref field as the key (which is always a</span><br><span class="hljs-comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="hljs-comment">         * == null) mean that the key is no longer referenced, so the</span><br><span class="hljs-comment">         * entry can be expunged from table.  Such entries are referred to</span><br><span class="hljs-comment">         * as &quot;stale entries&quot; in the code that follows.</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>            Object value;<br><br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                <span class="hljs-built_in">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这一行注释</p><blockquote><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.</p></blockquote><p>下面研究一下WeakReferences这个玩意</p><h3 id="WeakReferences"><a href="#WeakReferences" class="headerlink" title="WeakReferences"></a>WeakReferences</h3><p>WeakReferences如字面意思，弱引用。当一个对象仅仅被weak references指向时，没有任何strong references指向的时候，这是会被GC回收掉不管当前的内存空间是否足够。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReference</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reference</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeakReference</span><span class="hljs-params">(T referent)</span> &#123;<br>        <span class="hljs-built_in">super</span>(referent);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeakReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-built_in">super</span> T&gt; q)</span> &#123;<br>        <span class="hljs-built_in">super</span>(referent, q);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>WeakReference(T referent)：referent就是被弱引用的对象（注意区分弱引用对象和被弱引用的对应，弱引用对象是指WeakReference的实例或者其子类的实例），比如有一个Apple实例apple，可以如下使用，并且通过get()方法来获取apple引用。也可以再创建一个继承WeakReference的类来对Apple进行弱引用，下面就会使用这种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">WeakReference&lt;Apple&gt; appleWeakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(apple);<br><span class="hljs-type">Apple</span> <span class="hljs-variable">apple2</span> <span class="hljs-operator">=</span> appleWeakReference.get();<br></code></pre></td></tr></table></figure></li><li><p>WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)：与上面的构造方法比较，多了个ReferenceQueue，在对象被回收后，会把弱引用对象，也就是WeakReference对象或者其子类的对象，放入队列ReferenceQueue中，注意不是被弱引用的对象，被弱引用的对象已经被回收了.</p></li></ul><h3 id="ThreadLocal-和-ThreadLocalMap-是什么？"><a href="#ThreadLocal-和-ThreadLocalMap-是什么？" class="headerlink" title="ThreadLocal 和 ThreadLocalMap 是什么？"></a><strong>ThreadLocal 和 ThreadLocalMap 是什么？</strong></h3><ol><li>ThreadLocalMap是用来存储Thread的数据的</li><li>ThreadLocalMap是ThreadLocal的一个静态内部类</li><li>ThreadLocal是操作ThreadLocalMap的一个工具，通过ThreadLocal可以将一些对象保存到线程上实现同一线程不同方法之间共享</li></ol><h3 id="Thread、ThreadLocal-与-ThreadLocalMap-之间的关系"><a href="#Thread、ThreadLocal-与-ThreadLocalMap-之间的关系" class="headerlink" title="Thread、ThreadLocal 与 ThreadLocalMap 之间的关系"></a><strong>Thread、ThreadLocal 与 ThreadLocalMap 之间的关系</strong></h3><p><code>ThreadLocal可以有多个，他只是一个供我们操作ThreadLocalMap的工具，ThreadLocalMap是一个线程只有一个的</code></p><p><img src="D:\note\assets\image-20221002204130186.png" alt="image-20221002204130186"></p><h3 id="ThreadLocal导致的内存泄漏的原因是什么？"><a href="#ThreadLocal导致的内存泄漏的原因是什么？" class="headerlink" title="ThreadLocal导致的内存泄漏的原因是什么？"></a><strong>ThreadLocal导致的内存泄漏的原因是什么？</strong></h3><p><code>程序员使用完ThreadLocalMap中的数据后没有清除掉这些数据</code>,v是强引用如果不释放就会一直存在</p><p>ThreadLocalMap是维护在线程内部的，意味着如果线程不退出，那ThreadLocalMap保存的对象引用就会一直存在，由于GC是根据可达性分析的，存在强引用的对象是不会被回收的。而ThreadLocalMap中存储的都是强引用。如果垃圾一直不能被回收可能就会出现OOM问题。</p><h3 id="如何清理-ThreadLocalMap-存储的对象"><a href="#如何清理-ThreadLocalMap-存储的对象" class="headerlink" title="如何清理 ThreadLocalMap 存储的对象"></a><strong>如何清理 ThreadLocalMap 存储的对象</strong></h3><p>使用完ThreadLocalMap存储的对象后，只需要调用一下ThreadLocal的remove方法，就会将ThreadLocalMap中的K-V对的引用置空，垃圾收集器就会在合适的时机将k-v引用的对象所占的空间清空</p><h3 id="为什么ThreadLocalMap使用弱引用key"><a href="#为什么ThreadLocalMap使用弱引用key" class="headerlink" title="为什么ThreadLocalMap使用弱引用key"></a><strong>为什么ThreadLocalMap使用弱引用key</strong></h3><p>ThreadLocalMap是与线程绑定的，线程不退出，强引用的key就不会被回收，当用户不能妥善处理好K-V时就会造成内存泄漏。使用弱引用，如果除了弱引用外没有强引用或者强引用没有被使用过就会在合适的时机被GC回收掉绝大多数的key（除static和全局key外），以减少内存泄漏</p><p><code>实际上最需要回收的是value对象，弱引用key只是一种挽救措施</code></p><h3 id="ThreadLocalMap-为什么使用强引用-value，而不是弱引用"><a href="#ThreadLocalMap-为什么使用强引用-value，而不是弱引用" class="headerlink" title="ThreadLocalMap 为什么使用强引用 value，而不是弱引用"></a><strong>ThreadLocalMap 为什么使用强引用 value，而不是弱引用</strong></h3><p>与key不同的是，key是作为索引使用的，实际用户需要的内容还是value，value需要在线程内共享</p><p>当局部value对象所在的方法结束时，栈桢被清空时，局部的value对象引用会被销毁，GC会清除没有引用的对象。如果此时设置成弱引用装入map，value会在某次GC中消亡，这明显不是我们想要看到的，我们想要的是可以在线程内部共享。，只有强引用能达到这个目的。    </p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Guava Cache</title>
    <link href="/2022/10/14/Cache/"/>
    <url>/2022/10/14/Cache/</url>
    
    <content type="html"><![CDATA[<h1 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h1><h2 id="为什么需要cache"><a href="#为什么需要cache" class="headerlink" title="为什么需要cache"></a>为什么需要cache</h2><p>一般稍微并发高一点的项目都需要缓存，为什么呢？cachek基于内存，内存的速度是远高于磁盘的。比如redis中间件是基于内存的常被用于缓存中间件，</p><p>Guava是Google提供的一个并发工具包，其中的cache模块便是对缓存的一种解决方案</p><h2 id="什么是Guava-Cache"><a href="#什么是Guava-Cache" class="headerlink" title="什么是Guava Cache"></a>什么是Guava Cache</h2><p>Guava cache与ConcurrentMap很相似，但也不完全一样。最基本的ConcurrentMap会一直保存你添加的数据直到你手动将它删除调。相对的，Guava Cache为了限制内存的使用，通常会根据设定的删除策略自动回收。</p><p>内存的空间是有限的，所以不是所有的场景都要使用cache的，使用场景如下：</p><ul><li>你愿意消耗内存来提升效率</li><li>你缓存到内存的内容将会被使用一次以上</li><li>可以一定程度上容忍数据一致性问题的出现</li></ul><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>19.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="cache初始化"><a href="#cache初始化" class="headerlink" title="cache初始化"></a>cache初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Cache&lt;Integer, String&gt; cache = CacheBuilder.newBuilder()  <br>        <span class="hljs-comment">//设置cache的初始大小为10，要合理设置该值</span><br>        <span class="hljs-comment">// 数据过多也就失去了缓存的意义</span><br>        .initialCapacity(<span class="hljs-number">10</span>)  <br>        <span class="hljs-comment">//设置并发数为5，即同一时间最多只能有5个线程往cache执行写入操作  </span><br>        .concurrencyLevel(<span class="hljs-number">5</span>)  <br>        <span class="hljs-comment">//设置cache中的数据在写入之后的存活时间为10秒  </span><br>        .expireAfterWrite(<span class="hljs-number">10</span>, TimeUnit.SECONDS)  <br>        <span class="hljs-comment">//构建cache实例  </span><br>        .build();  <br></code></pre></td></tr></table></figure><h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 该接口的实现被认为是线程安全的，即可在多线程中调用 </span><br><span class="hljs-comment"> * 通过被定义单例使用 </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cache</span>&lt;K, V&gt; &#123;  <br><br>  <span class="hljs-comment">/** </span><br><span class="hljs-comment">   * 通过key获取缓存中的value，若不存在直接返回null </span><br><span class="hljs-comment">   */</span>  <br>  V <span class="hljs-title function_">getIfPresent</span><span class="hljs-params">(Object key)</span>;  <br><br>  <span class="hljs-comment">/** </span><br><span class="hljs-comment">   * 通过key获取缓存中的value，若不存在就通过valueLoader来加载该value </span><br><span class="hljs-comment">   * 整个过程为 &quot;if cached, return; otherwise create, cache and return&quot; </span><br><span class="hljs-comment">   * 注意valueLoader要么返回非null值，要么抛出异常，绝对不能返回null </span><br><span class="hljs-comment">   */</span>  <br>  V <span class="hljs-title function_">get</span><span class="hljs-params">(K key, Callable&lt;? extends V&gt; valueLoader)</span> <span class="hljs-keyword">throws</span> ExecutionException;  <br><br>  <span class="hljs-comment">/** </span><br><span class="hljs-comment">   * 添加缓存，若key存在，就覆盖旧值 </span><br><span class="hljs-comment">   */</span>  <br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span>;  <br><br>  <span class="hljs-comment">/** </span><br><span class="hljs-comment">   * 删除该key关联的缓存 </span><br><span class="hljs-comment">   */</span>  <br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">invalidate</span><span class="hljs-params">(Object key)</span>;  <br><br>  <span class="hljs-comment">/** </span><br><span class="hljs-comment">   * 删除所有缓存 </span><br><span class="hljs-comment">   */</span>  <br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">invalidateAll</span><span class="hljs-params">()</span>;  <br><br>  <span class="hljs-comment">/** </span><br><span class="hljs-comment">   * 执行一些维护操作，包括清理缓存 </span><br><span class="hljs-comment">   */</span>  <br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanUp</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="缓存回收"><a href="#缓存回收" class="headerlink" title="缓存回收"></a>缓存回收</h2><p>Guava Cache提供了三种基本的缓存回收方式：</p><ul><li>基于容量回收</li><li>定时回收</li><li>基于引用回收</li></ul><h3 id="基于容量回收（size-based-eviction）"><a href="#基于容量回收（size-based-eviction）" class="headerlink" title="基于容量回收（size-based eviction）"></a>基于容量回收（size-based eviction）</h3><p>如果要规定缓存项的数目不超过固定值，只需要使用<code>CacheBuilder.maximumSize(long)</code>缓存将尝试回收最近没有使用或总体上很少使用的缓存项。—&gt; FBI WARNING <code>在缓存项的数目达到限定值之前， 缓存就可能进行回收。通常来说，这种情况发生在缓存项的数目逼近最大缓存项数目时</code></p><h3 id="定时回收-Timed-Eviction"><a href="#定时回收-Timed-Eviction" class="headerlink" title="定时回收(Timed Eviction)"></a>定时回收(Timed Eviction)</h3><p>CacheBuilder提供两种定时回收的方法：</p><ol><li><p>expireAfterAccess(long, TimeUnit): Access这个单词的意思是访问。我们不难猜到这个方法的意思是在一定时间内没有被访问那么他就过期了。缓存项在给定时间内没有被访问（读/写）则被回收。请注意这种缓存的回收顺序和基于大小回收一样</p></li><li><p>expireAfterWrite(long, TimeUnit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候变得陈旧不可用，这种回收方式是可取的。</p><p>定时回收周期性的在写操作中执行，偶尔在读操作中执行</p></li></ol><h3 id="基于引用的回收-Reference-based-Eviction"><a href="#基于引用的回收-Reference-based-Eviction" class="headerlink" title="基于引用的回收(Reference-based Eviction)"></a>基于引用的回收(Reference-based Eviction)</h3><p>通过基于弱引用的键、或弱引用的值、或软引用的值，Guava Cache可以把缓存设置为允许垃圾回收:</p><ul><li>CacheBuilder.weakKeys(): 使用弱引用存储键，<code>当没有其他强或软引用时</code>，缓存项可以被垃圾回收。因为垃圾回收仅依赖于恒等式（==），使用弱引用键的缓存用 == 而不是equals()比较键</li><li>CacheBuilder.weakValues(): 使用弱引用存储值。<code>当值没有其他强或软引用时</code>，缓存项可以被垃圾回收。因为垃圾回收仅依赖于恒等式，使用弱引用值得缓存用==而不是equals()</li><li>CacheBuilder.softValues(): 使用软引用存储值。<code>软引用只有响应内存需要时</code>，才按照全局最近最少使用得顺序回收。考虑到使用软引用的性能影响，我们通常建议使用更有性能预测性的缓存大小限定。使用软引用的缓存同样用==而不是equals比较值。</li></ul><h3 id="显示清除"><a href="#显示清除" class="headerlink" title="显示清除"></a>显示清除</h3><p>任何时候你都可以显示的清除缓存项，而不是等待它被回收：</p><ul><li>个别清除 Cache.invalidate(key)</li><li>批量清除 Cache.invalidateAll(keys)</li><li>清除所有缓存项 Cache.invalidate()</li></ul><h3 id="移除监听器"><a href="#移除监听器" class="headerlink" title="移除监听器"></a>移除监听器</h3><p>通过CacheBuilder.removalListener(RemovalListener), 你可以生明一个监听器，以便缓存项被移除时做一些额外的操作。缓存项被移除时，RemovalListener会获取移除通知RemovalNotification，其中包含移除原因RemovalCause，键和值</p><h3 id="清理什么时候发生"><a href="#清理什么时候发生" class="headerlink" title="清理什么时候发生"></a>清理什么时候发生</h3><p>使用CacheBuilder构建的缓存不会“自动”的执行清理和回收工作，也不会在某个缓存项过期后马上清理，也没有诸如此类的清理机制。相反，他会在写操作时顺带做少量的维护工作，或者偶尔在读操作时做—如果写操作实在太少</p><p>这样做的原因在于：如果要自动的持续清理缓存，就必须有一个线程，这个线程会和用户操作竞争共享锁。此外，某些环境下线程的创建可能受限，那么CacheBuilder就不可用了。</p><p>相反，我们把选择权交给你，如果你的缓存是高吞吐的，那就无需担心缓存的维护和清理操作。如果你的缓存只是偶尔有写操作，而你又不想清理工作阻碍了读操作，那么可以创建 自己的维护线程，以固定的时间间隔调用cache.cleanUp(). ScheduledExecutorService可以帮助你很好的实现这样的定时调度。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>GuavaCache的实现代码中没有启动任何线程，Cache中的所有维护操作，包括清理移除缓存、写入缓存等，都需要外部调用来实现。这在需要低延迟服务场景中使用时需要关注，可能会在某个调用的响应时间突然变大。GuavaCache毕竟是一款面向本地缓存的，轻量级的cache，适合缓存少量数据，如果你想做缓存成千上万数据，可以为每个key设置不同的存活时间，并且高性能，那并不适合使用GuavaCache.</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot整合ES</title>
    <link href="/2022/09/30/springboot%E6%95%B4%E5%90%88ES/"/>
    <url>/2022/09/30/springboot%E6%95%B4%E5%90%88ES/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot整合ES"><a href="#springboot整合ES" class="headerlink" title="springboot整合ES"></a>springboot整合ES</h1><p>项目使用ES存储设备数据，故记录一下springboot与ES的整合，下次用的时候就不用到处找博客了，hhh</p><h2 id="spring-data-elasticsearch"><a href="#spring-data-elasticsearch" class="headerlink" title="spring data elasticsearch"></a>spring data elasticsearch</h2><p>我在项目中用的是这个东西，刚开始也不懂，后面捉摸着用感觉还挺方便的。用它的方式有两种一种是</p><p><code>Repository</code>一种是<code>ElasticsearchRestTemplate</code>。下面在详细的说，这里先提一下。</p><h3 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h3><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>网上很多导入<code>spring-boot-starter-data-elasticsearch</code>的，个人感觉不对，我们点开一看就知道spring-boot-starter-data-elasticsearch里面有spring-boot-starter和spring-data-elasticsearch的pom，然而spring-boot-starter是用来启动一个springboot服务的，然而我们肯定已经是一个spring boot服务并且也已经导入他的依赖了，所以我们是不需要的，我尝试将spring-boot-starter-data-elasticsearch删掉只留一个spring-data-elasticsearch也是可以的</p><h3 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">elasticsearch:</span><br>    <span class="hljs-attr">rest:</span><br>      <span class="hljs-attr">connection-timeout:</span> <span class="hljs-string">1s</span> <span class="hljs-comment"># 连接超时时间</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-comment"># 连接用户名</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-comment"># 连接密码</span><br>      <span class="hljs-attr">read-timeout:</span> <span class="hljs-string">30s</span> <span class="hljs-comment"># 读取超时时间</span><br>      <span class="hljs-attr">uris:</span> <span class="hljs-string">$&#123;ES_HOST:localhost&#125;:$&#123;ES_PORT:9200&#125;</span> <span class="hljs-comment"># es rest 接口地址，多个用逗号隔开</span><br></code></pre></td></tr></table></figure><p>这么配应该就可以了</p><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ruoyi.aiot.domain.message;<br><br><span class="hljs-keyword">import</span> lombok.*;<br><span class="hljs-keyword">import</span> org.springframework.data.annotation.Id;<br><span class="hljs-keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;<br><span class="hljs-keyword">import</span> org.springframework.data.elasticsearch.annotations.Field;<br><span class="hljs-keyword">import</span> org.springframework.data.elasticsearch.annotations.FieldType;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设备日志 三个分片 一个副本</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yecao</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Document(indexName = &quot;devicelog&quot;, shards = 3, replicas = 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeviceLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> String id;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * deviceId存为keyword防止分词</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Field(type = FieldType.Keyword)</span><br>    <span class="hljs-keyword">private</span> String deviceId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Field(type = FieldType.Text)</span><br>    <span class="hljs-keyword">private</span> String messageContent;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志类型 propertyReport eventLog functionInvoke onlineLog offlineLog</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Field(type = FieldType.Keyword)</span><br>    <span class="hljs-keyword">private</span> String logType;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Field(name = &quot;timestamp&quot;, type = FieldType.Text, fielddata = true)</span><br>    <span class="hljs-keyword">private</span> String timestamp;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过注解来设置ES文档的mapping结构，一些我们不希望被分词的可以设置为keyword，fieldata默认为false，这时候不能用这个字段排序的，设置为true才行</p><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DeviceLogRepo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ElasticsearchRepository</span>&lt;DeviceLog, String&gt; &#123;<br><br>    <span class="hljs-keyword">public</span> Page&lt;DeviceLog&gt; <span class="hljs-title function_">findAllByDeviceIdAndTimestampIsBetween</span><span class="hljs-params">(String deviceId, String startTime, String endTime, Pageable pageable)</span>;<br><br>    <span class="hljs-keyword">public</span> Page&lt;DeviceLog&gt; <span class="hljs-title function_">searchAllByDeviceId</span><span class="hljs-params">(NativeSearchQuery nativeSearchQuery, Pageable pageable)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们自定义一个接口继承自ElasticsearchRepository，即可使用给我们提供的一些默认的方法，我们也可以自定义一些接口，接口名称和参数的定义是要符合语义的，这样spring data es会自动给我们去实现这个接口。刚开始我以为这会很方便，实际操作起来认为，这只适合最做一些简单的crud稍微复杂的不太行，比如save find这些的用起来还是很爽的。我们save后es就会出现跟我们尸体了对应的文档结构了。</p><h3 id="ElasticsearchRestTemplate"><a href="#ElasticsearchRestTemplate" class="headerlink" title="ElasticsearchRestTemplate"></a>ElasticsearchRestTemplate</h3><p>这个我们写一些复杂的查询可以用这个，不过使用这个就稍微有一点门槛了，要求我们知道构建es查询的json的一个结构，如果不是很熟的话，我们可以先借助kibana的devtools来写，写完以后再通过代码把请求体构建出来就行了。</p><p>看一下下面的两个例子吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Sort.<span class="hljs-type">Order</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sort</span>.Order(Sort.Direction.DESC, <span class="hljs-string">&quot;timestamp&quot;</span>);<br>        <span class="hljs-type">PageRequest</span> <span class="hljs-variable">of</span> <span class="hljs-operator">=</span> PageRequest.of(deviceDataDto.getPageNum(), deviceDataDto.getPageSize(), Sort.by(timestamp));<br><br>        <span class="hljs-type">BoolQueryBuilder</span> <span class="hljs-variable">boolQueryBuilder</span> <span class="hljs-operator">=</span> QueryBuilders.boolQuery();<br>        boolQueryBuilder.must(QueryBuilders.termQuery(<span class="hljs-string">&quot;deviceId&quot;</span>, deviceDataDto.getDeviceId()));<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">logType</span> <span class="hljs-operator">=</span> deviceDataDto.getLogType();<br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(logType))&#123;<br>            boolQueryBuilder.must(QueryBuilders.termQuery(<span class="hljs-string">&quot;logType&quot;</span>, logType));<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> deviceDataDto.getStartTime();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> deviceDataDto.getEndTime();<br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(startTime) &amp;&amp; StringUtils.isNotEmpty(endTime))&#123;<br>            boolQueryBuilder.filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;timestamp&quot;</span>).gte(startTime).lte(endTime));<br>        &#125;<br>        <span class="hljs-type">NativeSearchQueryBuilder</span> <span class="hljs-variable">nativeSearchQueryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeSearchQueryBuilder</span>();<br>        <span class="hljs-type">NativeSearchQuery</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> nativeSearchQueryBuilder.withQuery(boolQueryBuilder).withPageable(of).build();<br>SearchHits&lt;DeviceLog&gt; search = elasticsearchRestTemplate.search(build, DeviceLog.class);<br></code></pre></td></tr></table></figure><p>上面构建了一个根据deviceID和时间范围的一个倒叙查找，大概分为三个步骤</p><ol><li>通过QueryBuilders创建请求的体，也就是那个大json</li><li>NativeSearchQueryBuilder将构建出来的json构建成一个可以执行的语句，相当于在QueryBuilders外面包了一层</li><li>通过ElasticsearchRestTemplate执行构建的语句，它相当于就是一个客户端，它负责将我们的请求发出去</li></ol><p>比较适合做一些复杂的查询比较灵活，我们可以看到它具体的实现，也方便我们调试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NativeSearchQueryBuilder</span> <span class="hljs-variable">nativeSearchQueryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeSearchQueryBuilder</span>();<br>        <span class="hljs-type">BoolQueryBuilder</span> <span class="hljs-variable">boolQueryBuilder</span> <span class="hljs-operator">=</span> QueryBuilders.boolQuery();<br>        boolQueryBuilder.must(QueryBuilders.termsQuery(<span class="hljs-string">&quot;deviceId&quot;</span>, list));<br>        boolQueryBuilder.filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;timestamp&quot;</span>).gte(from).lte(to));<br>        <span class="hljs-type">NativeSearchQuery</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> nativeSearchQueryBuilder.withQuery(boolQueryBuilder).build();<br>        <span class="hljs-keyword">return</span> elasticsearchRestTemplate.count(build, ReportPropertyMessage.class);<br></code></pre></td></tr></table></figure><p>这个例子是用来查询一组设备在某个时间段的消息数量。</p><p>优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先查询</span><br><span class="hljs-type">BoolQueryBuilder</span> <span class="hljs-variable">boolQueryBuilder</span> <span class="hljs-operator">=</span> QueryBuilders.boolQuery();<br>boolQueryBuilder.must(QueryBuilders.termsQuery(<span class="hljs-string">&quot;deviceId&quot;</span>, deviceIds));<br><br><span class="hljs-comment">// 后聚合</span><br><span class="hljs-type">RangeAggregationBuilder</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> AggregationBuilders.range(<span class="hljs-string">&quot;time_range&quot;</span>)<br>        .field(<span class="hljs-string">&quot;timestamp&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; limit; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;<br>        field.addRange(fromTemp , toTemp);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        fromTemp = fromTemp + step;<br>        toTemp = toTemp + step;<br>        field.addRange(fromTemp , toTemp);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">NativeSearchQuery</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeSearchQueryBuilder</span>()<br>        <span class="hljs-comment">// 不查询任何返回结果，这一点很重要，</span><br>        <span class="hljs-comment">// 我们要的是聚合结果，不需要他的返回结果，这里直接影响查询速度</span><br>        .withSourceFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FetchSourceFilter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;&quot;</span>&#125;, <span class="hljs-literal">null</span>))<br>        .withQuery(boolQueryBuilder)<br>        .addAggregation(field)<br>        .build();<br><br>SearchHits&lt;TestPojo&gt; search = elasticsearchRestTemplate.search(build, TestPojo.class);<br></code></pre></td></tr></table></figure><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>一段时间不操作过后再次试用报错：connection rest by peer其实就是tcp被断开了然后你又使用了这个tcp。需要通过@Bean手动将我们配置的Bean注入进去。手动设置keepAlive并开启，keepAlive的时间应该小于服务器的keepAlive时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ElasticserachRestClientConfig</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.elasticsearch.rest.uris&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String uris;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.elasticsearch.rest.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.elasticsearch.rest.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestHighLevelClient <span class="hljs-title function_">restHighLevelClient</span><span class="hljs-params">()</span> &#123;<br>        String[] split = uris.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        <span class="hljs-type">RestHighLevelClient</span> <span class="hljs-variable">restHighLevelClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(<br>                RestClient.builder(<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHost</span>(split[<span class="hljs-number">1</span>].replace(<span class="hljs-string">&quot;//&quot;</span>, <span class="hljs-string">&quot;&quot;</span>), Integer.parseInt(split[<span class="hljs-number">2</span>]))<br>                ).setRequestConfigCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RestClientBuilder</span>.RequestConfigCallback() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> RequestConfig.Builder <span class="hljs-title function_">customizeRequestConfig</span><span class="hljs-params">(RequestConfig.Builder requestConfigBuilder)</span> &#123;<br>                        <span class="hljs-keyword">return</span> requestConfigBuilder.setConnectTimeout(<span class="hljs-number">5000</span>)<span class="hljs-comment">//25hours</span><br>                                .setSocketTimeout(<span class="hljs-number">60000</span>);<br>                    &#125;<br>                &#125;).setHttpClientConfigCallback(httpClientBuilder -&gt; &#123;<br>                            <span class="hljs-type">CredentialsProvider</span> <span class="hljs-variable">credentialsProvider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicCredentialsProvider</span>();<br>                            credentialsProvider.setCredentials(AuthScope.ANY, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordCredentials</span>(userName, password));<br>                            httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider)<br>                                    .setKeepAliveStrategy((httpResponse, httpContext) -&gt; TimeUnit.SECONDS.toMillis(<span class="hljs-number">3</span>))<br>                                    .setDefaultIOReactorConfig(IOReactorConfig.custom().setSoKeepAlive(<span class="hljs-literal">true</span>).build());<br>                            <span class="hljs-keyword">return</span> httpClientBuilder;<br>                        &#125;<br>                )<br><br>        );<br>        <span class="hljs-keyword">return</span> restHighLevelClient;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口失败重试</title>
    <link href="/2022/09/04/%E6%8E%A5%E5%8F%A3%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/"/>
    <url>/2022/09/04/%E6%8E%A5%E5%8F%A3%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="接口失败重试机制"><a href="#接口失败重试机制" class="headerlink" title="接口失败重试机制"></a>接口失败重试机制</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近这个项目用到了ES，因为物联网设备数据量很多嘛，如果使用关系型数据库的话查询瓶颈很快就会显现出来，众所周知ES是一个分布式查询引擎，查询效率刚刚的</p><p>问题来了，前一天晚上测试好了ES的查询接口，就是一个很简单的分页倒叙查询，结果第二天测试的时候出问题了，</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs java">Caused by: java.io.IOException: Connection reset by peer<br>at org.elasticsearch.client.RestClient.extractAndWrapCause(RestClient.java:<span class="hljs-number">793</span>)<br>at org.elasticsearch.client.RestClient.performRequest(RestClient.java:<span class="hljs-number">218</span>)<br>at org.elasticsearch.client.RestClient.performRequest(RestClient.java:<span class="hljs-number">205</span>)<br>at org.elasticsearch.client.RestHighLevelClient.internalPerformRequest(RestHighLevelClient.java:<span class="hljs-number">1454</span>)<br>at org.elasticsearch.client.RestHighLevelClient.performRequest(RestHighLevelClient.java:<span class="hljs-number">1424</span>)<br></code></pre></td></tr></table></figure><p>一顿查询过后说是服务器关闭了ES的TCP连接导致的，这里就要说到TCP的保活机制了</p><h2 id="TCP保活机制"><a href="#TCP保活机制" class="headerlink" title="TCP保活机制"></a>TCP保活机制</h2><p>保活机制是由一个保活计时器实现的，当计数器被激发，连接一段将发送一个保活探测报文，另一端接收报文的同时会发送一个ack作为响应。如果客户端无响应服务器将中断连接，否则会重置保活探测计时器。服务器端Linux有三个参数可以控制保活时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcp_keepalive_time (开启keepalive的闲置时长)<br>tcp_keepalive_intvlk (keepalive 侦测包的发送时间间隔)<br>tcp_keepalive_probes (如果对方不与应答，侦测包的发送次数)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask实例化</title>
    <link href="/2022/07/15/Flask%E5%AE%9E%E4%BE%8B%E5%8C%96/"/>
    <url>/2022/07/15/Flask%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h1><h2 id="Flask实例化配置"><a href="#Flask实例化配置" class="headerlink" title="Flask实例化配置"></a>Flask实例化配置</h2><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可对实例、配置模板文件路径、静态文路径进行配置</span><br>Flask(__name__, static_folder=<span class="hljs-string">&#x27;mystatic&#x27;</span>, static_url_path=<span class="hljs-string">&#x27;/myurl&#x27;</span>,template_folder=<span class="hljs-string">&#x27;mytemplate&#x27;</span>)<br> <br><span class="hljs-comment"># 静态文件目录的路径 默认当前项目中的static目录</span><br>static_folder = <span class="hljs-string">&#x27;static&#x27;</span><br> <br><span class="hljs-comment"># 静态文件目录的url路径 默认不写是与static_folder同名,远程静态文件时复用</span><br>static_url_path = <span class="hljs-literal">None</span>, <br> <br><span class="hljs-comment"># template模板目录, 默认当前项目中的 templates 目录，一般用来存放一些前端界面之类得</span><br>template_folder = <span class="hljs-string">&#x27;templates&#x27;</span>  <br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#构建绝对路径</span><br>path = <span class="hljs-built_in">str</span>((Path(__file__).parent).absolute())+<span class="hljs-string">&quot;/test1/static&quot;</span><br> <br>设置template和static路径<br> <br>app = Flask(__name__,template_folder=<span class="hljs-string">&#x27;../test1/templates&#x27;</span>,static_folder=path)<br> <br>此时实例化后参数为<br> <br>static_folder  /..../test1/static<br>static_url_path   /static<br>template_folder  ../test1/templates <br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js获取对象属性方式</title>
    <link href="/2022/07/15/js%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/07/15/js%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue取参数"><a href="#Vue取参数" class="headerlink" title="Vue取参数"></a>Vue取参数</h2><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>) <span class="hljs-comment">//引入path文件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">dir</span>) &#123;<br>  <span class="hljs-comment">// console.log(&#x27;引入vue.config.js&#x27;)</span><br>  <span class="hljs-keyword">return</span> path.<span class="hljs-title function_">join</span>(__dirname, dir) <span class="hljs-comment">//path.join(__dirname)设置绝对路径</span><br>&#125;<br> <br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">productionSourceMap</span>:<span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">assetsDir</span>: <span class="hljs-string">&#x27;static&#x27;</span>,<br>  <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;./&#x27;</span>,<br>  <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vue.config.js.chainWebpack&#x27;</span>)<br>    config.<span class="hljs-property">resolve</span>.<span class="hljs-property">alias</span><br>      .<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src&#x27;</span>))<br>      .<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;components&#x27;</span>, <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/components&#x27;</span>))<br>      .<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/views&#x27;</span>))<br>      .<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;assets&#x27;</span>, <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/assets&#x27;</span>))<br>      .<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;network&#x27;</span>, <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/network&#x27;</span>))<br>      .<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;utils&#x27;</span>, <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/utils&#x27;</span>))<br>    <span class="hljs-comment">//set第一个参数：设置的别名，第二个参数：设置的路径</span><br>  &#125;,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-comment">// target: &quot;http://47.106.188.9:8081&quot;,</span><br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://127.0.0.1:8081&quot;</span>,<br>        <span class="hljs-comment">// target: &#x27;http://192.168.1.171:8081&#x27;,</span><br>        <span class="hljs-comment">// target: &#x27;http://192.168.1.16:8081&#x27;,</span><br>        <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<br>          <span class="hljs-comment">// &#x27;^/api&#x27;: &#x27;/api&#x27;,</span><br>          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>      &#125;,<br>      <span class="hljs-comment">// 仿写，当遇到 api_wx路由将url替换为新的地址</span><br>      <span class="hljs-string">&#x27;/api_wx&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://127.0.0.1:8081&quot;</span>,<br>        <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<br>          <span class="hljs-string">&#x27;^/api_wx&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入配置文件</span><br><span class="hljs-keyword">import</span> dev <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../../vue.config.js&quot;</span><br><br><span class="hljs-title function_">exportDevicesTable</span>(<span class="hljs-params"></span>)&#123; <br>        <span class="hljs-title function_">exportDevices</span>(&#123;<span class="hljs-attr">ids</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">multipleSelection</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = dev.<span class="hljs-property">devServer</span>.<span class="hljs-property">proxy</span>[<span class="hljs-string">&#x27;/api&#x27;</span>].<span class="hljs-property">target</span> + res;<br>      &#125;) <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="js中对象获取属性的两种表示方法"><a href="#js中对象获取属性的两种表示方法" class="headerlink" title="js中对象获取属性的两种表示方法"></a>js中对象获取属性的两种表示方法</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用 ."></a>使用 .</h4><p>点 一般操作静态对象来存取属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">let</span> obj = &#123;<br>     <span class="hljs-attr">a</span>:<span class="hljs-string">&quot;m1&quot;</span>,<br>     <span class="hljs-attr">b</span>:<span class="hljs-string">&quot;m2&quot;</span><br>   &#125;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a---&quot;</span>,obj.<span class="hljs-property">a</span>)<span class="hljs-comment">//m1</span><br> &#125;<br></code></pre></td></tr></table></figure><p>我们平常开发中会多使用第一种方式，系统会把调用的obj.a自动隐式转换为： obj[‘a’]来执行，所以第二种会第一种快捷。</p><h4 id="使用-又称数组表示法"><a href="#使用-又称数组表示法" class="headerlink" title="使用 [ ] (又称数组表示法)"></a>使用 [ ] (又称数组表示法)</h4><p>中括号一般操作动态对象来存取属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-string">&quot;m1&quot;</span>,<br>    <span class="hljs-attr">b</span>:<span class="hljs-string">&quot;m2&quot;</span><br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;b---&quot;</span>,obj[<span class="hljs-string">&#x27;b&#x27;</span>])<span class="hljs-comment">//m2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>共同点：以上两种都可以实现属性的存取。<br>区别：<br>第一种obj.a 点后面是对象中的属性名，必须是一个指控的属性名。第二种 obj[‘a’] []里面必须是字符型。</p><p>使用场景：<br>当动态为某个对象添加属性时用第二种合适。动态操作对象时。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">let</span> obj1 = &#123;<br>     <span class="hljs-attr">haha1</span>:&#123;<span class="hljs-attr">a1</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b1</span>:<span class="hljs-number">1</span>&#125;,<br>     <span class="hljs-attr">haha2</span>:&#123;<span class="hljs-attr">a2</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">b2</span>:<span class="hljs-number">2</span>&#125;,<br>     <span class="hljs-attr">haha3</span>:&#123;<span class="hljs-attr">a3</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">b3</span>:<span class="hljs-number">3</span>&#125;,<br>     <span class="hljs-attr">btn</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)&#123;<br>       <span class="hljs-keyword">return</span> obj1[<span class="hljs-string">&#x27;haha&#x27;</span>+num]<br>     &#125;<br>   &#125;<br>   <span class="hljs-keyword">let</span> result = obj1.<span class="hljs-title function_">btn</span>(<span class="hljs-number">3</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;result---&quot;</span>,result) <span class="hljs-comment">// &#123;a3: 3, b3: 3&#125;</span><br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql</title>
    <link href="/2022/06/03/Mysql/"/>
    <url>/2022/06/03/Mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h2><p>索引是帮助MySQL高效获取数据的排好序的<code>数据结构</code></p><ul><li><p>索引数据结构</p><ul><li>二叉树</li><li>红黑树</li><li>Hash表</li><li>B-Tree</li></ul><p><img src="01.png" alt="01"></p></li></ul><p><img src="Mysql.assets/image-20220603151116543.png" alt="image-20220603151116543"></p><p>如果没有索引我们查一条数据比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> col2<span class="hljs-operator">=</span><span class="hljs-number">89</span>;<br></code></pre></td></tr></table></figure><p>因为没有索引所以他要做一个全表扫面，一行一行的找，MySQL的数据是存在磁盘里的，这时候就会有大量的磁盘IO。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>MySQL早期索引的数据结构是一个二叉树。以K-V键值对的形式进行存储。k是我们的索引字段，v是k所在的磁盘地址。</p><p><img src="02.png" alt="02"></p><img src="Mysql.assets/image-20220603154637725.png" alt="image-20220603154637725" style="zoom:50%;" /><p><strong>缺点：</strong> 比如col1,这一列是递增上去的，我们给他建立索引的话是单边递增的，如果我们要查col1==6的，仍然要去查找六次，也相当于是做了一个全表扫描。</p><h3 id="RED-BLACK-TREE"><a href="#RED-BLACK-TREE" class="headerlink" title="RED/BLACK TREE"></a>RED/BLACK TREE</h3><p>红黑树又称二叉平衡树，当树的一边比另一边高的很多的时候，它可以自动平衡从而避免像二叉树这种情况。</p><p><img src="03.png" alt="03"></p><p><img src="Mysql.assets/image-20220603160845638.png" alt="image-20220603160845638"></p><p>比如这种情况，一遍比另外一边高出很多这时候红黑二叉树会自动做一个转换。转换成下面这个样子。</p><p><img src="04.png" alt="04"></p><p><img src="Mysql.assets/image-20220603161035925.png" alt="image-20220603161035925"></p><p>当使用红黑二叉树来查找col1=6的时候只需要查找三次。</p><p><img src="05.png" alt="05"></p><img src="../../../../../A/image-20220603161332243.png" alt="image-20220603161332243" style="zoom:80%;" /><p>这相对于二叉树就减少了三次的查询。</p><p>这样看着比二叉树好了蛮多，但是最终MySQL还是没有采用这种数据结构，因为随着数据量的不断增加，红黑二叉树的高度也会不断增加，我们查的数据可能有一部分是在叶子节点上，这样我们就要从根节点遍历到叶子节点，这样他的磁盘IO次数也会增加，导致效率较低。</p><p>如果想让高度可控，只有在横向进行扩展</p><h3 id="B-TREE"><a href="#B-TREE" class="headerlink" title="B-TREE"></a>B-TREE</h3><ul><li>叶节点具有相同的深度，叶节点的指针为空</li><li>所有索引元素 不重复</li><li>节点中的数据索引从左到右递增排列</li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树<img src="Mysql.assets/image-20220603172619010.png" alt="image-20220603172619010"></h3><p><img src="08.png" alt="08"></p><p> B+TREE非叶子节点不会存储数据，存的是下指向下一个 节点的指针，也可以说是下一个节点的磁盘地址，在叶子节点才会存储数据在磁盘中的地址。比如我们查找一个数据18，18在15<del>56之间，那么就会找到A，A中存储了下面一个节点的磁盘地址，然后在下面的这个节点中继续查找，18在15</del>20之间，然后根据d存储的下一节点的磁盘地址知道叶子节点，在叶子节点里面找到了18，然后18这个节点存储的是这个18所在的磁盘地址，这时候就可根据这个地址在磁盘中定位到数据了。</p><p>我么可以看到B+TREE的一个节点可以有多个索引，通过横向扩展的方式降低了这棵树的高度，就是因为他的一个节点可以有多个索引，这也有了 <strong>最左匹配原则</strong>，因为我们构建树的时候只能根据一个节点来构建，但是一个节点有多个索引，所以统一规定使用最左边的索引来构建这个树。</p><h3 id="hash结构"><a href="#hash结构" class="headerlink" title="hash结构"></a>hash结构</h3><ul><li>对索引的key进行一次hash运算就可以定位出数据存储的位置</li><li>很多时候hash索引要比B+树索引更高效</li><li>仅能满足 “=”  “in”,不支持范围查询 因为经过hash运算后之前的范围不一定等于之后的范围，你如之前的范围是[10,25],经过hash运算后就不一定是这个范围了。B+TREE叶子节点相当于是一个循环列表，叶子节点之间通过指针互联，而且索引字段还是排好序的，所以可以支持范围查找</li><li>hash冲突问题</li></ul><p><img src="12.png" alt="12"></p><p><img src="Mysql.assets/image-20220605144324433.png" alt="image-20220605144324433"></p><h2 id="MyISM存储引擎索引实现"><a href="#MyISM存储引擎索引实现" class="headerlink" title="MyISM存储引擎索引实现"></a>MyISM存储引擎索引实现</h2><img src="Mysql.assets/image-20220603195202610.png" alt="image-20220603195202610" style="zoom:67%;" /><p><img src="09.png" alt="09"></p><p>索引文件和数据文件是非聚集的。</p><p><strong>存储引擎是应用在表上面的</strong>，<strong>也就是说他是表级别的</strong>。</p><p>myism存储引擎存储时有两种文件：frm、myd</p><ul><li>frm: 存储表结构</li><li>myd: 存储表数据</li></ul><h2 id="Innodb存储引擎索引实现"><a href="#Innodb存储引擎索引实现" class="headerlink" title="Innodb存储引擎索引实现"></a>Innodb存储引擎索引实现</h2><p>聚集索引</p><ul><li>表数据文件本身就是按照B+TREE组织的一个索引结构文件</li><li>聚集索引叶子节点包含了完整的数据记录</li><li>为什么建议InnoDB表必须建主键，并且推荐使用整形的自增组件</li><li>为什么非主键索引结构叶子节点存储的是主键值（一致性和节省存储空间）</li></ul><p><img src="10.png" alt="10"></p><img src="Mysql.assets/image-20220603213632984.png" alt="image-20220603213632984" style="zoom:67%;" /><p><strong>叶子节点放的是索引所在行的其他列数据</strong>。叶子节点有去哪表的所有索引，对应的就是全表的所有数据。</p><p><strong>普通索引</strong></p><p><img src="11.png" alt="11"></p><p><img src="Mysql.assets/image-20220603214639609.png" alt="image-20220603214639609"></p><p>叶子节点存储的不是索引所在行的其他列，而是主键索引。根据主键在去主键索引里查找数据。（因为主键索引存储的是主键所在行的其他列的值）</p><h2 id="聚集索引和非聚集索引的区别"><a href="#聚集索引和非聚集索引的区别" class="headerlink" title="聚集索引和非聚集索引的区别"></a>聚集索引和非聚集索引的区别</h2><p>像myism存储引擎他的索引跟数据是分开存储的这种叫做非聚集索引，innodb的主键索引这种是索引跟数据存储在一起叫做聚集索引。</p><h2 id="为什么建议InnoDB建立主键索引"><a href="#为什么建议InnoDB建立主键索引" class="headerlink" title="为什么建议InnoDB建立主键索引"></a>为什么建议InnoDB建立主键索引</h2><p>首先呢，InnoDB这张表本身就是按照B+TREE这种结构来存储的，如果用的是主键索引通过主键索引到叶子节点找到的就是这条记录完整的记录了，如果没用主键索引，还要根据根据索引找到的叶子节点存储的还是主键索引，还要再找一次。</p><p>InnoDB存储数据时是按照B+TREE来存储的，所以他要有一个节点来构建这个属性结构。如果我们又没建立，那么MySQL会自动给我们维护一个隐藏列，而且会保证这个隐藏列的唯一性。然后根据这个隐藏的唯一列帮我们组织这个树。</p><h3 id="为什么建议使用整形自增的做主键呢"><a href="#为什么建议使用整形自增的做主键呢" class="headerlink" title="为什么建议使用整形自增的做主键呢"></a>为什么建议使用整形自增的做主键呢</h3><p>在寻找叶子节点的过程中需要进行不断的比较，那么是整形比较的快呢，还是uuid这种比较的快呢，显然是整形这种啦。</p><p>为什么建议自增呢？我们说过索引的本质是为了帮助MySQL高效获取数据的排好序的数据结构，使用自增可以提高排序效率。<strong>很少会造成节点的分裂，节点的分裂是比较耗费性能的</strong>  提高全表扫描能力，顺序访问。</p><h2 id="索引的本质-1"><a href="#索引的本质-1" class="headerlink" title="索引的本质"></a>索引的本质</h2><p>索引是帮助MySQL高效获取数据的 <code>排好序的数据结构</code> </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/26/flask/"/>
    <url>/2022/05/26/flask/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python之flask</title>
    <link href="/2022/05/26/python%E4%B9%8Bflask/"/>
    <url>/2022/05/26/python%E4%B9%8Bflask/</url>
    
    <content type="html"><![CDATA[<h1 id="python之flask"><a href="#python之flask" class="headerlink" title="python之flask"></a>python之flask</h1><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h3><p>安装virtualenv的一个好处呢就是环境隔离，类似于docker的集装箱概念吧，因为python会有很多扩展组件，组件的版本有很复杂，所以一套互相隔离的环境就相当重要了</p><h3 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h3><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">pip install virtualenv<br></code></pre></td></tr></table></figure><p>查看是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip list<br></code></pre></td></tr></table></figure><p>创建虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">virtualenv envname   # 创建一个名字为envname的虚拟环境<br></code></pre></td></tr></table></figure><p>指定用哪个python版本创建环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">virtualenv -p c:\Python27\Python.exe envname  # 如果安装了多个python版本，如py2和py3，需要指定使用哪个创建虚拟环境<br></code></pre></td></tr></table></figure><p>启动虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入虚拟环境文件</span><br>cd envname<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入相关的启动文件夹</span><br>cd Scripts<br><br>activate  # 启动虚拟环境<br>deactivate # 退出虚拟环境<br></code></pre></td></tr></table></figure><p>到此一个虚拟空间就完成了，现在就可以使用这个虚拟环境了。</p><h2 id="使用Pycharm和virtualenv创建一个flask项目"><a href="#使用Pycharm和virtualenv创建一个flask项目" class="headerlink" title="使用Pycharm和virtualenv创建一个flask项目"></a>使用Pycharm和virtualenv创建一个flask项目</h2><p>首先随便建一个文件夹用来存放我们的代码</p><p><img src="01.png" alt="01"></p><p>新建项目</p><p><img src="02.png" alt="02"></p><p>选择我们的项目地址，以及新建的virtualenv空间和virtualenv指定的python解析器，点击create创建完成。</p><h2 id="hello-word"><a href="#hello-word" class="headerlink" title="hello word"></a>hello word</h2><p><img src="03.png" alt="03"></p><p>一个hello word就好了</p><h2 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip freeze requirements.txt<br></code></pre></td></tr></table></figure><p>使用该指令将我们项目所需要的依赖输出到requirements文件中，下次部署环境时直接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install requirements.txt<br></code></pre></td></tr></table></figure><p><img src="04.png" alt="04"></p><p>可以看到这个requirements.txt包含了我们虚拟空间的依赖以及版本号，并没有其他空间的依赖项。</p><h2 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入flask扩展</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><span class="hljs-comment"># 创建flask应用实例，需要传入__name__,作用是为了确定资源所在的路径</span><br>app = Flask(__name__)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():  <span class="hljs-comment"># put application&#x27;s code here</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World!&#x27;</span><br><br><span class="hljs-comment"># 定义路由和视图函数 flask中定义路由通过装饰器来实现的</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/he&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi!&quot;</span><br><br><span class="hljs-comment"># 启动程序 执行了app.run就会把我们的flask程序运行在一个建议的服务器上（Flask提供的，用于猜测的）</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><h2 id="Flask运行过程"><a href="#Flask运行过程" class="headerlink" title="Flask运行过程"></a>Flask运行过程</h2><ol><li>当客户端想要获取资源时，一般会通过浏览器发送一个请求</li><li>此时，通过app.run启动的web服务器会把客户端的所有请求都交给Flask程序实例</li><li>程序使用Werkzeug来做路由分发（URL请求和视图函数之间的对应关系）</li><li>根据URL请求，找到具体的视图函数并进行调用<ul><li>在Flask程序中，路由的实现一般是通过程序实例的装饰器实现</li></ul></li><li>Flask调用视图函数后，可以返回两种内容：<ul><li>字符串内容：将视图函数的返回值作为相应的内容，返回给客户端。</li><li>HTML模板内容：获取到数据后，把数据传入HTML模板文件中，模板引擎负责渲染HTTP响应数据，然后返回响应数据给客户端。</li></ul></li></ol><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p>有时我们需要将同一URL映射到同一个视图函数处理，比如：使用同一个视图函数来显示不同用户的订单信息。</p><p>路由传递的参数默认当作str处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用同一个视图函数，来显示不同的视图信息</span><br><span class="hljs-comment"># &lt; &gt;定义路由参数</span><br><span class="hljs-comment"># 这里指定参数为int类型，其他类型的传过来会404，有点类似于Java调用方法要参数类型一直</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/order/&lt;int:orderId&gt;&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getOrderId</span>(<span class="hljs-params">orderId</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(orderId))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;orderId %s&#x27;</span> % orderId<br></code></pre></td></tr></table></figure><p>这里指定int，会调用系统的路由转换器进行转换和匹配，如果类型没有转换成功就无法匹配该路由</p><h2 id="结构化管理"><a href="#结构化管理" class="headerlink" title="结构化管理"></a>结构化管理</h2><p><img src="05.png" alt="05"></p><p>这一点很好理解，这是一种思想，分类管理。而不是要把所有的东西都放在一个地方。比如我们写api,新建一个api的包，v1代表版本，然后下面才是我们具体的api文件。</p><p>这里的路由不能使用@app.route</p><p><img src="06.png" alt="06"></p><p>蓝图需要向app注册,关于app对象的配置统一写在app.py里面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">createApp</span>():<br>    app = Flask(__name__)<br>    app.config.from_object(<span class="hljs-string">&#x27;app.config.setting&#x27;</span>)<br>    app.config.from_object(<span class="hljs-string">&#x27;app.config.secure&#x27;</span>)<br>    <span class="hljs-comment"># 调用注册方法实现注册</span><br>    registerBlueprints(app)<br>    <span class="hljs-keyword">return</span> app<br><br><br><span class="hljs-comment"># 定义一个注册的方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">registerBlueprints</span>(<span class="hljs-params">app</span>):<br>    <span class="hljs-keyword">from</span> api.v1.book <span class="hljs-keyword">import</span> book<br>    <span class="hljs-keyword">from</span> api.v1.user <span class="hljs-keyword">import</span> user<br>    app.register_blueprint(user)<br>    app.register_blueprint(book)<br></code></pre></td></tr></table></figure><h2 id="实现一个自己的蓝图"><a href="#实现一个自己的蓝图" class="headerlink" title="实现一个自己的蓝图"></a>实现一个自己的蓝图</h2><p>蓝图包括哪些功能呢？</p><ol><li>路由</li><li>路由和视图函数的绑定</li></ol><p>他是怎么实现的呢，看源代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">route</span>(<span class="hljs-params">self, roule, **option</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">f</span>):<br>        <span class="hljs-comment"># f是当前视图函数，将当前视图函数加入到option中</span><br>        endpoint = option.pop(<span class="hljs-string">&quot;endpoint&quot;</span>, f.__name__)<br>        <span class="hljs-comment"># 再给看图添加url规则</span><br>        self.add_url_rule(rule, edpoint, f, **option)<br>        <span class="hljs-keyword">return</span> f<br>    <span class="hljs-keyword">return</span> decorator<br></code></pre></td></tr></table></figure><p>我们自己模仿实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">route</span>(<span class="hljs-params">self, rule, **options</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">f</span>):<br>        <span class="hljs-comment"># 我们拿不到蓝图,先保存等可以拿到的时候再来处理</span><br>        self.mount.append((f, rule, options))<br>        <span class="hljs-keyword">return</span> f<br><br>    <span class="hljs-keyword">return</span> decorator<br></code></pre></td></tr></table></figure><p>register</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">self, bp, url_prefix=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">for</span> f, rule, options <span class="hljs-keyword">in</span> self.mount:<br>        <span class="hljs-comment"># 如果有以endpoint为key的value则取value，否则取视图的名字</span><br>        endpoint = options.pop(<span class="hljs-string">&quot;endpoint&quot;</span>, f.__name__)<br>        bp.add_url_rule(url_prefix + rule, endpoint, f, **options)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bootstrap application</title>
    <link href="/2022/05/22/application/"/>
    <url>/2022/05/22/application/</url>
    
    <content type="html"><![CDATA[<h1 id="bootstrap-application"><a href="#bootstrap-application" class="headerlink" title="bootstrap application"></a>bootstrap application</h1><p>用过 Spring Boot 的都知道在 Spring Boot 中有以下两种配置文件</p><ul><li>bootstrap (.yml 或者 .properties)</li><li>application (.yml 或者 .properties)</li></ul><p>为什么会有这两种配置文件呢？大家都清楚它们的区别和具体使用场景吗？</p><h2 id="bootstrap-application-的区别"><a href="#bootstrap-application-的区别" class="headerlink" title="bootstrap/ application 的区别"></a>bootstrap/ application 的区别</h2><p> Spring Cloud 的官方文档;</p><p>Spring Cloud 构建于 Spring Boot 之上，在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, <code>bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性</code>。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。</p><p><strong>因此，对比 application 配置文件，bootstrap 配置文件具有以下几个特性。</strong></p><ul><li>boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载</li><li>boostrap 里面的属性不能被覆盖</li></ul><h2 id="bootstrap-application-的应用场景"><a href="#bootstrap-application-的应用场景" class="headerlink" title="bootstrap/ application 的应用场景"></a>bootstrap/ application 的应用场景</h2><p>application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。</p><p>bootstrap 配置文件有以下几个应用场景。</p><ul><li>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</li><li>一些固定的不能被覆盖的属性</li><li>一些加密/解密的场景</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Optional</title>
    <link href="/2022/05/21/Optional/"/>
    <url>/2022/05/21/Optional/</url>
    
    <content type="html"><![CDATA[<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><h2 id="认识并使用"><a href="#认识并使用" class="headerlink" title="认识并使用"></a>认识并使用</h2><p>相信不少小伙伴已经被java的NPE(Null Pointer Exception)所谓的空指针异常搞的头昏脑涨,有大佬说过“防止 NPE，是程序员的基本修养。”但是修养归修养，也是我们程序员最头疼的问题之一，那么我们今天就要尽可能的利用Java8的新特性 Optional来尽量简化代码同时高效处理NPE（Null Pointer Exception 空指针异常）</p><p>简单来说，Opitonal类就是Java提供的为了解决大家平时判断对象是否为空用 会用 null!=obj 这样的方式存在的判断，从而令人头疼导致NPE（Null Pointer Exception 空指针异常），同时Optional的存在可以让代码更加简单，可读性跟高，代码写起来更高效.</p><p>常规判断：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//对象 人</span><br><span class="hljs-comment">//属性有 name，age</span><br>Person person=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span>==person)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;person为null&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> person;<br></code></pre></td></tr></table></figure><p>使用Optional：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//对象 人</span><br><span class="hljs-comment">//属性有 name，age</span><br>Person person=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">return</span> Optional.ofNullable(person).orElse(<span class="hljs-string">&quot;person为null&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="Optional对象创建"><a href="#Optional对象创建" class="headerlink" title="Optional对象创建"></a>Optional对象创建</h2><p>首先我们先打开Optional的内部,去一探究竟 先把几个创建Optional对象的方法提取出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Optional</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// final 修饰的属性要么在定义处初始化要么在构造函数处初始化</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Optional</span>&lt;&gt;();<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T value;<br>   <span class="hljs-comment">//我们可以看到两个构造方格都是private 私有的</span><br>   <span class="hljs-comment">//说明 我们没办法在外面去new出来Optional对象</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">Optional</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 在构造函数出初始化</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">Optional</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = Objects.requireNonNull(value);<br>    &#125;<br>    <span class="hljs-comment">// 这个静态方法大致是创建出一个包装值为空的一个对象因为没有任何参数赋值</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-comment">// 这个静态方法大致是创建出一个包装值非空的一个对象因为做了赋值</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Optional</span>&lt;&gt;(value);<br>    &#125;<br>    <span class="hljs-comment">// 这个静态方法大致是如果参数value为空，则创建空对象，如果不为空，则创建有参对象</span><br>    <span class="hljs-comment">// 其实就是用来构造Optional对象的</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="hljs-title function_">ofNullable</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> ? empty() : of(value);<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>再做一个简单的实例展示 与上面对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1、创建一个包装对象值为空的Optional对象</span><br>Optional&lt;String&gt; optEmpty = Optional.empty();<br><span class="hljs-comment">// 2、创建包装对象值非空的Optional对象</span><br>Optional&lt;String&gt; optOf = Optional.of(<span class="hljs-string">&quot;optional&quot;</span>);<br><span class="hljs-comment">// 3、创建包装对象值允许为空也可以不为空的Optional对象</span><br>Optional&lt;String&gt; optOfNullable1 = Optional.ofNullable(<span class="hljs-literal">null</span>);<br>Optional&lt;String&gt; optOfNullable2 = Optional.ofNullable(<span class="hljs-string">&quot;optional&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="Optional-get-方法-返回对象的值"><a href="#Optional-get-方法-返回对象的值" class="headerlink" title="Optional.get()方法(返回对象的值)"></a>Optional.get()方法(返回对象的值)</h2><p>get()方法是返回一个option的实例值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// value为Optional的一个私有成员变量，通过of方法赋值，ofNullAble会调用of方法</span><br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>(<span class="hljs-string">&quot;No value present&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是如果value不为空则做返回，如果为空则抛出异常 “No value present” 简单实例展示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.setAge(<span class="hljs-number">2</span>);<br>Optional.ofNullable(person).get();<br></code></pre></td></tr></table></figure><h2 id="Optional-isPresent-方法-判读是否为空"><a href="#Optional-isPresent-方法-判读是否为空" class="headerlink" title="Optional.isPresent()方法(判读是否为空)"></a>Optional.isPresent()方法(判读是否为空)</h2><p>isPresent()方法就是会返回一个boolean类型值，如果对象不为空则为真，如果为空则false 源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过Optional.ofNullAble()方法构造Optional对象然后通过isPresent判断是否为空</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">isPresent</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单的实例展示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.setAge(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span> (Optional.ofNullable(person).isPresent())&#123;<br>    <span class="hljs-comment">//写不为空的逻辑</span><br>    System.out.println(<span class="hljs-string">&quot;不为空&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//写为空的逻辑</span><br>    System.out.println(<span class="hljs-string">&quot;为空&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Optional-ifPresent-方法-判读是否为空并返回函数"><a href="#Optional-ifPresent-方法-判读是否为空并返回函数" class="headerlink" title="Optional.ifPresent()方法(判读是否为空并返回函数)"></a>Optional.ifPresent()方法(判读是否为空并返回函数)</h2><p>这个意思是如果对象非空，则运行函数体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参数为一个消费者，如果不为空会执行消费者的方法，lamada表达式  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ifPresent</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; consumer)</span> &#123;<br>        <span class="hljs-comment">//如果value不为空，则运行accept方法体</span><br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>)<br>            consumer.accept(value);<br>    &#125;<br></code></pre></td></tr></table></figure><p>看实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.setAge(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// ifPresent的参数是一个消费者，消费者不会有返回值，所以如果你有返回值那么也将会被ignore</span><br><span class="hljs-comment">// Result of &#x27;Employee.getSalary()&#x27; is ignored</span><br>Optional.ofNullable(person).ifPresent(p -&gt; System.out.println(<span class="hljs-string">&quot;年龄&quot;</span>+p.getAge()));<br></code></pre></td></tr></table></figure><h2 id="Optional-filter-方法-过滤对象"><a href="#Optional-filter-方法-过滤对象" class="headerlink" title="Optional.filter()方法(过滤对象)"></a>Optional.filter()方法(过滤对象)</h2><p>filter()方法大致意思是，接受一个对象，然后对他进行条件过滤，如果条件符合则返回Optional对象本身，如果不符合则返回空Optional</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Optional&lt;T&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; predicate)</span> &#123;<br>    Objects.requireNonNull(predicate);<br>    <span class="hljs-comment">//如果为空直接返回this</span><br>    <span class="hljs-keyword">if</span> (!isPresent())<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//判断返回本身还是空Optional</span><br>    <span class="hljs-keyword">return</span> predicate.test(value) ? <span class="hljs-built_in">this</span> : empty();<br>&#125;<br></code></pre></td></tr></table></figure><p>简单实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.setAge(<span class="hljs-number">2</span>);<br>Optional.ofNullable(person).filter(p -&gt; p.getAge()&gt;<span class="hljs-number">50</span>);<br></code></pre></td></tr></table></figure><h2 id="Optional-map-方法-对象进行二次包装"><a href="#Optional-map-方法-对象进行二次包装" class="headerlink" title="Optional.map()方法(对象进行二次包装)"></a>Optional.map()方法(对象进行二次包装)</h2><p>map()方法将对应Funcation函数式接口中的对象，进行二次运算，封装成新的对象然后返回在Optional中</p><p>将一个Optional,转换为另一个Optional</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;<br>       Objects.requireNonNull(mapper);<br>       <span class="hljs-comment">//如果为空返回自己</span><br>       <span class="hljs-keyword">if</span> (!isPresent())<br>           <span class="hljs-keyword">return</span> empty();<br>       <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">//否则返回用方法修饰过的Optional</span><br>           <span class="hljs-keyword">return</span> Optional.ofNullable(mapper.apply(value));<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.setAge(<span class="hljs-number">2</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">optName</span> <span class="hljs-operator">=</span> Optional.ofNullable(person).map(p -&gt; person.getName()).orElse(<span class="hljs-string">&quot;name为空&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="Optional-orElse-方法-为空返回对象"><a href="#Optional-orElse-方法-为空返回对象" class="headerlink" title="Optional.orElse()方法(为空返回对象)"></a>Optional.orElse()方法(为空返回对象)</h2><p>常用方法之一，这个方法意思是如果包装对象为空的话，就执行orElse方法里的value，如果非空，则返回写入对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">orElse</span><span class="hljs-params">(T other)</span> &#123;<br>    <span class="hljs-comment">//如果非空，返回value，如果为空，返回other</span><br>    <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span> ? value : other;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Optional-orElseGet-方法-为空返回Supplier对象"><a href="#Optional-orElseGet-方法-为空返回Supplier对象" class="headerlink" title="Optional.orElseGet()方法(为空返回Supplier对象)"></a>Optional.orElseGet()方法(为空返回Supplier对象)</h2><p>这个与orElse很相似，入参不一样，入参为Supplier对象，为空返回传入对象的.get()方法，如果非空则返回当前对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">orElseGet</span><span class="hljs-params">(Supplier&lt;? extends T&gt; other)</span> &#123;<br>    <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span> ? value : other.get();<br>&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Supplier&lt;Person&gt;&gt; sup=Optional.ofNullable(Person::<span class="hljs-keyword">new</span>);<br><span class="hljs-comment">//调用get()方法，此时才会调用对象的构造方法，即获得到真正对象</span><br>Optional.ofNullable(person).orElseGet(sup.get());<br></code></pre></td></tr></table></figure><p>说真的对于Supplier对象我也懵逼了一下，去网上简单查阅才得知 Supplier也是创建对象的一种方式,简单来说，Suppiler是一个接口，是类似Spring的懒加载，声明之后并不会占用内存，只有执行了get()方法之后，才会调用构造方法创建出对象创建对象的语法的话就是<code>Supplier supPerson= Person::new;</code>需要使用时<code>supPerson.get()</code>即可</p><h2 id="Optional-orElseThrow-方法-为空返回异常"><a href="#Optional-orElseThrow-方法-为空返回异常" class="headerlink" title="Optional.orElseThrow()方法(为空返回异常)"></a>Optional.orElseThrow()方法(为空返回异常)</h2><p>这个我个人在实战中也经常用到这个方法，方法作用的话就是如果为空，就抛出你定义的异常，如果不为空返回当前对象，在实战中所有异常肯定是要处理好的，为了代码的可读性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;X <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; T <span class="hljs-title function_">orElseThrow</span><span class="hljs-params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="hljs-keyword">throws</span> X &#123;<br>    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> exceptionSupplier.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//简单的一个查询</span><br><span class="hljs-type">Member</span> <span class="hljs-variable">member</span> <span class="hljs-operator">=</span> memberService.selectByPhone(request.getPhone());<br>Optional.ofNullable(member).orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceException</span>(<span class="hljs-string">&quot;没有查询的相关数据&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="相似方法进行对比分析"><a href="#相似方法进行对比分析" class="headerlink" title="相似方法进行对比分析"></a>相似方法进行对比分析</h2><p>可能小伙伴看到这，没用用过的话会觉得orElse()和orElseGet()还有orElseThrow()很相似，map()和flatMap()好相似</p><p>哈哈哈不用着急，都是从这一步过来的，我再给大家总结一下不同方法的异同点</p><p><strong>orElse()和orElseGet()和orElseThrow()的异同点</strong></p><p>方法效果类似，如果对象不为空，则返回对象，如果为空，则返回方法体中的对应参数，所以可以看出这三个方法体中参数是不一样的</p><ul><li>orElse（T 对象）</li><li>orElseGet（Supplier &lt; T &gt;对象）</li><li>orElseThrow（异常）</li></ul><p><strong>map()和orElseGet的异同点</strong></p><ul><li>方法效果类似，对方法参数进行二次包装，并返回,入参不同</li><li>map（function函数）</li><li>flatmap（Optional&lt; function &gt;函数）</li></ul><p>具体要怎么用，要根据业务场景以及代码规范来定义，下面可以简单看一下我在实战中怎用使用神奇的Optional</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js时间格式化方法</title>
    <link href="/2022/05/11/js%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/11/js%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="js时间格式化方法"><a href="#js时间格式化方法" class="headerlink" title="js时间格式化方法"></a>js时间格式化方法</h1><p>我一个搞后端的让我帮他们调前端界面。。。。真是裂开</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Date</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">format</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fmt</span>) &#123;<br>  <span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-string">&quot;M+&quot;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>, <span class="hljs-comment">//月份</span><br>    <span class="hljs-string">&quot;d+&quot;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getDate</span>(), <span class="hljs-comment">//日</span><br>    <span class="hljs-string">&quot;h+&quot;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getHours</span>(), <span class="hljs-comment">//小时</span><br>    <span class="hljs-string">&quot;m+&quot;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getMinutes</span>(), <span class="hljs-comment">//分</span><br>    <span class="hljs-string">&quot;s+&quot;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getSeconds</span>(), <span class="hljs-comment">//秒</span><br>    <span class="hljs-string">&quot;q+&quot;</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">3</span>) / <span class="hljs-number">3</span>), <span class="hljs-comment">//季度</span><br>    <span class="hljs-attr">S</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getMilliseconds</span>() <span class="hljs-comment">//毫秒</span><br>  &#125;;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/(y+)/</span>.<span class="hljs-title function_">test</span>(fmt)) &#123;<br>    fmt = fmt.<span class="hljs-title function_">replace</span>(<br>      <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>,<br>      (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getFullYear</span>() + <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">substr</span>(<span class="hljs-number">4</span> - <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>.<span class="hljs-property">length</span>)<br>    );<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> o) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;(&quot;</span> + k + <span class="hljs-string">&quot;)&quot;</span>).<span class="hljs-title function_">test</span>(fmt)) &#123;<br>      fmt = fmt.<span class="hljs-title function_">replace</span>(<br>        <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>,<br>        <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>.<span class="hljs-property">length</span> == <span class="hljs-number">1</span> ? o[k] : (<span class="hljs-string">&quot;00&quot;</span> + o[k]).<span class="hljs-title function_">substr</span>((<span class="hljs-string">&quot;&quot;</span> + o[k]).<span class="hljs-property">length</span>)<br>      );<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> fmt;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@/utils/dateFormat&quot;</span>;<br><br><span class="hljs-keyword">let</span> syncTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">format</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2022/05/01/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/05/01/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h2><p>说一下我的理解，就不用那些冠冕堂皇的话说了，直接白话文。</p><p>策略策略，策略是用来干嘛的呢？策略是用来解决问题的，也是一类问题的解决方案。就是我们常说的。</p><p>小明：我遇到了一个问题，你有什么策略应对吗？</p><p>我：有啊。</p><p>这里就说明了什么是策略，解决问题的方案。</p><p>还有人说策略模式可以消除if else …..</p><p>其实不能。。就像上面说的策略模式只是针对某种问题提出一种应对策略。该有的if else还是有的，策略模式只是把if else里面的代码段（也就是解决这个问题所要做的事情）换为某一种策略。</p><p>那如何消除if else呢，首先要明白会有if else的原因。知道了原因就好解决嘛。之所以要有很多if else是我们不知道发生的这种问题改用哪种解决方案。所以如何解决呢，我们可以把问题跟策略通过KV的形式将其绑定起来，那么下次出问题我们只要知道问题的类型，就可以获得到相应的解决策略。</p><h2 id="代码体现"><a href="#代码体现" class="headerlink" title="代码体现"></a>代码体现</h2><h3 id="策略接口"><a href="#策略接口" class="headerlink" title="策略接口"></a>策略接口</h3><p>新建一个策略接口，以后所有的策略都要实现这个接口。这样做的好处是让各种策略的风格都保持一致吧。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Handler</span>&#123;<br><br>    <span class="hljs-comment">// 具体的解决方案由自己实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AAA</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="具体的策略"><a href="#具体的策略" class="headerlink" title="具体的策略"></a>具体的策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KangBaHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AAA</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-comment">// 业务逻辑A</span><br>        System.out.println(<span class="hljs-string">&quot;亢八完成任务&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这样也就算是好了。但是为了解决if else我们引入工厂模式</p><h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工厂设计模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br><br>    <span class="hljs-comment">// 通过键值对的形式存储每种策略，key为某种问题，value为处理这个问题对应的策略</span><br>    <span class="hljs-comment">// 原本是需要通过大量的if else来判断使用那种模式模式处理，问题就在于判断出用哪种</span><br>    <span class="hljs-comment">// 所以我们就通过键值对的形式直接告诉他哪种问题用哪种策略解决</span><br>    <span class="hljs-comment">// 相当于是一个花名册</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Handler&gt; strategyMap = Maps.newHashMap();<br><br>    <span class="hljs-comment">// 根据name获取对应的处理策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Handler <span class="hljs-title function_">getInvokeStrategy</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> strategyMap.get(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 将策略注册到Map</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String name, Handler handler)</span> &#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name) || <span class="hljs-literal">null</span> == handler) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        strategyMap.put(name, handler);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何注册到工厂的map里面呢？这里要了解Bean的生命周期了。细心的同学会看到我的具体的策略加了<code>@Component</code>注解。加了这个注解表示这是一个组件，也是Spring的一个Bean，他的生命周期由Spring来接管。那我们就可以在Bean生命周期里做手脚让他注册到Factory的map里面。</p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>class  ——&gt;   实例化 ——–&gt;  对象 ——–&gt;属性填充———&gt;BeanPostProcessor、InitializingBean——&gt;……..——–&gt;Bean</p><p><img src="01.png" alt="01"></p><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>这个也是一个很经常在工程中看到的接口实现，从字面上 BeanPostProcessor 的意思就是 Bean 的后置处理器。主要作用就是帮助我们在bean实例化之后，初始化前后做一些事情。</p><p>spring 会自动从它的所有的 bean 定义中检测 BeanPostProcessor 类型的bean 定义，然后实例化它们，再将它们应用于<strong>随后</strong>创建的<strong>每一个</strong>bean实例。<br>在 bean 实例的初始化方法回调之前调用 BeanPostProcessor 的postProcessBeforeInitialization 的方法（进行 bean 实例属性的填充）。<br>在 bean 实例的初始化方法回调之后调用 BeanPostProcessor 的postProcessAfterInitialization 的方法（可以进行 bean 实例的代理封装）。</p><p>这里有两个关键字，第一个是：<code>随后创建的</code>  第二个是：<code>每一个</code></p><p>因为是应用于随后创建的每一个Bean，所以第一要想保证我们的策略类都可以注册进去，那么就得让他在这后面，，，其次她说满足 BeanPostProcessor 类型的bean 定义所以我们的Bean都可以注册进去。</p><p><em>BeanPostProcessor</em>的作用域是<code>容器级</code>的，<strong>它只和所在容器有关</strong>。如果你在容器中定义了<em>BeanPostProcessor,<em>它仅仅对此容器中的</em>bean</em>进行后置。它不会对定义在另一个容器中的<em>bean</em>进行任何处理。</p><p>注意的一点：</p><p>BeanFactory和ApplicationContext对待bean后置处理器稍有不同。ApplicationContext会自动检测在配置文件中实现了BeanPostProcessor接口的所有bean，并把它们注册为后置处理器，然后在容器创建bean的适当时候调用它。部署一个后置处理器同部署其他的bean并没有什么区别。而使用BeanFactory实现的时候，bean 后置处理器必须通过下面类似的代码显式地去注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BeanPostPrcessorImpl</span> <span class="hljs-variable">beanPostProcessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPostPrcessorImpl</span>();<br><span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemResource</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-type">ConfigurableBeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanFactory</span>(resource);<br>factory.addBeanPostProcessor(beanPostProcessor);<br><br></code></pre></td></tr></table></figure><p><strong>注册器实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerScaner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> ,PriorityOrdered&#123;<br><br>    <span class="hljs-comment">// 保证我们这个Bean的优先级,是应用于随后的每一个BeanPostProcessor类型的Bean定义</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Ordered.LOWEST_PRECEDENCE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        Class&lt;?&gt; aClass = bean.getClass();<br>        <span class="hljs-comment">// 判断aClass是不是Handler的一个子类或者子接口</span><br>        <span class="hljs-keyword">if</span> (Handler.class.isAssignableFrom(aClass))&#123;<br>            System.out.println(<span class="hljs-string">&quot;已加载组件： &quot;</span> + aClass.getSimpleName());<br>            <span class="hljs-comment">// getSimpleName获取的是简单类名和不是全类名</span><br>            Factory.register( aClass.getSimpleName(), (Handler) bean);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h4><p>和BeanPostProcessor 的区别，InitializingBean的作用域不是容器级的，只有实现了InitializingBean接口的Bean才会自动调用afterPropertitySet(),所以我们以后定义的每一个策略都要实现这个接口然后注册到map里面去，这就相对麻烦些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Handler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InitializingBean</span>&#123;<br><br>    <span class="hljs-comment">// 具体的解决方案由自己实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AAA</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KangBaHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AAA</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-comment">// 业务逻辑A</span><br>        System.out.println(<span class="hljs-string">&quot;亢八完成任务&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Factory.register(<span class="hljs-string">&quot;KangBaHandler&quot;</span>,<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再识Integer</title>
    <link href="/2022/04/30/%E5%86%8D%E8%AF%86Integer/"/>
    <url>/2022/04/30/%E5%86%8D%E8%AF%86Integer/</url>
    
    <content type="html"><![CDATA[<h1 id="再识Integer"><a href="#再识Integer" class="headerlink" title="再识Integer"></a>再识Integer</h1><h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><p>Integer是对象，int是基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br>Integer integer5= Integer.valueOf(<span class="hljs-number">100</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer1</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">101</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">101</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><h2 id="Integer-valueOf"><a href="#Integer-valueOf" class="headerlink" title="Integer.valueOf"></a>Integer.valueOf</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// high value may be configured by property</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">integerCacheHighPropValue</span> <span class="hljs-operator">=</span><br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                    <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>                &#125;<br>            &#125;<br>            high = h;<br><br>            cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br><br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>    &#125;<br></code></pre></td></tr></table></figure><p>Integer.valueOf()返回一个Integer对象，Integer底层维护了一个cache，因为我们常用的数值是处于-128~127之间的Java为了不反复创建对象，会从这个cache中返回，也就是说我连续创建两个Integer.valueOf(100),他们其实返回的是同一个，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">integer == integer5    <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">i == integer5          <span class="hljs-comment">// true</span><br><span class="hljs-comment">// ==100 和valueOf()都是干了同样一件事都是从cache里面取得</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>i == a    <span class="hljs-comment">// true Integer和int进行比较时会自动拆包为int然后进行比较</span><br></code></pre></td></tr></table></figure><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>== 是直接比较值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br>        Integer integer5= Integer.valueOf(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>integer == integer5 因为valueOf从cache里面返回得是同一个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">integer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">100</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>i == integer2  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>==100 和valueOf()都是干了同样一件事都是从cache里面取的，Integer2开辟一段存储空间，里面保存的值是new Integer(100)的地址，new Integer(100)是在堆中创建的明显地址值不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <br>a=c  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>Integer 和int进行比较时会进行拆包转换为int然后进行比较。    </p><p><code>equals</code>是Object的方法，所有的类都有这个方法，他的底层重写逻辑也是通过 == 号实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer userId;<br><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">// 是同一个引用直接返回true</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 为空或者不是一个class直接返回false</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) o;<br>        <span class="hljs-comment">// 判断具体各个属性值是否相等，Integer String均重写了equals方法</span><br>        <span class="hljs-keyword">return</span> userId.equals(user.userId) &amp;&amp; userName.equals(user.userName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(userId, userName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Integer的</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>            <span class="hljs-comment">// 也是通过intValue()</span><br>            <span class="hljs-type">return</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span>= ((Integer)obj).intValue();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// String</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br>            <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>                <span class="hljs-type">char</span> v1[] = value;<br>                <span class="hljs-type">char</span> v2[] = anotherString.value;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h2><p>我们要比较两个Integer可以通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> (x &lt; y) ? -<span class="hljs-number">1</span> : ((x == y) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>他返回的是一个int类型，可以根据返回的int直接判断大小   == 0   ==-1  ==1</p><h2 id="intValue"><a href="#intValue" class="headerlink" title="intValue()"></a>intValue()</h2><p>通过将integer.intValue()方法转变为int,然后再比较两个Integer</p>]]></content>
    
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis批量更新插入数据</title>
    <link href="/2022/04/27/MyBatis%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/04/27/MyBatis%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis批量更新插入数据"><a href="#MyBatis批量更新插入数据" class="headerlink" title="MyBatis批量更新插入数据"></a>MyBatis批量更新插入数据</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天中午突然想到MyBatis框架，然后想到我在更新、插入、修改操作的时候他返回的值到底是多少？</p><p>一时间想不起来，在网山找了一些文章，发现他们说的互相冲突。</p><p>于是晚上下班，开始验证。</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>新建一个springboot项目</p><p>引入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-comment">&lt;!-- SpringBoot集成mybatis框架 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--阿里数据库连接池 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-comment">#驱动名</span><br>    <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-comment">#数据源类型此处是德鲁伊数据源，还有三种数据源</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-attr">druid:</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">xn123456</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3309/db?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8</span><br><span class="hljs-comment">#配置mybatis</span><br><span class="hljs-attr">mybatis:</span><br><span class="hljs-comment">#mybatis配置文件所在的位置 注意 ：classpath后面不要加 / </span><br>  <span class="hljs-attr">config-location:</span> <span class="hljs-string">classpath:mybatis/mybatis-config.xml</span><br>  <span class="hljs-comment">#别名，在这里配置后，就不需要在mapper。xml里面的参数类型就不用写全路径了</span><br>  <span class="hljs-attr">typeAliasesPackage:</span> <span class="hljs-string">com.example.demo.domain</span><br>  <span class="hljs-comment">#mapper.xml文件所在的位置</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/*Mapper.xml</span><br></code></pre></td></tr></table></figure><p><code>mybatis-config.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span>             <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>  <span class="hljs-comment">&lt;!-- 全局映射器启用缓存 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span>         <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>  <span class="hljs-comment">&lt;!-- 允许 JDBC 支持自动生成主键 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultExecutorType&quot;</span>      <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;REUSE&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 配置默认的执行器 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span>                  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SLF4J&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 指定 MyBatis 所用日志的具体实现 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;  驼峰式命名 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>在主启动类上加MapperScan</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定要扫描的Mapper类的包的路径(对于Mybatis两点重要：其一是MapperScan，其二是Mapper.xml位置的配置)</span><br><span class="hljs-meta">@MapperScan(&quot;com.dean.test_mybatis.**.mapper&quot;)</span><br></code></pre></td></tr></table></figure><p><code>批量插入sql</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(user_id,user_name)<span class="hljs-keyword">values</span><br><span class="hljs-operator">&lt;</span>trim suffixOverrides<span class="hljs-operator">=</span>&quot;,&quot;<span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span>foreach collection<span class="hljs-operator">=</span>&quot;list&quot; item<span class="hljs-operator">=</span>&quot;item&quot; index<span class="hljs-operator">=</span>&quot;index&quot; separator<span class="hljs-operator">=</span>&quot;,&quot;<span class="hljs-operator">&gt;</span><br>         <span class="hljs-operator">&lt;</span>trim prefix<span class="hljs-operator">=</span>&quot;(&quot; suffix<span class="hljs-operator">=</span>&quot;)&quot; suffixOverrides<span class="hljs-operator">=</span>&quot;,&quot;<span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;item.userId != null&quot;<span class="hljs-operator">&gt;</span>#&#123;item.userId&#125;, <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;item.userName != null&quot;<span class="hljs-operator">&gt;</span>#&#123;item.userName&#125;, <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>         <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>trim<span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>foreach<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>trim<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>当需要插入的数据较多时可以分批插入</p><p><code>测试代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setUserId(<span class="hljs-number">1996</span>);<br>        user.setUserName(<span class="hljs-string">&quot;111&quot;</span>);<br>        users.add(user);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;2222&quot;</span>);<br>        users.add(user1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> testService.testSave(users);<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">28</span> <span class="hljs-number">00</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30.868</span> ERROR <span class="hljs-number">11808</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="hljs-keyword">for</span> servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.dao.DuplicateKeyException: <br>### Error updating database.  Cause: java.sql.SQLIntegrityConstraintViolationException: Duplicate entry <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;PRIMARY&#x27;</span><br><br></code></pre></td></tr></table></figure><p><img src="01.png" alt="01"></p><p><code>结论</code></p><p><strong>假如传入10条，有一条错误则抛出异常，且数据全部插入不成功</strong></p><p><code>第二种方式</code></p><p><strong>首先在jdbc链接里设置允许单次执行多条SQL</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">allowMultiQueries=true</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;;&quot;</span>&gt;</span><br>    insert into user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;item.userName != null&quot;</span>&gt;</span>user_name,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;item.userId != null&quot;</span>&gt;</span>user_id,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;values(&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;item.userName != null&quot;</span>&gt;</span>#&#123;item.userName&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;item.userId != null&quot;</span>&gt;</span>#&#123;item.userId&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>结论</code> <strong>这是多条sql insert 如果全部执行成功返回 1 如果有失败的抛出异常  并且前面插入成功的不会回滚掉   不建议使用   会被项目经理砍的</strong>    </p><p><code>批量更新</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testUpdate&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.util.List&quot;</span>&gt;</span><br>       update user<br>           <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot; user_name = case&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;end,&quot;</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> &gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;item.userName != null&quot;</span>&gt;</span><br>                           when user_id = #&#123;item.userId&#125; then #&#123;item.userName&#125;<br>                       <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>                   <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>        where user_id in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>                #&#123;item.userId&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;batchUpdateProductSyncStatus&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.util.List&quot;</span>&gt;</span><br>        update hf_product<br>        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot; sync_state =case&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;end,&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&#x27;item.value !=null and item.value !=&quot;&quot;&#x27;</span> &gt;</span><br>                        when serial_no = #&#123;item.value&#125; then #&#123;item.syncState&#125;<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot; sync_time =case&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;end,&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&#x27;item.value !=null and item.value !=&quot;&quot;&#x27;</span> &gt;</span><br>                        when serial_no = #&#123;item.value&#125; then #&#123;item.syncTime&#125;<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>        where<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> &gt;</span><br>            serial_no=#&#123;item.value&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>结论</code></p><ol><li>当update成功时返回match的条数</li><li>有一条失败时直接报错，且所有update不生效</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不一般的单例模式</title>
    <link href="/2022/04/26/%E4%B8%8D%E4%B8%80%E8%88%AC%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/26/%E4%B8%8D%E4%B8%80%E8%88%AC%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="不一般的单例模式"><a href="#不一般的单例模式" class="headerlink" title="不一般的单例模式"></a>不一般的单例模式</h1><h2 id="多线程下的单例模式"><a href="#多线程下的单例模式" class="headerlink" title="多线程下的单例模式"></a>多线程下的单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StudentSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (StudentSingleton.class)&#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)&#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentSingleton</span>();<span class="hljs-comment">//*</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述星号处其实包括三个步骤：</p><ul><li>在堆内存中开辟空间 ①</li><li>调用构造方法，初始化对象信息 ②</li><li>将堆内存地址赋值给栈内存的instance ③</li></ul><p>但是在 JVM 中，会根据一定的条件进行优化，导致部分不相互依赖的语句可能会进行顺序的调整，这样可以优化硬件的使用效率（这里不细说，关于一些寄存器了）。 经过指令重排之后，单线程下依旧可以保证最终结果一致性，如果连基本正确性都无法保证，那么优化也没有任何意义了。但是在多线程情况下，指令重排之后，就会出现一些问题了。</p><p><img src="01.png" alt="01"></p><p>当发生指令重排后，线程1，在①处，顺序可能变为 1 -&gt; 3 -&gt; 2 , 而当执行完第二步赋值后，还没完成初始化，此时CPU执行切换到线程2。那么此时线程2进行instance判空的话，不为空，但是此时线程1的初始化操作可能没有完成。这样如果线程2的调用者在操作对象时，可能会造成某些对象没有，比如抛出空指针异常 NullPointerException. 那有什么解决办法呢？由于jdk5之后对volatile关键字加强作用后，可以使用关键字volatile关键字修饰instance。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonSingleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">PersonSingleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> PersonSingleton instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PersonSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(PersonSingleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonSingleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道synchronized关键字可以保证线程安全，即可以保证：①原子性 ②可见性 ③ 有序性。至于这三个特性的具体含义，这里不再详细描述了。但是，即使将创建对象的代码放在synchronized代码块中，也无法解决指令重排的问题，此时就需要使用我们的volatile关键字了。使用volatile关键字修饰instance之后，可以防止指令重排，即不会出现步骤2 和 步骤3 进行换序的问题 （ 1-&gt;2-&gt;3），也就不会出现线程2 读取到 instance不为null，但是可以使用内部属性出现异常的情况。<br>留疑：在double-check 下的单例模式，即使发生指令重排，是否异常只会发生在多核CPU下，单核CPU是不是不会出现问题呢？</p><p>经过讲述单例模式的几种方式，以及double-checked locking问题，引入了关键字synchronized和volatile, 那下面我们就真正的走进多线程。</p><h2 id="并发的三大特性"><a href="#并发的三大特性" class="headerlink" title="并发的三大特性"></a>并发的三大特性</h2><p>三个并发基础 为了保证线程安全，Java并发有哪几个基本特性呢？</p><p>A：有三个特性：①原子性 ②可见性 ③有序性。</p><p>Q：好，能不能详细说一下这三个特性呢？</p><p>A：</p><p>原子性（Atomicity）：这个其实和数据库的原子性是相似的，简单来说就是 要么全做完，要不一点都不做。在多线程中表现为 当线程A在执行一段代码时，不能被其他线程所干扰。同时在这段代码开始执行到执行完过程中，CPU的执行权不会能进行切换，即不能中断，要么全部执行完，要么就不执行，这样才能保证原子性。<br>可见性（Visibility）：表现为线程A对共享资源的操作对其他线程是及时可见的，即其他线程可以立即知道共享资源发生了修改。显然在串行程序中，可见性问题是不存在的。因为你在任何一个操作步骤中修改了某一个变量，后续的步骤中都可以读取到这个变量的值，而且读取到的都是修改后的值。<br>有序性（Ordering）：串行化的程序中，其实有序性的问题是不存在，即使JVM进行优化，也必须保证语句的最终一致性。所以在我们看来就相当于代码从上至下依次执行。 但是在多线程环境下，代码的顺序就难以预测了，可能由于指令重排的发生，会导致一些看似不可能发生的问题。所以：如果在本线程中观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前者是指“线程内表现为串行语义”。而后者是指“指令重排”现象和“工作内存和主内存同步延迟”现象。<br>对于有序性，有一些指令是不允许指令重排的，称为先行发生原则 (happens-before relationship)</p><p>程序顺序原则：一个线程内，按照代码顺序，书写在前面的操作先行发生于后面的操作。<br>锁定规则：一个unLock 操作先行发生于后面对同一个锁的lock操作。<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。<br>传递规则：如果操作A先行发生于操作B，而操作B有先行发生于操作C，则可以得出操作A先行发生于操作C。<br>线程启动规则：Thread对象的start方法先行发生于此线程的每一个动作。<br>线程中断规则：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生。<br>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join() 方法结束，Thread.isAlive() 的返回值手段检测到线程已经终止执行。<br>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 关键字是JDK内置的。是一个内置可重入锁，据说在jdk5之前，这个内置锁的效率不怎么样，但是等到了jdk5了，jdk进行了大量的优化，现在的效率已经非常不错了。</p><p>那为什么我们会使用到synchronized呢？因为在多线程场景下，存在共享数据，多个线程会去操作共享数据，导致共享数据会出现线程安全的问题。所以我们需要使用synchronized关键字修饰，将共享资源的操作放置到同步代码中，使得每次只有一个线程进行操作。这样就可以保证线程安全了。</p><p>synchronized 可以保证并发安全，即能保证 ① 原子性 ② 有序性 ③可见性</p><p>synchronized 底层是使用字节码指令 monitorenter 和 monitorexit 实现的。</p><p>我们将下面这段代码使用javap命令看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (SynchronizedTest.class) &#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="02.png" alt="02"></p><p>可以看到，其中使用同步代码块的方法，多了monitorenter 和 monitorexit两条指令。</p><p>synchronized 关键字的三种使用方式：</p><p>修饰静态方法。锁的是当前类的class对象。<br>修饰普通方法。锁的是当前对象。(this)<br>修饰代码块。则锁的是指定的对象。<br>下面我们通过代码演示一下：</p><p><strong>锁静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorObject</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码synchronized关键字锁的是 <strong>MonitorObject.class</strong> 对象。也就是上面的第一种情况。</p><p><strong>锁普通方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorObject</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码，调用method方法时，锁的是当前调用的对象。即下面的代码中，锁的是 <strong>obj</strong> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">MonitorObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonitorObject</span>();<br>    obj.method();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>锁代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorObject</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">ob</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(ob)&#123;  <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码显而易见就是锁的ob对象。当多个线程来访问，都需要获取ob锁，如果被占用，则阻塞等待。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知其他线程。</p><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile修饰之后，那么久具备了两层语义：</p><p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某变量的值，这个新值对其他线程来说是立即可见的。</p><p>2）禁止进行指令重排。</p><p>现在的处理器都是多核CPU的，那我们用图来简单描述一下线程与主存的联系，可以发现中间有一个CPU cache。由于CPU与主存的数据的频繁交互，在一定程度上也会降低性能，所以现在的处理器中，一般CPU都会相应的告诉缓存。如果单核CPU到不会出现数据不一致的问题，因为都是操作相同的高速缓存，但是放在多核CPU就会出现问题。<br><img src="03.png" alt="03"></p><p>如上图所示，假如线程1在CPU1中执行，而线程2在CPU2中执行。当两个线程都需要对主存中的共享变量进行操作时，CPU1和CPU2都会将Main Memory 中的共享变量拷贝一份到自己的cpu cache中，这样就会出现问题。</p><p>我们来看一下下面的代码，线程1先执行，线程2后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程1</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span>(!stop)&#123;<br>    doSomething();<br>&#125;<br> <br><span class="hljs-comment">//线程2</span><br>stop = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>这段代码我们不能把它放在一个方法里，需要分来，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileDemo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">while</span> (!stop) &#123;<br>            System.out.println(<span class="hljs-string">&quot;doSomething...&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;stop:&quot;</span> + stop);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateStopState</span><span class="hljs-params">()</span> &#123;<br>        stop = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述代码需要先ThreadA调用method，然后ThreadB调用updateStopState 方法。这段代码在测试过程中，很难遇到死循环的问题，但是这段代码理论上是有问题的。即：如果ThreadA和ThreadB分别在不同的CPU上执行的话，首先AB线程都会把共享数据stop拷贝一份放置到自己的高速缓存中，此时线程A判断自己的缓存的stop为false，循环执行，此时线程B修改stop为true，然后写回主存，但是此时ThreadA无法感知到变化，因为自己的高速缓存的stop一致是false，这样就会出现死循环的问题。此时就需要使用volatile 修饰stop变量了。</p><p>volatile修饰之后就变得不一样了：</p><p>第一：使用volatile关键字会强制将修改的值立即写入到主存。</p><p>第二：使用volatile关键字的话，当线程B进行修改时，会导致线程A的工作内存中缓存变量stop的缓存行无效。（反映到硬件层面的话，就是CPU的L1和L2缓存中对象的缓存行失效）；</p><p>第三：由于线程A的工作内存中缓存变量stop的缓存行无效，所以线程A再次读取变量的值时会去主存中读取。</p><p>那么在线程B修改stop的值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写回到主存），会使得线程A的工作内存中缓存变量stop的缓存行无效，然后线程A读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p><p>那么线程A读取到的就是最新的正确的值。</p><h3 id="volatile-能保证原子性吗？"><a href="#volatile-能保证原子性吗？" class="headerlink" title="volatile 能保证原子性吗？"></a>volatile 能保证原子性吗？</h3><p>我们先来看一个实际的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileDemo1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        num++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        List&lt;Future&lt;?&gt;&gt; futureList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">VolatileDemo1</span> <span class="hljs-variable">volatileDemo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileDemo1</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            futureList.add(executorService.submit(volatileDemo1::method));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Future&lt;?&gt; future : futureList) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                future.get();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.println(volatileDemo1.num);<br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过运行上面的例子，通过输出结果我们就可以验证上面的例子。那么这是为什么呢？按我们正常的想法，应该是输出100，但是输出的结果基本都是小于100的。</p><p>如果使用idea的小朋友可能会发现，idea其实有提示：</p><p><img src="03.png" alt="03"></p><p>基本就是：在 volatile 修饰的属性 num 上的操作不是原子操作。</p><p>那这里为什么不是原子操作呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">num++;<br></code></pre></td></tr></table></figure><p>其实num++ 计算不是一步到位的，需要分为三步：</p><ul><li>第一步：read num from memory 读取num的值。</li><li>第二步：add 1 在原来的num基础上加1。</li><li>第三步：write num to memory 将num写回到内存中。</li></ul><p><img src="04.png" alt="04"></p><p>我们可以想象一下，此时num = 10， 当线程A执行到第二步，此时线程A的n变为11，但是还没来得及写回内存，此时CPU执行权切换到线程B，即使此时num是volatile变量，满足可见性，即直接会写回到内存中，但是由于CPU执行权的切换，导致A还没写回到内存中，B已经开始读，读取到的num还是10.执行到第三步，线程B写回到内存值为11. 此时CPU执行权切换回A，A将11写回内存，导致A和B写回的都是11。这也就是输出结果小于100的根本原因，所以volatile不能保证对变量的操作是原子性。</p><p>那如果需要实现上述功能呢，我们可以将代码进行改造：</p><p>方式1：使用synchronized关键字进行同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (VolatileDemo1.class)&#123;<br>        num++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>仅以同步代码块示例。由于此时使用了同步代码块，可以保证并发的三个特性，所以这里num可以不用volatile修饰。</p><p>方式2：使用Lock锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock.lock();<br>        num++;<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用Lock锁来保证临界区的线程安全。</p><p>方式3：使用AtomicInteger原子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    num.incrementAndGet();<br>&#125;<br></code></pre></td></tr></table></figure><p>在java1.5 的 java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的自增(加1操作)，自减（减一操作），以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</p><h3 id="volatile-能保证有序性吗"><a href="#volatile-能保证有序性吗" class="headerlink" title="volatile 能保证有序性吗"></a>volatile 能保证有序性吗</h3><p>volatile关键字可以禁止指令重排序，所以volatile在一定程度上是可以保证有序性的。</p><p>volatile关键字禁止指定重排序有两层意思：</p><p>1）当程序执行到volatile变量的读操作和写操作时，在其前面的操作的更改肯定全部已经进行，切结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><p>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放在其前面执行。</p><p>可能上面的说的比较绕，举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// x,y 为非volatile变量</span><br><span class="hljs-comment">// flag为volatile变量</span><br><br>x = <span class="hljs-number">2</span>;<span class="hljs-comment">//语句1</span><br>y = <span class="hljs-number">0</span>;  <span class="hljs-comment">//语句2</span><br>flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">//语句3</span><br>x = <span class="hljs-number">4</span>;  <span class="hljs-comment">//语句4</span><br>y = -<span class="hljs-number">1</span>; <span class="hljs-comment">//语句5</span><br></code></pre></td></tr></table></figure><p>由于flag变量是volatile变量，那么在进行指令重排序的时候，不会将语句3放在语句1和语句2前面，也不会将语句3放在语句4和语句5后面，但是要注意语句1和语句2的顺序，语句4和语句5的顺序是不作任何保证的。并且volatile关键字能保证，执行到语句3时，语句1和语句2 必定是执行完毕了的，且语句1和语句2的执行结果对语句3和语句4，语句5是可以见的。</p><p>那么再看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程1：</span><br>context=loadContext(); <span class="hljs-comment">//语句1</span><br>inited = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//语句2</span><br><br><span class="hljs-comment">//线程2：</span><br><span class="hljs-keyword">while</span>(!inited)&#123;<br>    sleep();<br>&#125;<br>doSomethingWithConfig(context);<br></code></pre></td></tr></table></figure><p>如果inited 不是volatile修饰的变量的话，如果指定重排，可能会将语句2放在语句1前面，导致语句2先执行。此时线程2进来判断之后，可能此时context还没有加载完成，则会导致程序出错。</p><p>如果我们使用volatile修饰inited变量，就不会出现这种问题，可以保证语句1执行完之后，才会执行语句2，并且context可以保证可见性，线程2是可以立即感知到的。</p><h3 id="volatile-的原理和实现机制"><a href="#volatile-的原理和实现机制" class="headerlink" title="volatile 的原理和实现机制"></a>volatile 的原理和实现机制</h3><p>摘自《深入理解Java虚拟机》：</p><p>“观察加入volatile关键字和没有加入volatile关键字时所生产的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”。</p><p>lock前缀指定实际上相当于一个内存屏障（也成为内存栅栏），内存屏障会提供三个功能：</p><p>1） 它确保指定重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>2） 它会强制将对缓存的修改操作立即写入主存；<br>3） 如果是写操作，它会导致其他CPU中对应的缓存行无效；</p><p>使用场景<br>1） 状态量标记<br>2） 屏障前后的一致性</p><h2 id="看这个！！"><a href="#看这个！！" class="headerlink" title="看这个！！"></a>看这个！！</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>()&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Student INSTANCE;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Student <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> INSTANCE;&#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Student <span class="hljs-title function_">instace</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE == NULL)&#123;<br>            <span class="hljs-keyword">synchronized</span>(obj)&#123;<br>                <span class="hljs-keyword">if</span>(INSTANCE == NULL)&#123;<br>                    INSTANCE = <span class="hljs-built_in">this</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自己理解其中的巧妙，哈哈哈哈</strong></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring中的@AliasFor标签</title>
    <link href="/2022/04/24/Spring%E4%B8%AD%E7%9A%84-AliasFor%E6%A0%87%E7%AD%BE/"/>
    <url>/2022/04/24/Spring%E4%B8%AD%E7%9A%84-AliasFor%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring中的-AliasFor标签"><a href="#Spring中的-AliasFor标签" class="headerlink" title="Spring中的@AliasFor标签"></a>Spring中的@AliasFor标签</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在回顾之前项目的代码，项目中有一个非常常用的注解 <strong>@Subscribe</strong></p><p>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Subscribe &#123;<br><br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String[] topics() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-meta">@AliasFor(&quot;topics&quot;)</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String <span class="hljs-title function_">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    Subscription.Feature[] features() <span class="hljs-keyword">default</span> Subscription.Feature.local;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后去找他的实现找到了这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">subscribes</span> <span class="hljs-operator">=</span> AnnotatedElementUtils.getMergedAnnotationAttributes(method, Subscribe.class);<br></code></pre></td></tr></table></figure><p>很不理解<strong>getMergedAnnotationAttributes</strong>方法。于是开始在网上找各种文章，于是找到了以下内容，让我豁然开朗。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>在这之前首先要知道什么是元注解，刚开始我也不理解元注解是什么，以为spring自带的注解叫元注解，就是因为这个错误的理解让我在看spring源代码的时候一直不理解代码的逻辑。</p><p>元注解，我现在的理解是注解上面的注解。</p><p><img src="01.png" alt="01"></p><p>我们定义的注解的上面的注解就是元注解。与之概念类似的还有元数据。比如一个word文档，他的元数据有文件名、创建日期等。这些数据是用来描述这个文件的。</p><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><p>在Spring的众多注解中，经常会发现很多注解的不同属性起着相同的作用，比如@RequestMapping的value属性和path属性，这就需要做一些基本的限制，比如value和path的值不能冲突，比如任意设置value或者设置path属性的值，都能够通过另一个属性来获取值等等。为了统一处理这些情况，Spring创建了@AliasFor标签。</p><p>spring对Annotation的派生性应用可谓炉火纯青,而属性上派生的需求则借助了<code>@AliasFor</code>，它是从spring4.2中开始支持的。</p><p><strong>使用</strong></p><p><a href="https://github.com/AliasFor">@AliasFor</a>标签有几种使用方式。</p><p>1，在同一个注解内显示使用；比如在<a href="https://github.com/RequestMapping">@RequestMapping</a>中的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Mapping</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RequestMapping &#123;<br> <br>    <span class="hljs-meta">@AliasFor(&quot;path&quot;)</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br> <br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String[] path() <span class="hljs-keyword">default</span> &#123;&#125;;<br> <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>又比如<a href="https://github.com/ContextConfiguration">@ContextConfiguration</a>注解中的value和locations属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ContextConfiguration &#123;<br>    <span class="hljs-meta">@AliasFor(&quot;locations&quot;)</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br> <br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String[] locations() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在同一个注解中成对使用即可，比如示例代码中，value和path就是互为别名。但是要注意一点，@AliasFor标签有一些使用限制，但是这应该能想到的，比如要求互为别名的属性属性值类型，默认值，都是相同的，互为别名的注解必须成对出现，比如value属性添加了@AliasFor(“path”)，那么path属性就必须添加@AliasFor(“value”)，另外还有一点，互为别名的属性必须定义默认值。</p><p>那么如果违反了别名的定义，在使用过程中就会报错，我们来做个简单测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ContextConfiguration(value = &quot;aa.xml&quot;, locations = &quot;bb.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationUtilsTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAliasfor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ContextConfiguration</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> AnnotationUtils.findAnnotation(getClass(),<br>                ContextConfiguration.class);<br>        System.out.println(<br>                StringUtils.arrayToCommaDelimitedString(cc.locations()));<br>        System.out.println(StringUtils.arrayToCommaDelimitedString(cc.value()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试，报错；value和locations互为别名，不能同时设置；</p><p>稍微调整一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnnotation</span><br><span class="hljs-meta">@ContextConfiguration(value = &quot;aa.xml&quot;, locations = &quot;aa.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationUtilsTest</span> &#123;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnnotation</span><br><span class="hljs-meta">@ContextConfiguration(value = &quot;aa.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationUtilsTest</span> &#123;<br></code></pre></td></tr></table></figure><p>运行测试，均打印出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">aa.xml<br>aa.xml<br></code></pre></td></tr></table></figure><p>2，显示的覆盖元注解中的属性；<br>先来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(classes = AopConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopUtilsTest</span> &#123;<br></code></pre></td></tr></table></figure><p>这段代码是一个非常熟悉的基于JavaConfig的Spring测试代码；假如现在我有个癖好，我觉得每次写<a href="https://github.com/ContextConfiguration">@ContextConfiguration</a>(classes = AopConfig.class)太麻烦了，我想写得简单一点，我就可以定义一个这样的标签：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@ContextConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> STC &#123;<br> <br>    <span class="hljs-meta">@AliasFor(value = &quot;classes&quot;, annotation = ContextConfiguration.class)</span><br>    Class&lt;?&gt;[] cs() <span class="hljs-keyword">default</span> &#123;&#125;;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>1，因为@ContextConfiguration注解本身被定义为@Inherited的，所以我们的STC注解即可理解为继承了@ContextConfiguration注解；<br>2，我觉得classes属性太长了，所以我创建了一个cs属性，为了让这个属性等同于@ContextConfiguration属性中的classes属性，我使用了@AliasFor标签，分别设置了value（即作为哪个属性的别名）和annotation（即作为哪个注解）；</p><p>使用我们的STC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@STC(cs = AopConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopUtilsTest</span> &#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IEmployeeService service;<br></code></pre></td></tr></table></figure><p>正常运行；<br>这就是@AliasFor标签的第二种用法，显示的为元注解中的属性起别名；这时候也有一些限制，比如属性类型，属性默认值必须相同；当然，在这种使用情况下，@AliasFor只能为作为当前注解的元注解起别名；</p><p>3，在一个注解中隐式声明别名；<br>这种使用方式和第二种使用方式比较相似，我们直接使用Spring官方文档的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ContextConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestConfig &#123;<br><br>   <span class="hljs-meta">@AliasFor(annotation = ContextConfiguration.class, attribute = &quot;locations&quot;)</span><br>   String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>   <span class="hljs-meta">@AliasFor(annotation = ContextConfiguration.class, attribute = &quot;locations&quot;)</span><br>   String[] groovyScripts() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>   <span class="hljs-meta">@AliasFor(annotation = ContextConfiguration.class, attribute = &quot;locations&quot;)</span><br>   String[] xmlFiles() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在MyTestConfig注解中，为value，groovyScripts，xmlFiles都定义了别名@AliasFor(annotation = ContextConfiguration.class, attribute = “locations”)，所以，其实在这个注解中，value、groovyScripts和xmlFiles也互为别名，这个就是所谓的在统一注解中的隐式别名方式；</p><p>4，别名的传递；<br>@AliasFor注解是允许别名之间的传递的，简单理解，如果A是B的别名，并且B是C的别名，那么A是C的别名；<br>我们看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyTestConfig</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> GroovyOrXmlTestConfig &#123;<br><br>   <span class="hljs-meta">@AliasFor(annotation = MyTestConfig.class, attribute = &quot;groovyScripts&quot;)</span><br>   String[] groovy() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>   <span class="hljs-meta">@AliasFor(annotation = ContextConfiguration.class, attribute = &quot;locations&quot;)</span><br>   String[] xml() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>1，GroovyOrXmlTestConfig把 @MyTestConfig（参考上一个案例）作为元注解；<br>2，定义了groovy属性，并作为MyTestConfig中的groovyScripts属性的别名；<br>3，定义了xml属性，并作为ContextConfiguration中的locations属性的别名；<br>4，因为MyTestConfig中的groovyScripts属性本身就是ContextConfiguration中的locations属性的别名；所以xml属性和groovy属性也互为别名；<br>这个就是别名的传递性；<br><strong>原理：</strong></p><p>明白<a href="https://github.com/AliasFor">@AliasFor</a>标签的使用方式，我们简单来看看<a href="https://github.com/AliasFor">@AliasFor</a>标签的使用原理；<br>首先来看看该标签的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AliasFor &#123;<br> <br>    <span class="hljs-meta">@AliasFor(&quot;attribute&quot;)</span><br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br> <br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String <span class="hljs-title function_">attribute</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br> <br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotation() <span class="hljs-keyword">default</span> Annotation.class;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<a href="https://github.com/AliasFor">@AliasFor</a>标签自己就使用了自己，为value属性添加了attribute属性作为别名；</p><p>那么就把这个注解放在我们需要的地方就可以了么？真就这么简单么？我们来做一个例子：<br>1，创建一个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br> <br>    <span class="hljs-meta">@AliasFor(&quot;alias&quot;)</span><br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br> <br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String <span class="hljs-title function_">alias</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>在该注解中，我们让alias和value属性互为别名；<br>2，完成测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnnotation(value = &quot;aa&quot;, alias = &quot;bb&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationUtilsTest</span> &#123;<br> <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAliasfor2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyAnnotation</span> <span class="hljs-variable">ann</span> <span class="hljs-operator">=</span> getClass().getAnnotation(MyAnnotation.class);<br>        System.out.println(ann.value());<br>        System.out.println(ann.alias());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将MyAnnotation放在AnnotationUtilsTest上，可以看到，我们故意将value和alias值设置为不一样的，然后在测试代码中分别获取value()和alias()的值，结果打印：<br>aa<br>bb</p><p>WTF？和预期的不一样？原因很简单，AliasFor是Spring定义的标签，要使用他，只能让Spring来处理，修改测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnnotation(value = &quot;aa&quot;, alias = &quot;bb&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationUtilsTest</span> &#123;<br> <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAliasfor3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyAnnotation</span> <span class="hljs-variable">ann</span> <span class="hljs-operator">=</span> AnnotationUtils.findAnnotation(getClass(),<br>                MyAnnotation.class);<br>        System.out.println(ann.value());<br>        System.out.println(ann.alias());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次我们使用Spring的AnnotationUtils工具类的findAnnotation方法来获取标签，然后再次打印value()和alias()值：</p><p>如愿报错；所以，使用@AliasFor最需要注意一点的，就是只能使用Spring的AnnotationUtils工具类来获取；</p><p>而真正在起作用的，是AnnotationUtils工具类中的<A extends Annotation> A synthesizeAnnotation(A annotation, AnnotatedElement annotatedElement)方法；<br>这个方法传入注解对象，和这个注解对象所在的类型，返回一个经过处理（这个处理就主要是用于处理@AliasFor标签）之后的注解对象，简单说，这个方法就是把A注解对象—-(经过处理)——&gt;支持AliasFor的A注解对象，我们来看看其中的关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DefaultAnnotationAttributeExtractor</span> <span class="hljs-variable">attributeExtractor</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultAnnotationAttributeExtractor</span>(annotation, annotatedElement);<br><span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynthesizedAnnotationInvocationHandler</span>(attributeExtractor);<br><span class="hljs-keyword">return</span> (A) Proxy.newProxyInstance(annotation.getClass().getClassLoader(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123;(Class&lt;A&gt;) annotationType, SynthesizedAnnotation.class&#125;, handler);<br></code></pre></td></tr></table></figure><p>可以看到，本质原理就是使用了AOP来对A注解对象做了次动态代理，而用于处理代理的对象为SynthesizedAnnotationInvocationHandler；我们来看看SynthesizedAnnotationInvocationHandler中的重要处理代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">if</span> (isEqualsMethod(method)) &#123;<br>        <span class="hljs-keyword">return</span> annotationEquals(args[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isHashCodeMethod(method)) &#123;<br>        <span class="hljs-keyword">return</span> annotationHashCode();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isToStringMethod(method)) &#123;<br>        <span class="hljs-keyword">return</span> annotationToString();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isAnnotationTypeMethod(method)) &#123;<br>        <span class="hljs-keyword">return</span> annotationType();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isAttributeMethod(method)) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;Method [%s] is unsupported for synthesized annotation type [%s]&quot;</span>, method,<br>            annotationType());<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigurationException</span>(msg);<br>    &#125;<br>    <span class="hljs-keyword">return</span> getAttributeValue(method);<br>&#125;<br></code></pre></td></tr></table></figure><p>在invoke（即拦截方法中，这个拦截方法就是在注解中获取属性值的方法，不要忘了，注解的属性实际上定义为接口的方法），其次判断，如果当前执行的方法不是equals、hashCode、toString、或者属性是另外的注解，或者不是属性方法，之外的方法（这些方法就是要处理的目标属性），都调用了getAttributeValue方法，所以我们又跟踪到getAttributeValue方法的重要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">attributeName</span> <span class="hljs-operator">=</span> attributeMethod.getName();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.valueCache.get(attributeName);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            value = <span class="hljs-built_in">this</span>.attributeExtractor.getAttributeValue(attributeMethod);<br></code></pre></td></tr></table></figure><p>这里我们重点关注的是如果没有缓存到值（这个先不用管），直接调用attributeExtractor.getAttributeValue方法获取属性值，那么，很容易猜到，如果属性有@AliasFor注解，就应该是这个方法在处理；那我们来看看这个方法又在做什么事情：</p><p>attributeExtractor是一个AnnotationAttributeExtractor类型，这个对象是在构造SynthesizedAnnotationInvocationHandler时传入的，默认是一个DefaultAnnotationAttributeExtractor对象；而DefaultAnnotationAttributeExtractor是继承AbstractAliasAwareAnnotationAttributeExtractor，看名字，真正的处理AliasFor标签的动作，应该就在这里面，于是继续看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">getAttributeValue</span><span class="hljs-params">(Method attributeMethod)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">attributeName</span> <span class="hljs-operator">=</span> attributeMethod.getName();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">attributeValue</span> <span class="hljs-operator">=</span> getRawAttributeValue(attributeMethod);<br> <br>        List&lt;String&gt; aliasNames = <span class="hljs-built_in">this</span>.attributeAliasMap.get(attributeName);<br>        <span class="hljs-keyword">if</span> (aliasNames != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">defaultValue</span> <span class="hljs-operator">=</span> AnnotationUtils.getDefaultValue(getAnnotationType(), attributeName);<br>            <span class="hljs-keyword">for</span> (String aliasName : aliasNames) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">aliasValue</span> <span class="hljs-operator">=</span> getRawAttributeValue(aliasName);<br> <br>                <span class="hljs-keyword">if</span> (!ObjectUtils.nullSafeEquals(attributeValue, aliasValue) &amp;&amp;<br>                        !ObjectUtils.nullSafeEquals(attributeValue, defaultValue) &amp;&amp;<br>                        !ObjectUtils.nullSafeEquals(aliasValue, defaultValue)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigurationException</span>(...)<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ObjectUtils.nullSafeEquals(attributeValue, defaultValue)) &#123;<br>                    attributeValue = aliasValue;<br>                &#125;<br>            &#125;<br>        &#125;<br> <br>        <span class="hljs-keyword">return</span> attributeValue;<br>    &#125;<br></code></pre></td></tr></table></figure><p>对原代码做了些改造，但是我们能清晰的看到重点：<br>1，首先正常获取当前属性的值；<br>2，List<String> aliasNames = this.attributeAliasMap.get(attributeName);得到所有的标记为别名的属性名称；<br>3，Object aliasValue = getRawAttributeValue(aliasName);遍历获取所有别名属性的值；<br>4，三个重要判断，attributeValue、aliasValue、defaultValue相同，我们前面介绍的@AliasFor标签的传递性也是在这里体现；如果不相同，直接抛出异常；否则正常返回属性值；</p><p>至此，AliasFor的执行过程分析完毕；<br><strong>小结</strong></p><p>类似<a href="https://github.com/AliasFor">@AliasFor</a>这样的注解，在Spring框架中比比皆是，而每一个这样的细节的点，都值得我们去体会。我们常常说Spring框架非常复杂，因为在每一个点的实现，都要考虑很多健壮性和扩展性的问题，这些，都是我们值得去研究的。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试之redis</title>
    <link href="/2022/04/05/java%E9%9D%A2%E8%AF%95%E4%B9%8Bredis/"/>
    <url>/2022/04/05/java%E9%9D%A2%E8%AF%95%E4%B9%8Bredis/</url>
    
    <content type="html"><![CDATA[<p>1.Redis 是一个基于内存的高性能key-value数据库。<br>2.Redis相比memcached有哪些优势：<br>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型<br>redis的速度比memcached快很多<br>redis可以持久化其数据<br>3.Redis是单线程<br>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</p><p>4.Reids常用5种数据类型<br>string，list，set，sorted set，hash<br>6.Reids6种淘汰策略：<br>noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。大多数写命令都会导致占用更多的内存(有极少数会例外。<br>**allkeys-lru:**所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。<br>**volatile-lru:**只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。<br>**allkeys-random:**所有key通用; 随机删除一部分 key。<br>volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。<br>volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。<br>7.Redis的并发竞争问题如何解决?<br>单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用setnx实现锁。</p><p>8.Redis是使用c语言开发的。<br>9.Redis前端启动命令<br>./redis-server</p><p>10.Reids支持的语言：<br>java、C、C#、C++、php、Node.js、Go等。</p><p>11.Redis 持久化方案：<br>Rdb 和 Aof</p><p>12.Redis 的主从复制<br>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，</p><p>13.Redis是单线程的，但Redis为什么这么快？<br>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用多路I/O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><p>14.为什么Redis是单线程的？<br>Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p><p>15.Redis info查看命令：info memory<br>16.Redis内存模型<br>used_memory：Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。</p><p>used_memory_rss<strong>：</strong>Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。</p><p>mem_fragmentation_ratio<strong>：</strong>内存碎片比率，该值是used_memory_rss / used_memory的比值。</p><p>mem_allocator<strong>：</strong>Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。</p><p>17.Redis内存划分<br>数据<br>作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。</p><p>进程本身运行需要的内存<br>Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。</p><p>缓冲内存<br>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。</p><p>内存碎片<br>内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。</p><p>18.Redis对象有5种类型<br>无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。</p><p>19.Redis没有直接使用C字符串<br>(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。</p><p>20.Reidis的SDS在C字符串的基础上加入了free和len字段<br>21.Reids主从复制<br>复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</p><p>22.Redis哨兵<br>在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</p><p>23.Reids持久化触发条件<br>RDB持久化的触发分为手动触发和自动触发两种。</p><p>24.Redis 开启AOF<br>Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：</p><p>appendonly yes</p><p>25.AOF常用配置总结<br>下面是AOF常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。</p><p>appendonly no：是否开启AOF<br>appendfilename “appendonly.aof”：AOF文件名<br>dir ./：RDB文件和AOF文件所在目录<br>appendfsync everysec：fsync持久化策略<br>no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡<br>auto-aof-rewrite-percentage 100：文件重写触发条件之一<br>auto-aof-rewrite-min-size 64mb：文件重写触发提交之一<br>aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件<br>26.RDB和AOF的优缺点<br>RDB持久化</p><p>优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。</p><p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p><p>AOF持久化</p><p>与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。</p><p>27.持久化策略选择<br>（1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。</p><p>（2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。</p><p>（3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。</p><p>28.redis缓存被击穿处理机制<br>使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法</p><p>29.Redis还提供的高级工具<br>像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。</p><p>30.Redis常用管理命令</p><h1 id="dbsize-返回当前数据库-key-的数量。"><a href="#dbsize-返回当前数据库-key-的数量。" class="headerlink" title="dbsize 返回当前数据库 key 的数量。"></a>dbsize 返回当前数据库 key 的数量。</h1><h1 id="info-返回当前-redis-服务器状态和一些统计信息。"><a href="#info-返回当前-redis-服务器状态和一些统计信息。" class="headerlink" title="info 返回当前 redis 服务器状态和一些统计信息。"></a>info 返回当前 redis 服务器状态和一些统计信息。</h1><h1 id="monitor-实时监听并返回redis服务器接收到的所有请求信息。"><a href="#monitor-实时监听并返回redis服务器接收到的所有请求信息。" class="headerlink" title="monitor 实时监听并返回redis服务器接收到的所有请求信息。"></a>monitor 实时监听并返回redis服务器接收到的所有请求信息。</h1><h1 id="shutdown-把数据同步保存到磁盘上，并关闭redis服务。"><a href="#shutdown-把数据同步保存到磁盘上，并关闭redis服务。" class="headerlink" title="shutdown 把数据同步保存到磁盘上，并关闭redis服务。"></a>shutdown 把数据同步保存到磁盘上，并关闭redis服务。</h1><h1 id="config-get-parameter-获取一个-redis-配置参数信息。（个别参数可能无法获取）"><a href="#config-get-parameter-获取一个-redis-配置参数信息。（个别参数可能无法获取）" class="headerlink" title="config get parameter 获取一个 redis 配置参数信息。（个别参数可能无法获取）"></a>config get parameter 获取一个 redis 配置参数信息。（个别参数可能无法获取）</h1><h1 id="config-set-parameter-value-设置一个-redis-配置参数信息。（个别参数可能无法获取）"><a href="#config-set-parameter-value-设置一个-redis-配置参数信息。（个别参数可能无法获取）" class="headerlink" title="config set parameter value 设置一个 redis 配置参数信息。（个别参数可能无法获取）"></a>config set parameter value 设置一个 redis 配置参数信息。（个别参数可能无法获取）</h1><h1 id="config-resetstat-重置-info-命令的统计信息。（重置包括：keyspace-命中数、"><a href="#config-resetstat-重置-info-命令的统计信息。（重置包括：keyspace-命中数、" class="headerlink" title="config resetstat 重置 info 命令的统计信息。（重置包括：keyspace 命中数、"></a>config resetstat 重置 info 命令的统计信息。（重置包括：keyspace 命中数、</h1><h1 id="keyspace-错误数、-处理命令数，接收连接数、过期-key-数）"><a href="#keyspace-错误数、-处理命令数，接收连接数、过期-key-数）" class="headerlink" title="keyspace 错误数、 处理命令数，接收连接数、过期 key 数）"></a>keyspace 错误数、 处理命令数，接收连接数、过期 key 数）</h1><h1 id="debug-object-key-获取一个-key-的调试信息。"><a href="#debug-object-key-获取一个-key-的调试信息。" class="headerlink" title="debug object key 获取一个 key 的调试信息。"></a>debug object key 获取一个 key 的调试信息。</h1><h1 id="debug-segfault-制造一次服务器当机。"><a href="#debug-segfault-制造一次服务器当机。" class="headerlink" title="debug segfault 制造一次服务器当机。"></a>debug segfault 制造一次服务器当机。</h1><h1 id="flushdb-删除当前数据库中所有-key-此方法不会失败。小心慎用"><a href="#flushdb-删除当前数据库中所有-key-此方法不会失败。小心慎用" class="headerlink" title="flushdb 删除当前数据库中所有 key,此方法不会失败。小心慎用"></a>flushdb 删除当前数据库中所有 key,此方法不会失败。小心慎用</h1><h1 id="flushall-删除全部数据库中所有-key，此方法不会失败。小心慎用"><a href="#flushall-删除全部数据库中所有-key，此方法不会失败。小心慎用" class="headerlink" title="flushall 删除全部数据库中所有 key，此方法不会失败。小心慎用"></a>flushall 删除全部数据库中所有 key，此方法不会失败。小心慎用</h1><p>31.Reids工具命令<br>#redis-server：Redis 服务器的 daemon 启动程序<br>#redis-cli：Redis 命令行操作工具。当然，你也可以用 telnet 根据其纯文本协议来操作<br>#redis-benchmark：Redis 性能测试工具，测试 Redis 在你的系统及你的配置下的读写性能<br>$redis-benchmark -n 100000 –c 50<br>#模拟同时由 50 个客户端发送 100000 个 SETs/GETs 查询<br>#redis-check-aof：更新日志检查<br>#redis-check-dump：本地数据库检查</p><p>32.为什么需要持久化？<br>由于Redis是一种内存型数据库，即服务器在运行时，系统为其分配了一部分内存存储数据，一旦服务器挂了，或者突然宕机了，那么数据库里面的数据将会丢失，为了使服务器即使突然关机也能保存数据，必须通过持久化的方式将数据从内存保存到磁盘中。</p><p>33.判断key是否存在<br>exists key +key名字</p><p>34.删除key<br>del key1 key2 …<br>35.缓存和数据库间数据一致性问题<br>分布式环境下（单机就不用说了）非常容易出现缓存和数据库间的数据一致性问题，针对这一点的话，只能说，如果你的项目对缓存的要求是强一致性的，那么请不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括 合适的缓存更新策略，更新数据库后要及时更新缓存、缓存失败时增加重试机制，例如MQ模式的消息队列。</p><p>36.布隆过滤器<br>bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小</p><p>37.缓存雪崩问题<br>存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。</p><p>解决方案：</p><p>1、也是像解决缓存穿透一样加锁排队。</p><p>2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</p><p>38.缓存并发问题<br>这里的并发指的是多个redis的client同时set key引起的并发问题。比较有效的解决方案就是把redis.set操作放在队列中使其串行化，必须的一个一个执行，具体的代码就不上了，当然加锁也是可以的，至于为什么不用redis中的事务，留给各位看官自己思考探究。</p><p>39.Redis分布式<br>redis支持主从的模式。原则：Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。</p><p>这是一个典型的分布式读写分离模型。我们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量</p><p>40.读写分离模型<br>通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。</p><p>41.数据分片模型<br>为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。</p><p>可以将每个节点看成都是独立的master，然后通过业务实现数据分片。</p><p>结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。</p><ol start="42"><li>redis常见性能问题和解决方案：<br>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li></ol><p>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</p><p>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</p><p>尽量避免在压力很大的主库上增加从库</p><p>43.redis通讯协议<br>RESP 是redis客户端和服务端之前使用的一种通讯协议；RESP 的特点：实现简单、快速解析、可读性好</p><p>44.Redis分布式锁实现<br>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。<strong>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</strong>set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</p><p>45.Redis做异步队列<br>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。<strong>能不能生产一次消费多次呢？</strong>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p><p>46.Redis中海量数据的正确操作方式<br>利用SCAN系列命令（SCAN、SSCAN、HSCAN、ZSCAN）完成数据迭代。</p><p>47.SCAN系列命令注意事项<br>SCAN的参数没有key，因为其迭代对象是DB内数据；<br>返回值都是数组，第一个值都是下一次迭代游标；<br>时间复杂度：每次请求都是O(1)，完成所有迭代需要O(N)，N是元素数量；<br>可用版本：version &gt;= 2.8.0；<br>48.Redis 管道 Pipeline<br>在某些场景下我们在一次操作中可能需要执行多个命令，而如果我们只是一个命令一个命令去执行则会浪费很多网络消耗时间，如果将命令一次性传输到 Redis中去再执行，则会减少很多开销时间。但是需要注意的是 pipeline中的命令并不是原子性执行的，也就是说管道中的命令到达 Redis服务器的时候可能会被其他的命令穿插</p><p>49.事务不支持回滚<br>50.手写一个 LRU 算法<br>class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {<br>    private final int CACHE_SIZE;</p><div class="code-wrapper"><pre><code class="hljs">/** * 传递进来最多能缓存多少数据 * * @param cacheSize 缓存大小 */public LRUCache(int cacheSize) &#123;    // true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。    super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);    CACHE_SIZE = cacheSize;&#125;@Overrideprotected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;    // 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。    return size() &gt; CACHE_SIZE;&#125;</code></pre></div><p>}</p><p>51.多节点 Redis 分布式锁：Redlock 算法<br>获取当前时间（start）。</p><p>依次向 N 个 Redis节点请求锁。请求锁的方式与从单节点 Redis获取锁的方式一致。为了保证在某个 Redis节点不可用时该算法能够继续运行，获取锁的操作都需要设置超时时间，需要保证该超时时间远小于锁的有效时间。这样才能保证客户端在向某个 Redis节点获取锁失败之后，可以立刻尝试下一个节点。</p><p>计算获取锁的过程总共消耗多长时间（consumeTime = end - start）。如果客户端从大多数 Redis节点（&gt;= N/2 + 1) 成功获取锁，并且获取锁总时长没有超过锁的有效时间，这种情况下，客户端会认为获取锁成功，否则，获取锁失败。</p><p>如果最终获取锁成功，锁的有效时间应该重新设置为锁最初的有效时间减去 consumeTime。</p><p>如果最终获取锁失败，客户端应该立刻向所有 Redis节点发起释放锁的请求。</p><p>52.Redis 中设置过期时间主要通过以下四种方式<br>expire key seconds：设置 key 在 n 秒后过期；<br>pexpire key milliseconds：设置 key 在 n 毫秒后过期；<br>expireat key timestamp：设置 key 在某个时间戳（精确到秒）之后过期；<br>pexpireat key millisecondsTimestamp：设置 key 在某个时间戳（精确到毫秒）之后过期；<br>53.Reids三种不同删除策略<br>定时删除：在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作</p><p>惰性删除：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键</p><p>定期删除：每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><p>54.定时删除<br><strong>优点：</strong>对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放国期间所占用的内存<br><strong>缺点：</strong>对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，影响服务器的响应时间和吞吐量<br>55.定期删除<br>由于定时删除会占用太多cpu时间，影响服务器的响应时间和吞吐量以及惰性删除浪费太多内存，有内存泄露的危险，所以出现一种整合和折中这两种策略的定期删除策略。</p><p>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。<br>定时删除策略有效地减少了因为过期键带来的内存浪费。<br>56.惰性删除<br><strong>优点：</strong>对cpu时间友好，在每次从键空间获取键时进行过期键检查并是否删除，删除目标也仅限当前处理的键，这个策略不会在其他无关的删除任务上花费任何cpu时间。<br><strong>缺点：</strong>对内存不友好，过期键过期也可能不会被删除，导致所占的内存也不会释放。甚至可能会出现内存泄露的现象，当存在很多过期键，而这些过期键又没有被访问到，这会可能导致它们会一直保存在内存中，造成内存泄露。<br>57.Reids 管理工具：Redis Manager 2.0<br>github地址</p><p>58.Redis常见的几种缓存策略<br>Cache-Aside<br>Read-Through<br>Write-Through<br>Write-Behind<br>59.Redis Module 实现布隆过滤器<br>Redis module 是Redis 4.0 以后支持的新的特性，这里很多国外牛逼的大学和机构提供了很多牛逼的Module 只要编译引入到Redis 中就能轻松的实现我们某些需求的功能。在Redis 官方Module 中有一些我们常见的一些模块，我们在这里就做一个简单的使用。</p><p>neural-redis 主要是神经网络的机器学，集成到redis 可以做一些机器训练感兴趣的可以尝试<br>RedisSearch 主要支持一些富文本的的搜索<br>RedisBloom 支持分布式环境下的Bloom 过滤器<br>60.Redis 到底是怎么实现“附近的人”<br>使用方式<br>GEOADD key longitude latitude member [longitude latitude member …]<br>将给定的位置对象（纬度、经度、名字）添加到指定的key。其中，key为集合名称，member为该经纬度所对应的对象。在实际运用中，当所需存储的对象数量过多时，可通过设置多key(如一个省一个key)的方式对对象集合变相做sharding，避免单集合数量过多。</p><p>成功插入后的返回值：</p><p>(integer) N<br>其中N为成功插入的个数。</p>]]></content>
    
    
    <categories>
      
      <category>java面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试之Mysql</title>
    <link href="/2022/04/05/java%E9%9D%A2%E8%AF%95%E4%B9%8BMysql/"/>
    <url>/2022/04/05/java%E9%9D%A2%E8%AF%95%E4%B9%8BMysql/</url>
    
    <content type="html"><![CDATA[<p>一、存储引擎<br>MySQL常见的两种存储引擎：MyISAM与InnoDB<br><strong>MySql最左匹配原则</strong>：索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。</p><p><strong>MySQL 关于联合索引的字段顺序规则</strong></p><p>比如商品有三个分类A，B，C，类似「界门纲目科属种」那样，越左类别越大。还有一个是商品来源D，不一定会用于查询条件中。</p><p>举个例子，A代表衣服，B代表衣服下的长袖，C代表衣服下的红色的长袖。</p><p>如果这三个字段是商品的三个属性，并且要建立索引的话，必然是A,B,C的顺序，并且中间不应该有比如D字段(商品来源)</p><p>因为假设你的索引是这样建立的D,A,B,C，那么当你的查询条件中没有D字段的话，那么这个索引将不会被使用到。</p><p>假设2：索引是这样建立的A,B,D,C，当查询语句为：</p><p>select * from goods where A=’衣服’ and B=’长袖’ and C=’红色’;</p><p>虽然会使用到这个索引，但是这个索引只用到了A,B，因为D字段不作为查询条件，所以C字段也没有使用到。</p><p>这就是  最左匹配原则  的一种。</p><p>再多的，可以再去了解一下数据库索引的数据结构，以及其他最左匹配原则，这里列一下。</p><p>假设有这样一个索引——(a,b,c)，针对下面的5个关于最左原则的解释，做出举例。</p><p>1.必须用到索引的第一个字段，如select * from table where b=’b’ and c=’c’，不会使用到索引。</p><p>2.对于索引的第一个字段，用like时左边必须是固定值，通配符只能出现在右边，如select * from table where a like ‘%a%’不会使用到索引，而select * from table where a like ‘a%’则会使用到索引。</p><p>3.如果在字段前加了函数或在字段前嵌入了表达式，则不会使用索引。如select * from table where trim(a)&gt;1不会使用索引，select * from table where a+1&gt;1也不会使用索引，而select * from table where a&gt;2会使用到索引。</p><p>4.MySQL遵循最左前缀原理，当查询条件匹配联合索引的前面几列时，可以使用联合索引；否则，不会使用联合索引。如果where字句中的列全都包含在索引列中，那么where字句中的字段顺序和索引顺序无关，但如果是部分包括的话就要看是否满足最左前缀匹配原则了。</p><p>5.使用到索引第一个字段的不等于表达式，即使其他字段不是索引字段也会使用到索引。如select * from table where a!=’a’ and ddd=’ddd’会使用到索引。</p><p><strong>为什么MySQL InnoDB 存储引擎 要用B+树做索引，而不用B树</strong><br>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。而因为B+树的内部节点只是作为索引使用，而不像B树那样每个节点都需要存储硬盘指针。也就是说：B+树中每个非叶节点没有指向某个关键字具体信息的指针，所以每一个节点可以存放更多的关键字数量，即一次性读入内存所需要查找的关键字也就越多，减少了I/O操作。</p><p>二、字符集及校对规则<br>字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。Mysql中每一种字符集都会对应一系列的校对规则。</p><p>Mysql采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） </p><p>三、索引<br>Mysql索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p><p>Mysql的BTree索引使用的是B数中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p><p>  MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p><p>  InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p><p>四、缓存<br>my.cnf加入以下配置，重启Mysql开启查询缓存</p><p>query_cache_type=1<br>query_cache_size=600000<br>Mysql执行以下命令也可以开启查询缓存</p><p>set global  query_cache_type=1;<br>set global  query_cache_size=600000;<br>如上，开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、Mysql库中的系统表，其查询结果也不会被缓存。</p><p>缓存建立之后，Mysql的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p><p>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：</p><p>select sql_no_cache count(*) from usr;<br>五、事务<br>关系性数据库需要遵循ACID规则，具体内容如下： </p><p>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p><p>一致性： 执行事务前后，数据保持一致；</p><p>隔离性： 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；</p><p>持久性: 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库 发生故障也不应该对其有任何影响。</p><p>为了达到上述事务特性，数据库定义了几种不同的事务隔离级别：</p><p>READ_UNCOMMITTED（未授权读取）: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p><p>READ_COMMITTED（授权读取）: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p><p>REPEATABLE_READ（可重复读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p>SERIALIZABLE（串行）: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p><p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>六、锁<br>MyISAM和InnoDB存储引擎使用的锁：</p><p>MyISAM采用表级锁(table-level locking)。</p><p>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</p><p>表级锁和行级锁对比：</p><p>表级锁： Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p><p>行级锁： Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p><p>InnoDB存储引擎的锁的算法有三种：</p><p>Record lock：单个行记录上的锁</p><p>Gap lock：间隙锁，锁定一个范围，不包括记录本身</p><p>Next-key lock：record+gap 锁定一个范围，包含记录本身</p><p>七、大表优化<br>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><p>限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</p><p>读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</p><p>缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</p><p>垂直分区：</p><p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。<br>垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p><div class="code-wrapper"><pre><code class="hljs">   5. 水平分区：</code></pre></div><p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。<br>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL 并发能力没有什么意义，所以 水品拆分最好分库 。</p><p>水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join 性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 I/O。</p><p>下面补充一下数据库分片的两种常见方案：</p><p>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</p><p>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat、360的Atlas、网易的DDB等等都是这种架构的实现。</p>]]></content>
    
    
    <categories>
      
      <category>java面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试之网络</title>
    <link href="/2022/04/04/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/04/04/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Java面试之网络"><a href="#Java面试之网络" class="headerlink" title="Java面试之网络"></a>Java面试之网络</h1><h2 id="什么是三次握手，四次挥手"><a href="#什么是三次握手，四次挥手" class="headerlink" title="什么是三次握手，四次挥手"></a>什么是三次握手，四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次挥手是建立连接，是为了确保客户端和服务端的发送接收能力都OK </p><p>我： 喂 ，你好，能听到我说话吗？</p><p>领导： 可以的。</p><p>我：好的。</p><p>然后开始巴拉巴拉说事情。</p><p>这就是三次握手，确保了双方都可以发送和接收。</p><ol><li>第一次握手：客户端发送一个网络包，服务端接收到网络包。说明客户端的发送能力和服务端的接收能力是OK的</li><li>第二次握手：服务端发送一个网络包给客户端，客户端完成接收。这时候客户端完成了一次发报文，并且得到的服务端的响应，那么能说明客户端这边没问题。但是呢客户端只接收了客户端的一次请求包智能说明自己接收能力OK，虽然也发送了一次网络包给客户端，但是这时候客户端还没给我回应所以这时候并不能保证服务端的发送能力是OK的，所以还要再来一次握手。</li><li>第三次握手：客户端收到服务端发来的网络包并给服务端一个回应。这时候服务端接收到消息后才能确定自己第二次挥手的时候发送过去的数据包有被接收到这时候他才能确定自己说我的发送能里很OK!</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>为什么需要握手三次就可以，挥手需要四次呢。因为握手没有数据传输，只是建立连接。而建立连接后就需要进行数据传输了，为了保证数据传输的完整性，则需要四次挥手。</p><p>第一次挥手： 客户端发送一个FIN报文说我要断开连接了。</p><p>第二次挥手：服务器收到以后可能数据还没有传输完，这时候会回复一个ACK确认报文。但是数据还没有传输完所以还需要等待数据传输结束。</p><p>第三次挥手： 服务器数据传输完发送一个FIN报文给客户端。告诉客户端已经传输完了。</p><p>第四次挥手：当客户端收到服务器发送的FIN报文后会发送一个ACK确认报文。当等待2MSL后关闭连接。</p><p>等待2MSL是确保服务端收到了客户端的ACK，如果服务端没有收到ACK的话，会继续发送FIN报文。</p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p><p>两者的区别大致如下：</p><ul><li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li><li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li><li>tcp 面向字节流，udp 面向报文；</li><li>tcp 数据传输慢，udp 数据传输快；</li></ul><h2 id="http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="http 响应码 301 和 302 代表的是什么？有什么区别？"></a>http 响应码 301 和 302 代表的是什么？有什么区别？</h2><p>301：永久重定向。</p><p>302：暂时重定向。</p><p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p><h2 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h2><p>forward 是转发 和 redirect 是重定向：</p><ul><li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li><li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li><li>效率：forward 比 redirect 效率高。</li></ul><h2 id="说一下-tcp-粘包是怎么产生的？"><a href="#说一下-tcp-粘包是怎么产生的？" class="headerlink" title="说一下 tcp 粘包是怎么产生的？"></a>说一下 tcp 粘包是怎么产生的？</h2><h3 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h3><p>TCP是面向字节流的协议，就是没有界限的一串数据，本没有“包”的概念，“粘包”和“拆包”一说是为了有助于形象地理解这两种现象。</p><p>因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。</p><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p><ul><li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li><li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li></ul><h3 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h3><p>对于粘包和拆包问题，常见的解决方案有四种：</p><ul><li>发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；</li><li>发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；</li><li>将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</li><li>通过自定义协议进行粘包和拆包的处理。</li></ul><h3 id="Netty对粘包和拆包问题的处理"><a href="#Netty对粘包和拆包问题的处理" class="headerlink" title="Netty对粘包和拆包问题的处理"></a>Netty对粘包和拆包问题的处理</h3><p>Netty对解决粘包和拆包的方案做了抽象，提供了一些解码器（Decoder）来解决粘包和拆包的问题。如：</p><ul><li>LineBasedFrameDecoder：以行为单位进行数据包的解码；</li><li>DelimiterBasedFrameDecoder：以特殊的符号作为分隔来进行数据包的解码；</li><li>FixedLengthFrameDecoder：以固定长度进行数据包的解码；</li><li>LenghtFieldBasedFrameDecode：适用于消息头包含消息长度的协议（最常用）；</li></ul><p>基于Netty进行网络读写的程序，可以直接使用这些Decoder来完成数据包的解码。对于高并发、大流量的系统来说，每个数据包都不应该传输多余的数据（所以补齐的方式不可取），LenghtFieldBasedFrameDecode更适合这样的场景。</p><h2 id="OSI-的七层模型都有哪些？"><a href="#OSI-的七层模型都有哪些？" class="headerlink" title="OSI 的七层模型都有哪些？"></a>OSI 的七层模型都有哪些？</h2><ul><li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li><li>数据链路层：负责建立和管理节点间的链路。</li><li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li><li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li><li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li><li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li><li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li></ul><h2 id="get-和-post-请求有哪些区别？"><a href="#get-和-post-请求有哪些区别？" class="headerlink" title="get 和 post 请求有哪些区别？"></a>get 和 post 请求有哪些区别？</h2><ul><li>get 请求会被浏览器主动缓存，而 post 不会。</li><li>get 传递参数有大小限制，而 post 没有。</li><li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li></ul><h2 id="如何实现跨域请求？"><a href="#如何实现跨域请求？" class="headerlink" title="如何实现跨域请求？"></a>如何实现跨域请求？</h2><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>一个URL由三部分组成：URL   协议     端口号。这三个只要有一个不同那么就属于是跨域。</p><h3 id="跨域的产生原因"><a href="#跨域的产生原因" class="headerlink" title="跨域的产生原因"></a>跨域的产生原因</h3><p>浏览器的同源策略限制。</p><p>同源策略（Same Orgin Policy）是一种约定，它是浏览器核心也最基本的安全功能，它会阻止一个域的js脚本和另外一个域的内容进行交互，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。<br>所谓同源（即在同一个域）就是两个页面具有相同的协议（protocol）、主机（host）和端口号（port）。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>vue是如何解决的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue.config.js</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-comment">//配置跨域</span><br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://x.x.x.x:x/&#x27;</span>, <span class="hljs-comment">//这里填写项目真实的后台接口地址</span><br>        <span class="hljs-attr">changOrigin</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//设置允许跨域</span><br>        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-comment">//这个重写不可省略！因为我们真正请求的地址并不含 /api</span><br>          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>            <span class="hljs-comment">/* 当我们在浏览器中看到请求的地址为：http://localhost:8080/api/data/getdata 时</span><br><span class="hljs-comment">            因为重写了 /api ，所以实际上访问的地址是：http://x.x.x.x:x/data/getdata，</span><br><span class="hljs-comment">            */</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在vue项目中配置proxy解决跨域问题的原理是：将域名发送给本地的服务器（启动vue项目的服务，localhost:8080），再由本地的服务器去请求真正的服务器。</p><p><strong>nginx反向代理解决跨域（前端常用）</strong></p><ul><li><p>正向代理：</p><p>a–&gt;b访问不了，可以找个中间的服务器c, 先访问c再从c到b,类似曲线救国。<br>明确访问的目的地，但是用户不知道中间的代理服务器。（忽略中间服务器）</p></li><li><p>反向代理</p><p>a明确访问c代理服务器，但是不知道c的内容从哪里来，c反向从别的地方拿来数据。(忽略的是目标地址)</p><p>浏览器可以访问a,而服务器之间不存在跨域问题，浏览器先访问a的服务器c，让c服务器作为代理去访问b服务器,拿到之后再返回数据给a。</p></li><li><div class="code-wrapper"><pre><code class="xml">nginx是静态服务器，跨域请求放在api下面好管理http://www.baidu.com:80/api/user可以在nginx下面的config下面的nginx.conf里面配置从80端口进来的就拦截一下，代理到81端口server&#123;        location /api &#123;                //拦截一下                proxy_pass  http://www.baidu.com:81;    &#125;&#125;</code></pre></div></li></ul><p><strong>CORS解决跨域</strong> <strong>(<code>第三方模块</code>)</strong></p><p>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>浏览器端：</p><p>目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。</p><p>服务端：</p><p>CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。</p><p><strong>优势：</strong></p><p>在服务端进行控制是否允许跨域，可自定义规则<br>支持各种请求方式</p><p><strong>缺点：</strong></p><p>会产生额外的请求</p><p><strong>jsonp</strong></p><p>利用了 script 不受同源策略的限制</p><p>缺点：只能 get 方式，易受到 XSS攻击</p><p><em><strong>·</strong>CORS（Cross-Origin Resource Sharing）,跨域资源共享</em></p><p>当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头 origin；</p><p>后端在接受到请求后确定响应后会在后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin；</p><p>浏览器判断响应中的 Access-Control-Allow-Origin 值是否和当前的地址相同，匹配成功后才继续响应处理，否则报错</p><p>缺点：忽略 cookie，浏览器版本有一定要求</p><p><em><strong>·</strong>代理跨域请求</em></p><p>前端向发送请求，经过代理，请求需要的服务器资源</p><p>缺点：需要额外的代理服务器</p><p><em><strong>·</strong>Html5 postMessage 方法</em></p><p>允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本、多窗口、跨域消息传递</p><p>缺点：浏览器版本要求，部分浏览器要配置放开跨域限制</p><p><em><strong>·</strong>修改 document.domain 跨子域</em></p><p>相同主域名下的不同子域名资源，设置 document.domain 为 相同的一级域名</p><p>缺点：同一一级域名；相同协议；相同端口</p><p><em><strong>·</strong>基于 Html5 websocket 协议</em></p><p>websocket 是 Html5 一种新的协议，基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求</p><p>缺点：浏览器一定版本要求，服务器需要支持 websocket 协议</p><p><em><strong>·</strong><a href="https://link.zhihu.com/?target=http://document.xxx">http://document.xxx</a> + iframe</em></p><p>通过 iframe 是浏览器非同源标签，加载内容中转，传到当前页面的属性中</p><p>缺点：页面的属性值有大小限制</p><h2 id="说一下-JSONP-实现原理？"><a href="#说一下-JSONP-实现原理？" class="headerlink" title="说一下 JSONP 实现原理？"></a>说一下 JSONP 实现原理？</h2><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p>]]></content>
    
    
    <categories>
      
      <category>java面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试之集合</title>
    <link href="/2022/04/04/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <url>/2022/04/04/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Java面试之集合"><a href="#Java面试之集合" class="headerlink" title="Java面试之集合"></a>Java面试之集合</h1><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><p>用于存储数据的容器。</p><p>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。<br>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。</p><h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><ul><li>对象封装数据，对象多了也需要存储。集合用于存储对象。</li><li>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</li></ul><h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul><li>数组是固定长度的；集合可变长度的。</li><li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li></ul><h2 id="List，Set，Map三者的区别？List、Set、Map-是否继承自-Collection-接口？List、Map、Set-三个接口存取元素时，各有什么特点？"><a href="#List，Set，Map三者的区别？List、Set、Map-是否继承自-Collection-接口？List、Map、Set-三个接口存取元素时，各有什么特点？" class="headerlink" title="List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？"></a>List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</h2><p><img src="01.png" alt="01"></p><p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p><p>Collection集合主要有List和Set两大接口：</p><p>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。<br>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p><p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p><p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p><h2 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>Arraylist： Object数组<br>Vector： Object数组<br>LinkedList： 双向循环链表</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素<br>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。<br>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间<br>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h2 id="集合安全性问题"><a href="#集合安全性问题" class="headerlink" title="集合安全性问题"></a>集合安全性问题</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerNotSafeDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt; = <span class="hljs-number">30</span>; i++)&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>                <span class="hljs-comment">// 底层add方法没有加synchronized</span><br>                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>));<br>                System.out.println(list);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 故障现象 java.util.ConCurrentModificationException</span><br></code></pre></td></tr></table></figure><h4 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h4><ol><li><p>故障现象 </p><p>java.util.ConCurrentModificationException</p></li><li><p>导致原因</p><p>并发争抢修改导致，参考我们的花名册签名情况。一个正在写入，另一个同学过来争抢，导致数据不一致异常。并发修改异常。</p></li><li><p>解决方案</p><ul><li>使用Vector，牺牲并发换取线程安全</li></ul><p>​       <img src="02.png" alt="02"></p><ul><li><p>使用Collections.synahronizedList(new ArrayList&lt;&gt;());</p></li><li><p>使用CopyOnWriteArrayList();</p><p>CopyOnWriteArrayList是ArrayList的线程安全版本，在有写操作的时候会copy一份数据，然后写完再设置成新的数据，这样的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，适用于读多写少的并发场景。它底层使用了ReentranLock来支持并发操作，ReentrantLock是一种支持重入的独占锁，任意时刻只允许一个线程获得锁，所以可以安全的的并发去写数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>       lock.lock(); <span class="hljs-comment">//上锁，只允许一个线程进入</span><br>       <span class="hljs-keyword">try</span> &#123;<br>           Object[] elements = getArray(); <span class="hljs-comment">// 获得当前数组对象</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<span class="hljs-comment">// 得到数组的长度</span><br>           Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<span class="hljs-comment">//拷贝到一个新的数组中</span><br>           newElements[len] = e;<span class="hljs-comment">//插入数据元素</span><br>           setArray(newElements);<span class="hljs-comment">//将新的数组对象设置回去</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock();<span class="hljs-comment">//释放锁</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet底层是HashMap,HashMap是key value键值对，HashSet只有一个键，他的值默认是一个<font>PRESENT常量</font></p><p><strong>解决方案</strong>:   同样会犯跟ArrayList同样的错误，解决方案也是一样的。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>使用ConcurrentHashMap&lt;K,V&gt;</p><h2 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h2><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list. add(<span class="hljs-string">&quot;x&quot;</span>);<br>Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);<br>clist. add(<span class="hljs-string">&quot;y&quot;</span>); <span class="hljs-comment">// 运行时此行报错</span><br>System. out. println(list. size());<br></code></pre></td></tr></table></figure><h2 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h2><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h3 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h3><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;Integer&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>   *<span class="hljs-comment">// do something*</span><br>   it.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一种最常见的</strong>错误<strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Integer i : list)&#123;<br>   list.remove(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p><h4 id="遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？"><a href="#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？" class="headerlink" title="遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</h4><p><strong>遍历方式有以下几种：</strong></p><ul><li><p>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</p></li><li><p>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</p></li><li><p>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</p></li></ul><p><strong>最佳实践：</strong>Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p><p>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。<br>如果没有实现该接口，表示不支持 Random Access，如LinkedList。<br><strong>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</strong></p><h2 id="说一下-ArrayList-的优缺点"><a href="#说一下-ArrayList-的优缺点" class="headerlink" title="说一下 ArrayList 的优缺点"></a>说一下 ArrayList 的优缺点</h2><p><strong>ArrayList的优点如下：</strong></p><p>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。<br>ArrayList 在顺序添加一个元素的时候非常方便。<br><strong>ArrayList 的缺点如下</strong>：</p><p>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。<br>插入元素的时候，也需要做一次元素复制操作，缺点同上。<br>ArrayList 比较适合顺序添加、随机访问的场景。</p><h2 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h2><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h2 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h2><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。<br>HashSet 中的add ()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><p>以下是HashSet 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><br><span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>hashCode（）与equals（）的相关规定：</p><p>如果两个对象相等，则hashcode一定也是相同的<br>两个对象相等,对两个equals方法返回true<br>两个对象有相同的hashcode值，它们也不一定是相等的<br>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖<br>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p><h2 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h2><table><thead><tr><th><strong>HashMap</strong></th><th align="center"><strong>HashSet</strong></th></tr></thead><tbody><tr><td>实现了Map接口</td><td align="center">实现Set接口</td></tr><tr><td>存储键值对</td><td align="center">仅存储对象</td></tr><tr><td>调用put（）向map中添加元素</td><td align="center">调用add（）方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td align="center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td align="center">HashSet较HashMap来说比较慢</td></tr></tbody></table><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><h3 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h3><h4 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h4><p> HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><p> 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p><strong>HashMap 基于 Hash 算法实现的:</strong></p><ul><li>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li><li>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</li><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li><li>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比</li><li>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</li></ul><h3 id="1-8-1-7的区别"><a href="#1-8-1-7的区别" class="headerlink" title="1.8  1.7的区别"></a>1.8  1.7的区别</h3><table><thead><tr><th><strong>不同</strong></th><th><strong>JDK 1.7</strong></th><th>JDK 1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组 + 链表</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>初始化方式</td><td>单独函数：<code>inflateTable()</code></td><td>直接集成到了扩容函数<code>resize()</code>中</td></tr><tr><td>hash值计算方式</td><td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td><td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td></tr><tr><td>存放数据的规则</td><td>无冲突时，存放数组；冲突时，存放链表</td><td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr><tr><td>插入数据方式</td><td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td><td>尾插法（直接插入到链表尾部/红黑树</td></tr><tr><td>扩容后存储位置的计算方式</td><td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td><td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td></tr></tbody></table><h3 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h3><p>当我们put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标index = (table.length - 1) &amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><h3 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p><p>②.每次扩展的时候，都是扩展2倍；</p><p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p><h3 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h3><p>答：在解决这个问题之前，我们首先需要知道什么是哈希冲突，而在了解哈希冲突之前我们还要知道什么是哈希才行；</p><h4 id="什么是哈希？"><a href="#什么是哈希？" class="headerlink" title="什么是哈希？"></a>什么是哈希？</h4><p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有散列函数都有如下一个基本特性<strong>：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p><h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p><h4 id="HashMap的数据结构-1"><a href="#HashMap的数据结构-1" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做链地址法的方式可以解决哈希冲突：<br><img src="03.png" alt="03"></p><p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化</p><h4 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash()函数"></a>hash()函数</h4><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<span class="hljs-comment">// 与自己右移16位进行异或运算（高低位异或）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p><h4 id="JDK1-8新增红黑树"><a href="#JDK1-8新增红黑树" class="headerlink" title="JDK1.8新增红黑树"></a>JDK1.8新增红黑树</h4><p><img src="04.png" alt="04"></p><p>通过上面的链地址法（使用散列表）和扰动函数我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p><p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong><br><strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong><br><strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong></p><h3 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h3><p>答：重写hashCode()和equals()方法</p><p>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；<br>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；</p>]]></content>
    
    
    <categories>
      
      <category>java面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试之RabbitMQ</title>
    <link href="/2022/04/03/java%E9%9D%A2%E8%AF%95%E4%B9%8BRabbitMQ/"/>
    <url>/2022/04/03/java%E9%9D%A2%E8%AF%95%E4%B9%8BRabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="Java面试之RabbitMQ"><a href="#Java面试之RabbitMQ" class="headerlink" title="Java面试之RabbitMQ"></a>Java面试之RabbitMQ</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p>MQ（Message Queue）消息队列，是基础数据结构中“先进先出”的一种数据机构。指把要传输的数据（消息）放在队列中，用队列机制来实现软件之间的通信——(生产者产生消息并把消息放入队列，然后由消费者去处理)。消费者可以到指定队列拉取消息，或者订阅相应的队列，由MQ服务端给其推送消息。</p><h2 id="什么是列队"><a href="#什么是列队" class="headerlink" title="什么是列队"></a>什么是列队</h2><ul><li>列队是以先进先出方式的存储结构</li><li>实际生活中，队列的应用随处可见，比如排队买 XXX、医院的挂号系统等，采用的都是队列的结构。</li></ul><h2 id="为什么使用MQ"><a href="#为什么使用MQ" class="headerlink" title="为什么使用MQ"></a>为什么使用MQ</h2><ul><li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量</li><li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li><li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li><li>日志处理 - 解决大量日志传输。</li><li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li></ul><h2 id="MQ的优点"><a href="#MQ的优点" class="headerlink" title="MQ的优点"></a>MQ的优点</h2><p><strong>主要是：解耦、异步、削峰。</strong></p><p><strong>解耦：</strong>A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p><strong>就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。</strong></p><p><strong>异步：</strong>A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。</p><p><strong>削峰：</strong>减少高峰时期对服务器压力。主要是还是来自于互联网的业务场景，例如，马上即将开始的春节火车票抢购，大量的用户需要同一时间去抢购；以及大家熟知的阿里双11秒杀，这个时候在同一时间点请求来的太猛烈，服务器受不住。削峰，等于是减缓服务器压力，可以以漏斗，或者水管的方式来进行消费，想一想水管和漏斗的机制大家就明白了</p><h2 id="消息队列有什么优缺点？RabbitMQ有什么优缺点？"><a href="#消息队列有什么优缺点？RabbitMQ有什么优缺点？" class="headerlink" title="消息队列有什么优缺点？RabbitMQ有什么优缺点？"></a><a href="https://so.csdn.net/so/search?q=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">消息队列</a>有什么优缺点？RabbitMQ有什么优缺点？</h2><ul><li>优点上面已经说了，就是<strong>在特殊场景下有其对应的好处</strong>，<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</li><li>缺点有以下几个：<ol><li><strong>系统可用性降低</strong><br>本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低；</li><li><strong>系统复杂度提高</strong><br>加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。</li><li><strong>一致性问题</strong><br>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</li></ol></li></ul><p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p><h2 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、<a href="https://so.csdn.net/so/search?q=RabbitMQ&spm=1001.2101.3001.7020">RabbitMQ</a>、RocketMQ 有什么优缺点？</h2><p><img src="01.png" alt="01"></p><p><strong>综上，各种对比之后，有如下建议：</strong></p><ol><li>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</li><li>后来大家开始用 RabbitMQ，但是确实 <a href="https://so.csdn.net/so/search?q=erlang&spm=1001.2101.3001.7020">erlang</a> 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li><li>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li><li>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li></ol><h2 id="MQ-有哪些常见问题？如何解决这些问题？"><a href="#MQ-有哪些常见问题？如何解决这些问题？" class="headerlink" title="MQ 有哪些常见问题？如何解决这些问题？"></a>MQ 有哪些常见问题？如何解决这些问题？</h2><ul><li>消息的顺序问题</li><li>消息的重复问题</li></ul><h3 id="消息的顺序问题"><a href="#消息的顺序问题" class="headerlink" title="消息的顺序问题"></a>消息的顺序问题</h3><ul><li><p>消息有序指的是可以按照消息的发送顺序来消费。</p></li><li><p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p><p><img src="02.png" alt="02"></p><p><strong>解决方案：</strong>保证生产者 - MQServer - 消费者是一对一对一的关系</p><p><img src="03.png" alt="03"></p><p><strong>缺陷:</strong></p><ul><li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li><li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解来规避。</li><li>不关注乱序的应用实际大量存在</li><li>队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</li></ul></li></ul><h3 id="消息的重复问题"><a href="#消息的重复问题" class="headerlink" title="消息的重复问题"></a>消息的重复问题</h3><ul><li>造成消息重复的根本原因是：网络不可达。</li><li>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</li><li>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</li></ul><h2 id="什么是RabbitMQ？"><a href="#什么是RabbitMQ？" class="headerlink" title="什么是RabbitMQ？"></a>什么是RabbitMQ？</h2><ul><li>RabbitMQ是一款开源的，Erlang编写的，消息中间件；<br>最大的特点就是消费并不需要确保提供方存在,实现了服务之间的高度解耦<br>可以用它来：解耦、异步、削峰。</li></ul><h2 id="rabbitmq-的使用场景"><a href="#rabbitmq-的使用场景" class="headerlink" title="rabbitmq 的使用场景"></a>rabbitmq 的使用场景</h2><p>（1）服务间异步通信</p><p>（2）顺序消费</p><p>（3）定时任务</p><p>（4）请求削峰</p><h2 id="RabbitMQ基本概念"><a href="#RabbitMQ基本概念" class="headerlink" title="RabbitMQ基本概念"></a>RabbitMQ基本概念</h2><ul><li>Broker： 简单来说就是消息队列服务器实体</li><li>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列</li><li>Queue： 消息队列载体，每个消息都会被投入到一个或多个队列</li><li>Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来</li><li>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递</li><li>VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。</li><li>Producer： 消息生产者，就是投递消息的程序</li><li>Consumer： 消息消费者，就是接受消息的程序</li><li>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</li></ul><p><strong>由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。</strong></p><h2 id="RabbitMQ的工作模式"><a href="#RabbitMQ的工作模式" class="headerlink" title="RabbitMQ的工作模式"></a>RabbitMQ的工作模式</h2><h4 id="simple模式（即最简单的收发模式）"><a href="#simple模式（即最简单的收发模式）" class="headerlink" title="simple模式（即最简单的收发模式）"></a>simple模式（即最简单的收发模式）</h4><p><img src="04.png" alt="04"></p><ol><li>消息产生消息，将消息放入队列</li><li>消息的消费者(consumer) 监听 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失，这里可以设置成手动的ack,但如果设置成手动ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出)。</li></ol><h4 id="work工作模式-资源的竞争"><a href="#work工作模式-资源的竞争" class="headerlink" title="work工作模式(资源的竞争)"></a>work工作模式(资源的竞争)</h4><p><img src="05.png" alt="05"></p><p>消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2同时监听同一个队列,消息被消费。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。</p><h4 id="publish-subscribe发布订阅-共享资源"><a href="#publish-subscribe发布订阅-共享资源" class="headerlink" title="publish/subscribe发布订阅(共享资源)"></a>publish/subscribe发布订阅(共享资源)</h4><p><img src="06.png" alt="06"></p><h4 id="routing路由模式"><a href="#routing路由模式" class="headerlink" title="routing路由模式"></a>routing路由模式</h4><p><img src="07.png" alt="07"></p><ol><li>消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息;</li><li>根据业务功能定义路由字符串</li><li>从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。</li><li>业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误;</li></ol><h4 id="topic-主题模式-路由模式的一种"><a href="#topic-主题模式-路由模式的一种" class="headerlink" title="topic 主题模式(路由模式的一种)"></a>topic 主题模式(路由模式的一种)</h4><p><img src="08.png" alt="08"></p><ol><li>星号井号代表通配符</li><li>星号代表多个单词,井号代表一个单词</li><li>路由功能添加模糊匹配</li><li>消息产生者产生消息,把消息交给交换机</li><li>交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费</li></ol><p><strong>（在我的理解看来就是routing查询的一种模糊匹配，就类似sql的模糊查询方式）</strong></p><h2 id="如何保证RabbitMQ消息的顺序性？"><a href="#如何保证RabbitMQ消息的顺序性？" class="headerlink" title="如何保证RabbitMQ消息的顺序性？"></a>如何保证RabbitMQ消息的顺序性？</h2><ol><li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；</li><li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</li></ol><h2 id="如何解决消息丢失的问题"><a href="#如何解决消息丢失的问题" class="headerlink" title="如何解决消息丢失的问题"></a>如何解决消息丢失的问题</h2><h3 id="为什么消息会丢失？"><a href="#为什么消息会丢失？" class="headerlink" title="为什么消息会丢失？"></a>为什么消息会丢失？</h3><p>跟消息重复问题类似，消息丢失也可能出现在生产者、MQ、消费者三者中。这三者导致消息丢失的原因是什么呢？</p><ul><li>生产者：生产者推送消息到 MQ 中，由于网络抖动等原因消息没有推送到 MQ 中，或者消息推送到 MQ 中了但是 MQ 内部出错了，导致消息丢失。</li><li>MQ：MQ 接收到消息后先把消息暂存在 OS Cache 中，消费者还没消费的时候 MQ 自己挂了，导致消息丢失。</li><li>消费者：消费者消费到了这条消息，但是还没来得及处理，消费者自己挂了，但是消费者已经告诉了 MQ 自己已经消费完了，导致消息丢失。</li></ul><h3 id="如何解决消息丢失的问题-1"><a href="#如何解决消息丢失的问题-1" class="headerlink" title="如何解决消息丢失的问题"></a>如何解决消息丢失的问题</h3><p>不同的消息队列解决消息丢失的方法是不同的，下面分别介绍不同 MQ 是如何解决消息丢失问题的。</p><h4 id="生产者导致消息丢失"><a href="#生产者导致消息丢失" class="headerlink" title="生产者导致消息丢失"></a>生产者导致消息丢失</h4><p>RabbitMQ 有两种方案可以避免消息丢失，一种是 RabbitMQ 的事务机制，一种是 Confirm 模式。这里先看一下事务机制。</p><p>RabbitMQ 客户端中 Channel 接口有这么几个函数，channel.txSelect 用来开启一个事务，channel.txCommit 用来提交事务，channel.txRollback 用来回滚事务。为了避免消息丢失，我们可以在发送消息前，先开启执行 txSelect 方法开启一个事务，接着发送消息，如果消息投递失败，执行 txRollback 回滚事务，再执行重试操作重新发送，如果消息投递成功，执行 txCommit 方法提交事务。</p><p>这个方案可以保证我们的消息一定是投递成功的，但是几乎没有人使用这种方案。因为这个方案是同步阻塞的，也就是一条消息发送后，一定要等到 MQ 回应之后执行了提交或回滚事务操作，才能继续往下执行。大致过程如下图所示：</p><p><img src="21.png" alt="21"></p><p>RabbitMQ 还提供了另一种方法避免生产者消息丢失问题，那就是 Confirm 模式。Confirm 模式是这样子的，生产者发送消息后，不需要等待 MQ 的回应，MQ 接收成功后，会回调生产者的 ack 接口通知生产者消息投递成功了，如果 MQ 接收失败，会回调 nack 接口通知生产者消息投递失败了，生产者可以重新对这条消息进行投递。大致过程如下图所示：</p><p><img src="22.png" alt="22"></p><h4 id="RabbitMQ-导致消息丢失"><a href="#RabbitMQ-导致消息丢失" class="headerlink" title="RabbitMQ 导致消息丢失"></a>RabbitMQ 导致消息丢失</h4><p>RabbitMQ 自己弄丢了数据是由于持久化导致的。通常 RabbitMQ 接收到消息之后写入 OS Cache 中，就会给生产者返回接收成功的回应，这时如果 RabbitMQ 挂了，消息也就丢失了。解决方法可以结合生产者的 Confirm 模式，配置 RabbitMQ 持久化到磁盘之后，才给生产者返回 ack 信号。</p><h4 id="消费者导致消息丢失"><a href="#消费者导致消息丢失" class="headerlink" title="消费者导致消息丢失"></a>消费者导致消息丢失</h4><p>RabbitMQ 在消费者端弄丢数据，是由于 RabbitMQ 的默认自动提交 ack 导致的。解决方法就是关闭 RabbitMQ 的自动响应 ack 即可。这样消息没有处理完成，消费者挂了，RabbitMQ 会认为消息没有处理成功，会再次推送消息给消费者处理。</p><p><img src="23.png" alt="23"></p><h2 id="消息如何分发？"><a href="#消息如何分发？" class="headerlink" title="消息如何分发？"></a>消息如何分发？</h2><p>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能</p><h2 id="消息怎么路由？"><a href="#消息怎么路由？" class="headerlink" title="消息怎么路由？"></a>消息怎么路由？</h2><p>消息提供方-&gt;路由-&gt;一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；</p><p><strong>常用的交换器主要分为一下三种：</strong></p><ol><li>fanout：如果交换器收到消息，将会广播到所有绑定的队列上</li><li>direct：如果路由键完全匹配，消息就被投递到相应的队列</li><li>topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符</li></ol><h2 id="消息基于什么传输？"><a href="#消息基于什么传输？" class="headerlink" title="消息基于什么传输？"></a>消息基于什么传输？</h2><p>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。</p><h2 id="如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？</h2><ul><li>先说为什么会重复消费：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除；</li><li>但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。</li><li>针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性；<ul><li>比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过；</li><li>假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性</li></ul></li></ul><h2 id="如何确保消息正确地发送至-RabbitMQ？-如何确保消息接收方消费了消息？"><a href="#如何确保消息正确地发送至-RabbitMQ？-如何确保消息接收方消费了消息？" class="headerlink" title="如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？"></a>如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？</h2><h4 id="发送方确认模式"><a href="#发送方确认模式" class="headerlink" title="发送方确认模式"></a>发送方确认模式</h4><ul><li>将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。</li><li>一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。</li><li>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。</li><li>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</li></ul><h4 id="接收方确认机制"><a href="#接收方确认机制" class="headerlink" title="接收方确认机制"></a>接收方确认机制</h4><ul><li>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除.</li><li>这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性；</li></ul><h4 id="下面罗列几种特殊情况"><a href="#下面罗列几种特殊情况" class="headerlink" title="下面罗列几种特殊情况"></a>下面罗列几种特殊情况</h4><ul><li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）</li><li>如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。</li></ul><h2 id="如何保证RabbitMQ消息的可靠传输？"><a href="#如何保证RabbitMQ消息的可靠传输？" class="headerlink" title="如何保证RabbitMQ消息的可靠传输？"></a>如何保证RabbitMQ消息的可靠传输？</h2><ul><li>消息不可靠的情况可能是消息丢失，劫持等原因；</li><li>丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息</li></ul><h3 id="生产者丢失消息"><a href="#生产者丢失消息" class="headerlink" title="生产者丢失消息"></a>生产者丢失消息</h3><p>从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息；</p><p>transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；</p><p>confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；</p><p>rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；</p><p>如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p><h3 id="消息队列丢数据"><a href="#消息队列丢数据" class="headerlink" title="消息队列丢数据"></a>消息队列丢数据</h3><p>消息持久化。</p><p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。</p><p>这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。</p><p>这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p><p>那么如何持久化呢？</p><p>这里顺便说一下吧，其实也很容易，就下面两步</p><ol><li><p>将queue的持久化标识durable设置为true,则代表是一个持久的队列</p></li><li><p>发送消息的时候将deliveryMode=2</p><p>这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据</p></li></ol><h3 id="消费者丢失消息"><a href="#消费者丢失消息" class="headerlink" title="消费者丢失消息"></a>消费者丢失消息</h3><p>消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！</p><p>消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息；</p><p>如果这时处理消息失败，就会丢失该消息；</p><p><strong>解决方案：处理消息成功后，手动回复确认消息。</strong></p><h2 id="为什么不应该对所有的-message-都使用持久化机制？"><a href="#为什么不应该对所有的-message-都使用持久化机制？" class="headerlink" title="为什么不应该对所有的 message 都使用持久化机制？"></a>为什么不应该对所有的 message 都使用持久化机制？</h2><ul><li><p>首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有 10 倍的差距。</p></li><li><p>其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。</p></li><li><p>所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条/秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。</p></li></ul><h2 id="如何保证高可用的？RabbitMQ-的集群"><a href="#如何保证高可用的？RabbitMQ-的集群" class="headerlink" title="如何保证高可用的？RabbitMQ 的集群"></a>如何保证高可用的？RabbitMQ 的集群</h2><ul><li>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</li></ul><h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><p>就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式</p><h3 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h3><ul><li>意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。</li><li>你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作</li></ul><h3 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h3><ol><li>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</li><li>这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</li></ol><h2 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</h2><ul><li><p>消息积压处理办法：临时紧急扩容：</p></li><li><p>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。<br>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。<br>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。<br>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。<br>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。<br>MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p></li><li><p>mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p></li></ul><h2 id="设计MQ思路"><a href="#设计MQ思路" class="headerlink" title="设计MQ思路"></a>设计MQ思路</h2><ul><li><p>比如说这个消息队列系统，我们从以下几个角度来考虑一下：</p></li><li><p>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</p></li><li><p>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</p></li><li><p>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</p></li><li><p>能不能支持数据 0 丢失啊？可以呀，有点复杂的。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>java面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射机制</title>
    <link href="/2022/04/03/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/04/03/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><h2 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h2><p>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。 这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p><p><img src="01.png" alt="01"></p><h2 id="哪里用过反射"><a href="#哪里用过反射" class="headerlink" title="哪里用过反射"></a>哪里用过反射</h2><ol><li>jdbc就是典型的反射</li></ol><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加载MySQL的驱动类</span><br>Class.forName(<span class="hljs-string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>); <br></code></pre></td></tr></table></figure><ol start="2"><li><p>spring的IOC </p><p>spring的IOC特性，维护了一个beans.xml 里面配置了每个类的class全路径，就是通过反射机制构造的</p></li><li><p>hibernate，struts等框架使用反射实现的。</p></li></ol><h2 id="反射的实现方式"><a href="#反射的实现方式" class="headerlink" title="反射的实现方式"></a>反射的实现方式</h2><p>第一步：获取Class对象，有4中方法：</p><ol><li>Class.forName(“类的路径”)；</li><li>类名.class</li><li>对象名.getClass()</li><li>基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象</li></ol><h2 id="实现Java反射的类"><a href="#实现Java反射的类" class="headerlink" title="实现Java反射的类"></a>实现Java反射的类</h2><ol><li><p>Class：表示正在运行的Java应用程序中的类和接口</p><p>注意： 所有获取对象的信息都需要Class类来实现。</p></li><li><p>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</p></li><li><p>Constructor：提供关于类的单个构造方法的信息以及它的访问权限</p></li><li><p>Method：提供类或接口中某个方法的信息</p></li></ol><h2 id="反射机制的优缺点"><a href="#反射机制的优缺点" class="headerlink" title="反射机制的优缺点"></a>反射机制的优缺点</h2><p><strong>优点：</strong></p><ol><li>能够运行时动态获取类的实例，提高灵活性；</li></ol><p><strong>缺点：</strong></p><ol><li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</li><li>相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</li></ol><p><strong>解决方案：</strong></p><ol><li>通过setAccessible(true)关闭JDK的安全检查来提升反射速度；</li><li>多次创建一个类的实例时，有缓存会快很多</li><li>ReflflectASM工具类，通过字节码生成的方式加快反射速度</li></ol><h2 id="反射使用步骤"><a href="#反射使用步骤" class="headerlink" title="反射使用步骤"></a>反射使用步骤</h2><p><strong>获取Class对象，调用对象方法</strong></p><ol><li>获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。</li><li>调用 Class 类中的方法，既就是反射的使用阶段。</li><li>使用反射 API 来操作这些信息。</li></ol><h2 id="获取class对象的几种方法"><a href="#获取class对象的几种方法" class="headerlink" title="获取class对象的几种方法"></a>获取class对象的几种方法</h2><ol><li><p>通过一个对象调用getClass方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> p.getClacc();<br></code></pre></td></tr></table></figure></li><li><p>通过调用某个类的class属性来获取该类对应的Class对象</p></li><li><p>使用Class类的静态方法forName()方法(最安全性能最好)，当我们获得了我们想要的类的Class对象后，可以通过Class类中的方法获取并查看该类中的方法和属性。</p><ul><li>获取方法：getDeclaredMethods()</li><li>获取字段：getDeclaredFileds()</li><li>获取构造方法：getDeclaredConstructors();</li></ul></li></ol><h2 id="利用反射动态创建对象实例"><a href="#利用反射动态创建对象实例" class="headerlink" title="利用反射动态创建对象实例"></a>利用反射动态创建对象实例</h2><ol><li><p>使用Class对象的newInstance()方法来创建该class对象对应类的实例，但是这种方式会要求该class对象对应的类有默认的空构造器。</p></li><li><p>先使用class对象获取指定的constructor对象，在调用constructor的newInstance方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Constructor</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> class.getDeclaredConstructor(String.class,Integer.class);<br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> c.newInstance(<span class="hljs-string">&quot;zahngsan&quot;</span>,<span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure></li></ol><h2 id="反射相关的API"><a href="#反射相关的API" class="headerlink" title="反射相关的API"></a>反射相关的API</h2><p><img src="02.png" alt="02"></p><p><strong>一个类在内存中只有一个class对象，一个类在被加载后，类得整个结构都会被封装在Class对象中。</strong></p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p><img src="03.png" alt="03"></p><h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><p><img src="04.png" alt="04"></p><h3 id="获取class类的实例"><a href="#获取class类的实例" class="headerlink" title="获取class类的实例"></a>获取class类的实例</h3><p><img src="05.png" alt="05"></p><h2 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h2><p><img src="06.png" alt="06"></p><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><strong>当程序主动使用某个类时，如果该类还未加载到内存，则系统会通过如下三个步骤对该类进行初始化。</strong></p><p><img src="07.png" alt="07"></p><p><img src="08.png" alt="08"></p><h2 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h2><p><img src="09.png" alt="09"></p><h2 id="什么时候会发生类的初始化"><a href="#什么时候会发生类的初始化" class="headerlink" title="什么时候会发生类的初始化"></a>什么时候会发生类的初始化</h2><p><img src="10.png" alt="10"></p><h2 id="通过反设调用方法"><a href="#通过反设调用方法" class="headerlink" title="通过反设调用方法"></a>通过反设调用方法</h2><p><img src="11.png" alt="11"></p><h2 id="通过反射操作属性"><a href="#通过反射操作属性" class="headerlink" title="通过反射操作属性"></a>通过反射操作属性</h2><p><img src="12.png" alt="12"></p><h2 id="SetAccessible"><a href="#SetAccessible" class="headerlink" title="SetAccessible"></a>SetAccessible</h2><p><img src="13.png" alt="13"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试之IO流</title>
    <link href="/2022/04/01/java%E9%9D%A2%E8%AF%95%E4%B9%8BIO%E6%B5%81/"/>
    <url>/2022/04/01/java%E9%9D%A2%E8%AF%95%E4%B9%8BIO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="什么是IO流"><a href="#什么是IO流" class="headerlink" title="什么是IO流"></a>什么是IO流</h2><p>流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式进行输入输出，数据被当成无结构的字节序列或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C/5797370">操作</a>。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入输出。</p><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><ol><li><p>根据流向可以分为输入流和输出流</p><p><strong>输入流和输出流是相对程序而言的</strong>，从外部文件读取到程序中是输入流，从程序中将数据先写入到外部文件是输出流</p><p><img src="01.png" alt="01"></p></li><li><p>根据传输数据单位分为字节流和字符流</p><ul><li>字节流：InputStream  OutputStream</li><li>字符流：Reader Writer</li></ul></li><li><p>根据功能分为节点流和包装流</p><ul><li><p>节点流：可以从（向）一个特定的地方（结点）读写数据，直接连接数据源。如常见的是文件的FileReader,还可以是数组、管道、字符串、关键字分别为ByteArray/CharArray,Piped,String。</p></li><li><p>处理流（包装流）：并不直接连接数据源，是对一个已存在的流的连接和封装，是一种典型的装饰器模式，使用处理流主要是为了方便的处理输入输出工作，如PrintStream,输出功能很强大，又如BufferedReader提供缓存机制，推荐输出时使用处理包装流。</p><p>一个流对象经过其他流的多次包装，称为流的连接。</p></li></ul></li><li><p>一些特别的流</p><ul><li>转换流： 转换流只有字节流转换为字符流。因为字符流使用起来比较方便，我们只会向更方便的方向转换    </li></ul><p><strong>注意：一个IO流既可以是输入流又可以是字节流又或是其他形式的流，这是互不影响的。比如FileInputStream它既是输入流又是字节流还是文件节点流。</strong></p></li></ol><h2 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h2><p>java流在处理上分为字符流和字节流。实际上字节流的InputStream和OutputStream是一切的基础。实际总线中流动的只有字节流。需要对字节流做特殊解码才能得到字符流。Java中负责从字节流向字符流解码的桥梁是：InputStreamReader和InputStreamWriter。</p><p>大多数情况下，字节是数据最小的基本单位，1 byte = 8 bit，而 1 char = 2 byte = 16 bit。</p><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。</p><p><strong>Java中的流是对字节序列的抽象，我们可以想象有一个水管，只不过现在流动在水管中的不再是水，而是字节序列。和水流一样，Java中的流也具有一个“流动的方向”，通常可以从中读入一个字节序列的对象被称为输入流；能够向其写入一个字节序列的对象被称为输出流。</strong></p><p><strong>输入流是相对程序而言的，外部传入数据给程序需要借助输入流，而程序把数据传输到外部需要借助输出流</strong>。</p><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>Java中的字节流处理的最基本单位为单个字节，它通常用来处理二进制数据。Java中最基本的两个字节流类是InputStream和OutputStream，它们分别代表了最基本的输入字节流和输出字节流。InputStream是所有字节输入流的祖先，而OutputStream是所有字节输出流的祖先，它们都是抽象类。</p><p>字节流在默认情况下是不支持缓存的，字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，这意味着每调用一次read方法都会请求操作系统来读取一个字节，这往往会伴随着一次磁盘IO，因此效率会比较低。要使用内存缓冲区以提高读取的效率，我们应该使用BufferedInputStream。</p><p>需注意，使用BufferedOutputStream输出数据时如果没有关闭流，数据也是不会输出到文件当中的，即并不是所有字节流都不用到缓冲区，输入缓冲字节流BufferedInputStream和输出缓冲字节流BufferedOutputStream还是要用到缓冲区的。</p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>Java中的字符流处理的最基本的单元是Unicode码元（大小2字节），它通常用来处理文本数据，例如字符、字符数组或字符串。Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。存储在磁盘上的数据通常有着各种各样的编码方式，不同的编码方式最终输出的字节内容是不同的，所以，字节流的读取和写入都要设置相应的编码方式。</p><p><strong>由于字符流在输出前实际上是要完成Unicode码元序列到相应编码方式的字节序列的转换，所以它会使用内存缓冲区来存放转换后得到的字节序列，等待都转换完毕再一同写入磁盘文件中。</strong></p><p><strong>所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。</strong></p><h3 id="字节流和字符流的区别-1"><a href="#字节流和字符流的区别-1" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h3><p>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元</p><p>字节流默认不使用缓冲区；字符流使用缓冲区。（因为要把字符流转换为字节流暂时存储在缓冲区待转换完成时在写或读）</p><p>字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出；</p><p>字符流在操作的时候是使用到缓冲区的。如果字符流不调用close或flush方法，则不会输出任何内容。（调用close方法会自动flush）</p><p>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据(因为磁盘上都是以字节存储的)，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</p><p>字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以。    </p><h3 id="字节流和字符流的转换"><a href="#字节流和字符流的转换" class="headerlink" title="字节流和字符流的转换"></a>字节流和字符流的转换</h3><p>字节流是最基本的，所有的InputStream和OutputStream的子类都是，主要用在处理二进制数据，它是按字节来处理的，但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的encode来处理，也就是要进行字符集的转化，这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联。在从字节流转化为字符流时，实际上就是byte[]转化为String时，而在字符流转化为字节流时，实际上是String转化为byte[]时。</p><p>字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组。所以字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点。所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。</p><p>字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以。</p><p>字节流与字符流主要的区别是他们的的处理方式。</p>]]></content>
    
    
    <categories>
      
      <category>java面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试之并发</title>
    <link href="/2022/03/30/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/"/>
    <url>/2022/03/30/java%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在写这篇博客的时候，我是准备跳槽了，跳槽的原因也很简单，我做的岗位没有达到的预期，可以说做的东西跟Java都不搭边，，，，，</p><p>在这之前很多东西都已经学过了，但是一直没有用到，所以随着时间的推移也就慢慢的遗忘了。我认为工作的意义除了早日帮老板实现财富自由，还有的就是让我们自己学的东西能够得到巩固吧。</p><p>跳不跳槽呢，我认为主要看下面几点：</p><ol><li>工资有没有达到你的预期</li><li>你做的东西对你下一次找工作有没有帮助</li><li>有没有一个可以说服自己不跳槽的理由</li></ol><p>就说这些吧。。。</p><h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><ol><li>一个进程包括多个进程</li><li>线程是处理机调度的最小单位</li><li>每条线程并行执行不同的任务</li><li>不同的进程使用不同的内存空间</li><li>所有的线程共享一片相同的内存空间（进程主内存），但是呢，每个线程也都拥有自己单独的栈内存来存储本地数据。（JMM内存模型）</li></ol><h2 id="实现多线程的方式有哪些"><a href="#实现多线程的方式有哪些" class="headerlink" title="实现多线程的方式有哪些"></a>实现多线程的方式有哪些</h2><ol><li>继承Thread类：Java单继承，不推荐</li><li>实现Runnable接口：Thread也是继承了thread接口，推荐</li><li>实现callable接口：实现callable接口，配合future task使用，有返回值</li><li>使用线程池：复用，节约资源</li></ol><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池的工作主要是控制运行的线程的数量，<font>处理过程中将任务放入队列</font>，然后在线程创建后启动这些任务，<font>如果线程数量超过了最大数量超出数量的线程排队等候</font>,等其他线程执行完毕，再从队列中取出任务来执行。</p><p><span alt="shake">特点：</span>线程复用，控制最大并发数，管理线程</p><p><font>Executors.newFixedThreadPool(int):</font> 执行长期的任务，性能好很好</p><p><font>Executors.newSingleThreadExecutor():</font> 一个任务一个任务执行的场景</p><p><font>Executors.newCachedThreadPool():</font> 执行很多短期异步的小程序或者负载较轻的服务</p><h3 id="线程池里的7大参数"><a href="#线程池里的7大参数" class="headerlink" title="线程池里的7大参数"></a>线程池里的7大参数</h3><ol><li><strong>corePoolSize:</strong> 线程池中的常驻核心线程数</li><li><strong>maximumPoolSize:</strong> 线程池能容纳的同时执行的最大线程数，此值必须大于等于1</li><li><strong>keepAliveTime:</strong> 多余的空闲线程的存活时间。当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的线程会被销毁只剩下corePoolSize个线程为止。</li><li><strong>unit:</strong> keepAliveTime的单位</li><li><strong>workQueue:</strong> 任务对列，被提交但是尚未被执行的任务。</li><li><strong>threadFactory:</strong> 表示生成线程池中工作线程的线程工厂，用于创建线程<font>一般默认的即可</font></li><li><strong>handler:</strong> 拒绝策略，表示当线程池满了并且工作线程数大于等于线程池的最大线程数</li></ol><h3 id="线程池不允许使用Executor去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源消耗殆尽"><a href="#线程池不允许使用Executor去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源消耗殆尽" class="headerlink" title="线程池不允许使用Executor去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源消耗殆尽"></a><strong>线程池不允许使用Executor去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源消耗殆尽</strong></h3><p><span alt="shake">说明：</span>Excutors返回的线程池对象的弊端如下：</p><ol><li><p>允许请求队列长度为Integer.MAX_VALUE，可能会堆积大量的线程，从而导致 OOM。</p></li><li><p><font>CachedThreadPool:</font></p><p>允许的创建线程池数量为Integer.MAX_VALUE，可能会导致创建大量的线程，从而导致 OOM.</p></li></ol><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><ol><li><p><strong>是什么</strong></p><p>等待队列满了，再也塞不下新任务了，同时线程池的max也达到了，无法持续为新任务服务，这时我们需要拒绝策略机制合理的处理这个问题</p></li><li><p><strong>JDK内置的拒绝策略</strong></p><p><strong>AbortPolicy:</strong>  默认的策略，直接抛出RejectedException异常组织系统运行</p><p><strong>CallerRunPolicy:</strong> “调用者运行”一种调节机制 ，该策略既不会抛弃任务也不会抛出异常，而是将某些任务回退到调用者，从而境地新任务的流量</p></li><li><p><strong>DiscardOldestPolicy</strong>: 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交</p></li><li><p><strong>DiscardPolicy:</strong>  直接丢弃任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的策略。</p></li></ol><p>以上策略均实现了RejectExecutionHandler接口</p><h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><ol><li><p><strong>CPU密集型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查看CPU核心数</span><br>System.out.println(Runtime.getRuntime().availableProcessors());<br></code></pre></td></tr></table></figure><p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）。</p><p>而在单核CPU上无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU的总运算能力有限。</p><p><font>CPU密集型任务配置应该尽可能少的线程数量</font></p><p><strong>一般公式：</strong><font>CPU核心数 + 1 个线程的线程池</font></p></li><li><p><strong>IO密集型</strong></p><p>由于IO密集型任务线程并不是一直执行任务，则应该配置尽可能多的线程，如<font>CPU核心数 * 2</font></p><p>IO密集型，即该任务需要大量的IO ，即大量的阻塞。在单线程上运行IO密集的任务会导致浪费大量的CPU运算能力浪费在等待。</p><p>所以在IO密集型任务中使用多线程可以大大的加速程序运行，即在单核的CPU上，这种加速主要是利用了被浪费掉的阻塞时间。</p><p>IO密集型时，大部分线程都阻塞，故需要多配置线程数：</p><p><strong>参考公式：</strong> <font>CPU核数 / 1 - 阻塞系数</font></p><p><strong>阻塞系数在0.8 ~ 0.9 之间</strong></p><p>比如8核CPU: 8 / 1 - 0.9 = 80个线程</p></li></ol><h2 id="使用runnable还是thread"><a href="#使用runnable还是thread" class="headerlink" title="使用runnable还是thread"></a>使用runnable还是thread</h2><ol><li>thread和runnable最大的区别是thread是类，runnable是接口。而Java是不支持多继承的，不过可以实现多个接口，所以至于你用哪个要看你的需求。</li><li>runnable相当于一个作业，而thread才是真正的处理线程，我们需要做的只是去定义这个作业，然后将作业交给线程去处理，这样就达到了松耦合的效果。同时也符合面向对象里的组合使用，也节省了函数的开销。继承thread，不仅有了作业的run方法，还有了thread的其他方法。</li><li>当需要创建大量的线程的时候，有以下不足：<ul><li>线程生命周期的开销比较高</li><li>资源消耗问题</li><li>稳定性问题</li></ul></li><li>如果二者可以选择不用那就不用，因为使用这样的裸线程比较容易出现问题，我们还需要去关注线程的数量问题。我们可以使用线程池。executor来使用线程。池化技术可以实现复用，降低了资源的消耗。</li></ol><h2 id="thread类中的run方法和start方法有什么区别"><a href="#thread类中的run方法和start方法有什么区别" class="headerlink" title="thread类中的run方法和start方法有什么区别"></a>thread类中的run方法和start方法有什么区别</h2><ol><li><p>start用来启动新创建的线程，而start内部调用了run方法，JDK1.8这样写到“</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Causes <span class="hljs-built_in">this</span> thread to begin execution; the Java Virtual Machine calls the &lt;code&gt;run&lt;/code&gt; method of <span class="hljs-built_in">this</span> thread.<br></code></pre></td></tr></table></figure><p>翻译：导致线程开始执行，Java虚拟机调用此线程的run方法。<font>这和直接调用run方法不一样，当你调用run方法的时候只会是在原来的线程中调用，没有新的线程启动，start才会启动新的线程。</font>JDK1.8源码注释中这样写到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">The result is that two threads are running concurrently: the current <span class="hljs-title function_">thread</span> <span class="hljs-params">(which returns from the call to the &lt;code&gt;start&lt;/code&gt; method)</span> and the other <span class="hljs-title function_">thread</span> <span class="hljs-params">(which executes its &lt;code&gt;run&lt;/code&gt; method)</span>.<br></code></pre></td></tr></table></figure><p>new 一个thread，线程就进入了新建状态，调用start方法会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行了。start会执行线程的相应的准备工作，然后自动执行run方法的内容，这是真正的多线程工作。而执行run方法，会把run方法当作一个mian线程下的普通方法去执行，并不会在某个线程下执行它，所以这并不是真正的多线程工作。</p></li><li><p> start：用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。</p></li><li><p>run： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。<font>并且run()方法必须是public访问权限，返回值类型为void。</font></p></li></ol><p><strong>总结：</strong> 调用start方法可以启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行的。</p><h2 id="实现并启动线程的两种方法"><a href="#实现并启动线程的两种方法" class="headerlink" title="实现并启动线程的两种方法"></a>实现并启动线程的两种方法</h2><ul><li>写一个类继承Thread，重写run()方法，然后通过start()方法启动线程</li><li>实现Runnable接口，实现run()方法，然后用new Thread(Runnable target).start()</li></ul><h2 id="谈谈你对volatile的理解"><a href="#谈谈你对volatile的理解" class="headerlink" title="谈谈你对volatile的理解"></a>谈谈你对volatile的理解</h2><p>volatile是Java虚拟机提供的<font>轻量级的同步机制</font>,</p><ol><li>volatile关键字首先具有<font>易变性</font>，声明为volatile变量编译器会强制要求读内存，相关语句不会直接使用上一条语句对应的寄存器内容，而是重新从内存中读取。</li><li>具有<font>不可优化性</font>，volatile告诉编译器，不要对这个变量进行任何激进的优化，甚至将变量直接消除，保证代码中的指令一定会被执行。</li><li>具有<font>顺序性</font>，能够保证volatile变量间的顺序性，编译器不会进行乱序优化，不过要注意与非volatile变量之间的操作，还是可能被编译器重排序</li></ol><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul><h3 id="JMM你谈谈"><a href="#JMM你谈谈" class="headerlink" title="JMM你谈谈"></a>JMM你谈谈</h3><p>JMM (JAVA Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，他描述的是一组规则或者规范，通过规范定制了程序中的各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="工作内存，主存的理解"><a href="#工作内存，主存的理解" class="headerlink" title="工作内存，主存的理解"></a>工作内存，主存的理解</h4><p>由于JVM运行程序的实体是线程，而每个线程创建时都会为其创建一个工作内存，工作内存是每个线程的私有数据空间，<font style="background-color:gray">而JMM中规</font>定所有的变量都存贮在主内存，主内存是共享区域内存，所有的线程都可以访问，<font>但线程对变量的操作必须在工作内存中进行，首先将变量从主内存拷贝到工作内存，然后对变量进行操作，</font><font>操作完后再将变量写回主内存，不能直接操作主内存中的变量</font>各个线程中的工作内存存储着主线程中的变量的副本拷贝，因此不同的线程无法访问对方的工作内存，通讯必须通过主存来完成。</p><p><img src="03.png" alt="03"></p><h4 id="可见性原理"><a href="#可见性原理" class="headerlink" title="可见性原理"></a>可见性原理</h4><p><strong>当修改volatile变量时，会给cpu发送一个信号告诉其他cpu这个变量已修改，当其他cpu调用这个变量时，就会先检查是否有收到修改该变量的信号，有则重新从内存中读取。volatile是无锁的，类似于乐观锁的机制。</strong>（多核CPU）</p><p> 在说这个问题之前，我们先看看CPU是如何执行java代码的。首先编译之后Java代码会被编译成<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>.class文件，在运行时会被加载到JVM中，JVM会将.class转换为具体的CPU执行指令，CPU加载这些指令逐条执行。如下图，</p><p><img src="04.png" alt="04"></p><p><img src="05.png" alt="05"></p><p> 以多核CPU为例（两核），我们知道CPU的速度比内存要快得多，为了弥补这个性能差异，CPU内核都会有自己的高速缓存区，当内核运行的线程执行一段代码时，首先将这段代码的指令集进行缓存行填充到高速缓存，如果非volatil变量当CPU执行修改了此变量之后，会将修改后的值回写到高速缓存，然后再刷新到内存中。如果在刷新会内存之前，由于是共享变量，那么CORE2中的线程执行的代码也用到了这个变量，这是变量的值依然是旧的。volatile关键字就会解决这个问题的，如何解决呢，首先被volatile关键字修饰的共享变量在转换成汇编语言时，会加上一个以lock为前缀的指令，当CPU发现这个指令时，立即做两件事：</p><p>将当前内核高速缓存行的数据立刻回写到内存；</p><p>使在其他内核里缓存了该内存地址的数据无效。</p><div class="code-wrapper"><pre><code class="hljs">    第一步很好理解，第二步如何做到呢？使用MESI协议。    MESI协议在早期的CPU中，是通过在总线加LOCK#锁的方式实现的，但这种方式开销太大，所以Intel开发了缓存一致性协议，也就是MESI协议，该解决缓存一致性的大致思路是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，那么他会发出信号通知其他CPU将该变量的缓存行设置为无效状态。当其他CPU使用这个变量时，首先会去嗅探是否有对该变量更改的信号，当发现这个变量的缓存行已经无效时，会从新从内存中读取这个变量。    以上这些就是volatile关键字的内部实现机制，使用Volatile有什么好处呢？从底层实现原理我们可以发现，volatile是一种非锁机制，这种机制可以避免锁机制引起的线程上下文切换和调度问题。因此，volatile的执行成本比synchronized更低。    MESI（缓存一致性协议）是一种保持一致性的协议。它的方法是在CPU缓存中保存一个标记位，这个标记位有四种状态：</code></pre></div><p>M：Modify，修改缓存，当前CPU的缓存已经被修改了，即与内存中数据已经不一致了</p><p>E：Exclusive，独占缓存，当前CPU的缓存和内存中数据保持一致，而且其他处理器并没有可使用的缓存数据</p><p>S：Share，共享缓存，和内存保持一致的一份拷贝，多组缓存可以同时拥有针对同一内存地址的共享缓存段</p><p>I：Invalid，实效缓存，这个说明CPU中的缓存已经不能使用了</p><div class="code-wrapper"><pre><code class="hljs">    CPU的读取遵循下面几点：</code></pre></div><p>如果缓存状态是I，那么就从内存中读取，否则就从缓存中直接读取。</p><p>如果缓存处于M或E的CPU读取到其他CPU有读操作，就把自己的缓存写入到内存中，并将自己的状态设置为S。</p><p>只有缓存状态是M或E的时候，CPU才可以修改缓存中的数据，修改后，缓存状态变为M。</p><h3 id="JMM关于同步的规定"><a href="#JMM关于同步的规定" class="headerlink" title="JMM关于同步的规定"></a>JMM关于同步的规定</h3><ol><li>线程解锁前，必须把共享变量的值刷新回主存</li><li>线程加锁前，必须读取主存的最新值到自己的工作内存</li><li>加锁解锁是同一把锁</li></ol><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>使用Atomic原子类</p><h4 id="有序性指令重排"><a href="#有序性指令重排" class="headerlink" title="有序性指令重排"></a>有序性指令重排</h4><p>计算机在执行程序的时候，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下三种：</p><p><font>源代码</font> —-&gt; <font>编译器优化的重排</font>——&gt;<font>指令并行的重排</font>——-&gt;<font>内存系统的重排</font>——-&gt;<font>最终执行的指令</font></p><p> <strong>说明：</strong></p><p>单线程环境里面为确保程序的最终结果和代码顺序执行的结果一致，处理器在进行重排序的时候要考虑指令间的<font>数据依赖性</font></p><p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mySort</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>    x = x + <span class="hljs-number">5</span>;<br>    y = x * x;<br>&#125;<br><span class="hljs-comment">// 语句四可以重排到第一条吗？</span><br>   不行，因为数据依赖性，y 依赖 x<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReSortSeqDemo</span>&#123;<br>    <span class="hljs-type">int</span>  <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method01</span><span class="hljs-params">()</span>&#123;<br>        a = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 语句1</span><br>        flag = <span class="hljs-literal">true</span>； <span class="hljs-comment">// 语句2</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 多线程环境下线程交替执行，由于编译器优化重排的存在。两个线程中使用的变量能否保证</span><br>    <span class="hljs-comment">// 一致性是无法确定的，结果无法预测</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method02</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            a = a + <span class="hljs-number">5</span>; <span class="hljs-comment">// 语句3</span><br>            System.out.println(a);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个案例是说，由于指令重排，可能会先执行语句2，然后呢flag变为true，然后还没执行语句1，就执行了语句3.</p><h3 id="禁止指令重排小结"><a href="#禁止指令重排小结" class="headerlink" title="禁止指令重排小结"></a>禁止指令重排小结</h3><p>volatile实现<font>禁止指令重排优化</font>，从而避免多线程环境下程序出现乱序执行的现象</p><ol><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。</li></ol><p>由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说<font>通过内存屏障禁止在内存屏障前后的指令执行重排序优化。</font> 内存屏障的另一个作用是<font>强制刷出各种CPU的缓存数据,</font>因此任何CPU上的线程都能读取到这些数据的最新版本</p><h3 id="你在哪里用过volatile"><a href="#你在哪里用过volatile" class="headerlink" title="你在哪里用过volatile"></a>你在哪里用过volatile</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>DCL双重检查加锁实现单例模式，本意是想要实现延迟初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleDemo</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">SingleDemo</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleDemo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(Thread.currentThread().getName());<br>    &#125;<br>    <br>    <span class="hljs-comment">// DCL(double check lock)双端检测机制</span><br>    <span class="hljs-comment">// 双端检锁模式不一定线程安全，原因是指令重排的存在，加入volatile可以禁止指令重排</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleDemo <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 如果instance不为null,则不会尝试去获取锁</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(SingleDemo.class)&#123;<br>                <span class="hljs-comment">// 再次检测instance是不是为null</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance == <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleDemo</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 总会返回一个实例，只是说是不是为null</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*上面代码其实还是线程不安全的，虽然执行成百上千遍可能不会出现问题，但是有指令重排的机制，加入*volatile可以禁止指令重排；new SingleDemo可以分为三步</span><br><span class="hljs-comment">* 1， memory = allocate();分配地址空间</span><br><span class="hljs-comment">* 2， SingleDemo = memory;设置实例指向刚分配的内存地址，此时SingleDemo != null,但是</span><br><span class="hljs-comment">*     对象还没有完成初始化、</span><br><span class="hljs-comment">* 3， SingleDemo(memory);初始化对象</span><br><span class="hljs-comment">* 但是指令重排只会保证串行语义执行的一致性（单线程），单并不会关心多线程间的语义一致性；</span><br><span class="hljs-comment">* 所以当一条线程访问实例不为null时，由于实例未必完成初始化，也就造成了线程安全问题；</span><br><span class="hljs-comment">* 但是这种问题概率极低，在解释一下，有时候你只是给实例分配了地址空间但是并没有实例初始化</span><br><span class="hljs-comment">* 你去取值就会存在问题。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS(compare and set)比较并交换，与期待值相等则set,不相等不set .他是一条<font>CPU并发原语</font>他的功能是判断内存某个位置的值是否为预期值，如果是则更新为新的值，这个过程是原子的。</p><p>CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现CAS汇编指令。这是一种完全依赖硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语是属于操作系统用语范畴，是由若干指令组成的，用于完成某个功能的一个过程，并且<font>原语的执行必须都是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</font></p><h4 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h4><p>是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于是一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sum.misc包中,其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p><p><strong>注意</strong><font>Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。</font></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p>如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p></li><li><p>只能保证一个共享变量的原子操作 </p><p>当对一个共享变量操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以利用所来保证原子性。</p></li><li><p>会导致ABA问题</p></li></ol><h4 id="ABA问题是如何产生的"><a href="#ABA问题是如何产生的" class="headerlink" title="ABA问题是如何产生的"></a>ABA问题是如何产生的</h4><p>CAS算法实现一个重要的前提需要取出内存中某时刻的数据，并在当下时刻比较替换，那么在这个时间差内会导致数据的变化。</p><p>比如说一个线程one从内存位置V取出A，这时候另一个线程two，也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变为A，这个时候线程one进行CAS操作发现内存中的值任然是A，然后线程one操作成功。</p><p><font>尽管线程one的CAS操作是成功的，但是不代表这个过程没有问题。</font></p><h2 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h2><p>相当于玩游戏机，但是只有一个游戏机（相当于一个cpu），start是开始排队，然后当轮到你了，就是相当于处理机给你分到了时间片，然后你就开始玩，就相当于执行你的run方法。当玩完了就相当于run()执行结束了或者被提前打断了相当于调用了stop方法。那么线程就会死亡，死亡的线程是无法再次进行start()的。</p><p><strong>总结：</strong> <strong>对线程就是分时利用CPU，宏观上让所有的线程一起执行，也叫并发。</strong></p><h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><ul><li><strong>并行还是并发取决于CPU的核心数量，多一个核心数就可以多处理一个线程，所以如果CPU有多个核心的话，是可以实现并行的。</strong></li><li>时间点不同。并发是<font>同一时间段</font>发生了很多事，这些事情交替执行。并行是<font>同一时刻</font>这些事情一起执行而不是交替。      </li></ul><h2 id="线程的6种状态"><a href="#线程的6种状态" class="headerlink" title="线程的6种状态"></a>线程的6种状态</h2><ol><li><p>初始状态</p><p><strong>线程被创建（new），但是还没有被start()</strong></p></li><li><p>就绪状态</p><p><strong>线程被start(),但是还没有被分到时间片</strong></p></li><li><p>运行状态</p><p><strong>线程分到时间片，开始运行</strong></p></li><li><p>阻塞状态</p><p><strong>线程因为请求不到资源，或者资源被占用导致处于阻塞状态</strong></p></li><li><p>等待状态</p><p><strong>进入该状态表示当前线程需要等待其他的线程做出一些特定的动作（通知或者中断）</strong></p></li><li><p>超时状态</p><p><strong>此状态不同于等待状态，超时等待状态可以在指定的时间内自行返回的。sleep() wait() join()</strong></p></li><li><p>终止状态</p><p><strong>表示当前线程已经执行完毕</strong></p></li></ol><p><img src="01.png" alt="01"></p><h2 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h2><p>死锁是指两个或者两个以上的线程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞的现象。若无外力的干涉，将一直持续下去导致程序无法继续执行下去。此时称系统处于死锁状态或者是系统产生了死锁。这些永远在等待的线程称为死锁线程。</p><p><img src="02.png" alt="02"> </p><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ul><li><strong>破坏互斥条件：</strong>这个条件我们无法破坏，因为我们用锁本来就是想让他们互斥的。一个资源每次只能被一个进程使用</li><li><strong>破坏请求与保持条件：</strong>一个进程因请求资源而阻塞时，对以获得资源保持不放。</li><li><strong>破坏不剥夺条件：</strong>一个进程以获得的资源，在没有使用完之前不得强行剥夺。</li><li><strong>破坏循环等待条件：</strong>若干线程之间形成首尾相接的循环等待资源的关系。</li></ul><h2 id="什么是死锁，活锁"><a href="#什么是死锁，活锁" class="headerlink" title="什么是死锁，活锁"></a>什么是死锁，活锁</h2><ul><li><strong>死锁：</strong> 死锁是两个或者多个线程之间由于竞争资源而导致的一种阻塞的现象。可以通过避免一个线程获取多个锁；一个锁占用一个资源；使用定时锁；</li><li><strong>死锁的必要条件：</strong>互斥条件、请求与保持条件、不剥夺条件、循环等待条件</li><li><strong>活锁：</strong>线程之间相互谦让都无法获取相应资源继续执行。</li></ul><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch是一个<font>同步工具类</font>，用来协调多个线程之间的同步，或者起到线程之间的通信，而不是用作互斥的作用。</p><p>CountDownLatch能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成一些任务，然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。</p><h3 id="CountDownLatch的用法"><a href="#CountDownLatch的用法" class="headerlink" title="CountDownLatch的用法"></a>CountDownLatch的用法</h3><p>CountDownLatch典型用法：</p><p>1、某一线程在开始运行前等待n个线程执行完毕。将CountDownLatch的计数器初始化为new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减1 countdownLatch.countDown()，当计数器的值变为0时，在CountDownLatch上await()的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p><p>2、实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的CountDownLatch(1)，将其计算器初始化为1，多个线程在开始执行任务前首先countdownlatch.await()，当主线程调用countDown()时，计数器变为0，多个线程同时被唤醒。</p><h3 id="CountDownLatch的不足"><a href="#CountDownLatch的不足" class="headerlink" title="CountDownLatch的不足"></a>CountDownLatch的不足</h3><p>CountDownLatch是一次性的，计算器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏，是一个可以循环利用的屏障。</p><p><strong>作用：</strong> 就是会让所有的线程都等待完成后才会继续 下一步的动作。</p><p><strong>例子：</strong> 我们约朋友一起吃饭，有些朋友会早到，有些可能会晚到，但是呢这个餐厅有个规定那就是，必须等人全部到齐了以后才会让你进入，这里的朋友就是各个线程，餐厅就是CyclicBarrier。</p><p><strong>构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span><br></code></pre></td></tr></table></figure><p><strong>解析：</strong> </p><ul><li>parties 是参与线程的个数。</li><li>第二个参数Runable，这个 参数的意思是一个线程到达后要做的任务</li></ul><p><strong>重要方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException<br></code></pre></td></tr></table></figure><ul><li>线程调用await(),表示自己已经到达栅栏</li><li>BrokenBarrierException表示栅栏已经被破坏，破坏的原因可能是其中一个线程await()时被中断或者超时。</li></ul><p><strong>基本使用：</strong></p><p>需求：一个线程组的线程需要等待所有的线程完成后再继续执行下一次任务。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrier</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskThread</span> entends Thread &#123;<br>        CyclicBarrier barrier;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskThread</span><span class="hljs-params">(CyclicBarrier barrier)</span>&#123;<br>            <span class="hljs-built_in">this</span>.barrier = barrier;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    sout(getName() + <span class="hljs-string">&quot;到达栅栏 A&quot;</span>);<br>                    barrier.await();<br>                    sout(getName() + <span class="hljs-string">&quot;冲破栅栏 A&quot;</span>);<br>          <br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    System.out.println(getName() + <span class="hljs-string">&quot; 到达栅栏 B&quot;</span>);<br>                    barrier.await();<br>                    System.out.println(getName() + <span class="hljs-string">&quot; 冲破栅栏 B&quot;</span>);<br>                 &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                    e.printStrackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>            <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(threadName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runable</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                    sout(Thread.currentThread().getName() + <span class="hljs-string">&quot;完成最后任务&quot;</span>);<br>                &#125;<br>            &#125;)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; threadNum; i++)&#123;<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskThread</span>(barrier).start();<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="乐观锁和非乐观锁"><a href="#乐观锁和非乐观锁" class="headerlink" title="乐观锁和非乐观锁"></a>乐观锁和非乐观锁</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p><ul><li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li><li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>在说明实现方式之前，需要明确：<strong>乐观锁和悲观锁是两种思想，它们的使用是非常广泛的，不局限于某种编程语言或数据库。</strong></p><p>悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）。</p><p>乐观锁的实现方式主要有两种：CAS机制和版本号机制，下面详细介绍。</p><h4 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h4><p>CAS操作包括了3个操作数：</p><ul><li>需要读写的内存位置(V)</li><li>进行比较的预期值(A)</li><li>拟写入的新值(B)</li></ul><p>CAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p><p>这里引出一个新的问题，既然CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？答案是：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。</p><p>下面以Java中的自增操作(i++)为例，看一下悲观锁和CAS分别是如何保证线程安全的。我们知道，在Java中自增操作不是原子操作，它实际上包含三个独立的操作：（1）读取i值；（2）加1；（3）将新值写回i</p><p>因此，如果并发执行自增操作，可能导致计算结果的不准确。在下面的代码示例中：value1没有进行任何线程安全方面的保护，value2使用了乐观锁(CAS)，value3使用了悲观锁(synchronized)。运行程序，使用1000个线程同时对value1、value2和value3进行自增操作，可以发现：value2和value3的值总是等于1000，而value1的值常常小于1000。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>     <br>    <span class="hljs-comment">//value1：线程不安全</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//value2：使用乐观锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//value3：使用悲观锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increaseValue3</span><span class="hljs-params">()</span>&#123;<br>        value3++;<br>    &#125;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//开启1000个线程，并执行自增操作</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i)&#123;<br>            <span class="hljs-comment">// 内部类的形式</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    value1++;<br>                    value2.getAndIncrement();<br>                    increaseValue3();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>        <span class="hljs-comment">//打印结果</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;线程不安全：&quot;</span> + value1);<br>        System.out.println(<span class="hljs-string">&quot;乐观锁(AtomicInteger)：&quot;</span> + value2);<br>        System.out.println(<span class="hljs-string">&quot;悲观锁(synchronized)：&quot;</span> + value3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先来介绍AtomicInteger。AtomicInteger是java.util.concurrent.atomic包提供的原子类，利用CPU提供的CAS操作来保证原子性；除了AtomicInteger外，还有AtomicBoolean、AtomicLong、AtomicReference等众多原子类。</p><p>下面看一下AtomicInteger的源码，了解下它的自增操作getAndIncrement()是如何实现的（源码以Java7为例，Java8有所不同，但思想类似）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    <span class="hljs-comment">//存储整数值，volatile保证可视性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-comment">//Unsafe用于实现对底层资源的访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br> <br>    <span class="hljs-comment">//valueOffset是value在内存中的偏移量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>    <span class="hljs-comment">//通过Unsafe获得valueOffset</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, expect, update);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 自旋</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> get();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (compareAndSet(current, next))<br>                <span class="hljs-keyword">return</span> current;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码分析说明如下：</p><p>（1）getAndIncrement()实现的自增操作是自旋CAS操作：在循环中进行compareAndSet，如果执行成功则退出，否则一直执行。</p><p>（2）其中compareAndSet是CAS操作的核心，它是利用Unsafe对象实现的。</p><p>（3）Unsafe又是何许人也呢？Unsafe是用来帮助Java访问操作系统底层资源的类（如可以分配内存、释放内存），通过Unsafe，Java具有了底层操作能力，可以提升运行效率；强大的底层资源操作能力也带来了安全隐患(类的名字Unsafe也在提醒我们这一点)，因此正常情况下用户无法使用。AtomicInteger在这里使用了Unsafe提供的CAS功能。</p><p>（4）valueOffset可以理解为value在内存中的偏移量，对应了CAS三个操作数(V/A/B)中的V；偏移量的获得也是通过Unsafe实现的。</p><p>（5）value域的volatile修饰符：<font>Java并发编程要保证线程安全，需要保证原子性、可视性和有序性；</font>CAS操作可以保证原子性，而volatile可以保证可视性和一定程度的有序性；在AtomicInteger中，volatile和CAS一起保证了线程安全性。关于volatile作用原理的说明涉及到Java内存模型(JMM)，这里不详细展开。</p><p>说完了AtomicInteger，再说synchronized。<font>synchronized通过对代码块加锁来保证线程安全：在同一时刻，只能有一个线程可以执行代码块中的代码。</font>synchronized是一个重量级的操作，<font>不仅是因为加锁需要消耗额外的资源，还因为线程状态的切换会涉及操作系统核心态和用户态的转换；</font>不过随着JVM对锁进行的一系列优化(如自旋锁、轻量级锁、锁粗化等)，synchronized的性能表现已经越来越好。</p><h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>除了CAS，版本号机制也可以用来实现乐观锁。版本号机制的基本思路是在数据中增加一个字段version，表示该数据的版本号，每当数据被修改，版本号加1。当某个线程查询数据时，将该数据的版本号一起查出来；当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。</p><p>需要注意的是，这里使用了版本号作为判断数据变化的标记，实际上可以根据实际情况选用其他能够标记数据版本的字段，如时间戳等。    </p><p>下面以“更新玩家金币数”为例（数据库为MySQL，其他数据库同理），看看悲观锁和版本号机制是如何应对并发问题的。</p><p>考虑这样一种场景：游戏系统需要更新玩家的金币数，更新后的金币数依赖于当前状态(如金币数、等级等)，因此更新前需要先查询玩家当前状态。</p><p>下面的实现方式，没有进行任何线程安全方面的保护。如果有其他线程在query和update之间更新了玩家的信息，会导致玩家金币数的不准确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateCoins</span><span class="hljs-params">(Integer playerId)</span>&#123;<br>    <span class="hljs-comment">//根据player_id查询玩家信息</span><br>    <span class="hljs-type">Player</span> <span class="hljs-variable">player</span> <span class="hljs-operator">=</span> query(<span class="hljs-string">&quot;select coins, level from player where player_id = &#123;0&#125;&quot;</span>, playerId);<br>    <span class="hljs-comment">//根据玩家当前信息及其他信息，计算新的金币数</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">newCoins</span> <span class="hljs-operator">=</span> ……;<br>    <span class="hljs-comment">//更新金币数</span><br>    update(<span class="hljs-string">&quot;update player set coins = &#123;0&#125; where player_id = &#123;1&#125;&quot;</span>, newCoins, playerId);<br>&#125;<br></code></pre></td></tr></table></figure><p>为了避免这个问题，悲观锁通过加锁解决这个问题，代码如下所示。在查询玩家信息时，使用select …… for update进行查询；该查询语句会为该玩家数据加上排它锁，直到事务提交或回滚时才会释放排它锁；在此期间，如果其他线程试图更新该玩家信息或者执行select for update，会被阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateCoins</span><span class="hljs-params">(Integer playerId)</span>&#123;<br>    <span class="hljs-comment">//根据player_id查询玩家信息（加排它锁）</span><br>    <span class="hljs-type">Player</span> <span class="hljs-variable">player</span> <span class="hljs-operator">=</span> queryForUpdate(<span class="hljs-string">&quot;select coins, level from player where player_id = &#123;0&#125; for update&quot;</span>, playerId);<br>    <span class="hljs-comment">//根据玩家当前信息及其他信息，计算新的金币数</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">newCoins</span> <span class="hljs-operator">=</span> ……;<br>    <span class="hljs-comment">//更新金币数</span><br>    update(<span class="hljs-string">&quot;update player set coins = &#123;0&#125; where player_id = &#123;1&#125;&quot;</span>, newCoins, playerId);<br>&#125;<br></code></pre></td></tr></table></figure><p>版本号机制则是另一种思路，它为玩家信息增加一个字段：version。在初次查询玩家信息时，同时查询出version信息；在执行update操作时，校验version是否发生了变化，如果version变化，则不进行更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateCoins</span><span class="hljs-params">(Integer playerId)</span>&#123;<br>    <span class="hljs-comment">//根据player_id查询玩家信息，包含version信息</span><br>    <span class="hljs-type">Player</span> <span class="hljs-variable">player</span> <span class="hljs-operator">=</span> query(<span class="hljs-string">&quot;select coins, level, version from player where player_id = &#123;0&#125;&quot;</span>, playerId);<br>    <span class="hljs-comment">//根据玩家当前信息及其他信息，计算新的金币数</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">newCoins</span> <span class="hljs-operator">=</span> ……;<br>    <span class="hljs-comment">//更新金币数，条件中增加对version的校验</span><br>    update(<span class="hljs-string">&quot;update player set coins = &#123;0&#125;, version = version + 1 where player_id = &#123;1&#125; and version = &#123;2&#125;&quot;</span>, newCoins, playerId, player.version);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优缺点和适用场景"><a href="#优缺点和适用场景" class="headerlink" title="优缺点和适用场景"></a>优缺点和适用场景</h3><p>乐观锁和悲观锁并没有优劣之分，它们有各自适合的场景；下面从两个方面进行说明。</p><h4 id="功能限制"><a href="#功能限制" class="headerlink" title="功能限制"></a>功能限制</h4><p>与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。</p><p>例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。</p><h4 id="竞争激烈程度"><a href="#竞争激烈程度" class="headerlink" title="竞争激烈程度"></a>竞争激烈程度</h4><p>如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度：</p><ul><li>当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。</li><li>当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。</li></ul><h4 id="面试官追问：乐观锁加锁吗？"><a href="#面试官追问：乐观锁加锁吗？" class="headerlink" title="面试官追问：乐观锁加锁吗？"></a>面试官追问：乐观锁加锁吗？</h4><p>（1）乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；AtomicInteger便是一个例子。</p><p>（2）有时乐观锁可能与加锁操作合作，例如，在前述updateCoins()的例子中，MySQL在执行update时会加排它锁。但这只是乐观锁与加锁操作合作的例子，不能改变“乐观锁本身不加锁”这一事实。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="ReentrantLock-的公平锁"><a href="#ReentrantLock-的公平锁" class="headerlink" title="ReentrantLock 的公平锁"></a>ReentrantLock 的公平锁</h3><p>ReentrantLock 默认采用非公平锁，除非在构造方法中传入参数 true 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><span class="hljs-comment">//传入true or false</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="公平锁的-lock-方法："><a href="#公平锁的-lock-方法：" class="headerlink" title="公平锁的 lock 方法："></a>公平锁的 lock 方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// AbstractQueuedSynchronizer.acquire(int arg)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-comment">// 如果尝试获取锁没有成功</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，在注释1的位置，有个<code>!hasQueuedPredecessors()</code>条件，意思是说当前同步队列没有前驱节点（也就是没有线程在等待）时才会去<code>compareAndSetState(0, acquires)</code>使用CAS修改同步状态变量。所以就实现了公平锁，根据线程发出请求的顺序获取锁。</p><h3 id="非公平锁的lock方法"><a href="#非公平锁的lock方法" class="headerlink" title="非公平锁的lock方法"></a>非公平锁的lock方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span><br>            acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// AbstractQueuedSynchronizer.acquire(int arg)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="hljs-comment"> * subclasses, but both need nonfair try for trylock method.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//3.这里也是直接CAS，没有判断前面是否还有节点。</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>非公平锁的实现在刚进入lock方法时会直接使用一次CAS去尝试获取锁，不成功才会到acquire方法中，如注释2。而在nonfairTryAcquire方法中并没有判断是否有前驱节点在等待，直接CAS尝试获取锁，如注释3。由此实现了非公平锁。</p><p><strong>总结：</strong> <strong>非公平锁和公平锁的两处不同</strong></p><ol><li><p>非公平锁在调用lock()以后，首先就会调用CAS进行一次抢锁，如果这时候恰巧锁没有被抢占用，那么就直接获取到锁返回了</p></li><li><p>非公平锁在CAS失败后，和公平锁一样都会进入到tryAcquire()方法，在tryAcquire()方法中如果这个时候发现锁被释放了(state == 0),非公平锁会直接CAS抢锁，但公平锁会判断等待队列里面有没有正在等待的线程，如果有不去抢锁，排在后面。</p></li></ol><p><strong>相对来说非公平锁的性能比较好，因为他的吞吐量比较大。当然非公平锁让获取锁的时间变得更加不确定，可能会导致阻塞队列中的线程长期处于饥饿状态。</strong></p><h2 id="sychronized-和-Lock的区别"><a href="#sychronized-和-Lock的区别" class="headerlink" title="sychronized 和 Lock的区别"></a>sychronized 和 Lock的区别</h2><ol><li><p><strong>原始构成</strong></p><p>synchronized是关键字属于JVM层面，monitorenter底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象只有在同步块或方法中才能调用wait/notify等方法monitorexit</p><p>Lock是具体类(Java.util.concurrent.locks.lock)是api层面的锁</p></li><li><p>使用方法</p><p>synchronized <font>不需要用户手动释放锁</font>，当synchronized代码执行完后系统会自动让线程释放对锁的占用</p><p>ReentrantLock则<font>需要用户去手动释放锁</font>若没有主动释放锁，就有可能导致死锁现象需要lock()和unlock()配合try/finally语句块来完成.</p></li><li><p>等待是否可中断</p><p>ReentrantLock可中断，1. 设置超时方法tryLock(long timeout, TimeUnit unit)</p><div class="code-wrapper"><pre><code class="hljs">                                     2. lockInterruptibly()放代码块中，调用interrupt()方法可中断</code></pre></div></li><li><p>加锁是否公平</p><p>synchronized非公平锁</p><p>ReentrantLock两者都可以，默认非公平锁，构造方法可以传入Boolean值，true为公平锁，false为非公平锁</p></li><li><p>绑定多个条件Condition</p><p>​    synchronized没有</p><p>Reentrantlock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试之Spring IOC AOP</title>
    <link href="/2022/03/30/java%E9%9D%A2%E8%AF%95%E4%B9%8BAOP-IOC/"/>
    <url>/2022/03/30/java%E9%9D%A2%E8%AF%95%E4%B9%8BAOP-IOC/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-面试之Spring-AOP-IOC"><a href="#Java-面试之Spring-AOP-IOC" class="headerlink" title="Java 面试之Spring AOP IOC"></a>Java 面试之Spring AOP IOC</h1><h3 id="Spring优点"><a href="#Spring优点" class="headerlink" title="Spring优点"></a>Spring优点</h3><ul><li>方便解耦，简化开发 Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护交给Spring管理</li><li>方便集成各种框架 Spring可以整合很多框架，比如Mybatis</li><li>方便程序的测试 Spring支持JUnit4，可以通过注解很方便的测试Spring程序</li><li>支持AOP（面向切面编程） Spring提供了面向切面编程</li><li>声明式事务 只需要配置就可以完成对事务的管理，无需手动编程</li></ul><h3 id="使用Spring需要导入的jar"><a href="#使用Spring需要导入的jar" class="headerlink" title="使用Spring需要导入的jar"></a>使用Spring需要导入的jar</h3><ul><li>Spring-core：包含Spring框架基本的核心工具类，Spring的其他组件都要用到这个包中的类，是其他组件的基本核心</li><li>Spring-beans：包含访问配置文件、创建和管理bean以及进行IOC或者DI操作相关的所有类</li><li>Spring-context：Spring提供在基础IOC功能上的扩展服务，此外还提供许多企业级服务的支持，例如邮件服务、任务调度等</li><li>Spring-expression：定义了Spring的表达式语句</li><li>commons-logging：处理日志信息</li><li>使用SPring框架，只需要倒入Spring的四个基础jar和处理日志信息的commons-logging即可</li></ul><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p><strong>IOC是指在程序开发过程中，对象实例的创建不再由调用者管理，而是由Spring容器创建，Spring容器会负责控制程序之间的关系，而不是由代码直接控制，因此，控制权由程序代码转移到了Spring容器，控制权发生了反转，即控制反转。</strong> <strong>Spring IOC提供了两种IOC容器，分别是BeanFactory和ApplicationContext。</strong></p><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BeanFactory是基础的IOC容器，是一个接口，提供了完整的IOC服务，BeanFactory是一个管理Bean的工厂，他主要负责初始化各种bean，并调用它们的生命周期方法 BeanFactory接口有多个实现类，最常见的是XmlBeanFactory，它根据Xml配置文件中的定义装配Bean。 <strong>创建XmlBeanFactory对象，传入xml文件</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs haxe">BeanFactory beanFactory = <span class="hljs-keyword">new</span> <span class="hljs-type">XmlBeanFactory</span>(<span class="hljs-keyword">new</span><span class="hljs-type">FileSystemResource</span>(<span class="hljs-string">&quot;D://applicationContext.xml&quot;</span>));<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p><strong>ApplicationContext是BeanFactory的字接口，也被称为应用上下文，不仅提供了BeanFactory的所有功能，还添加了对国际化、资源访问、事件传播等方面的支持。</strong></p><p>ApplicationContext提供了两个实现类</p><ul><li>ClassPathXmlApplicationContext 该类从类路径ClassPath中寻找制定的xml文件</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">ApplicationContext applicationContext = <span class="hljs-keyword">new</span> <span class="hljs-type">ClassPathXmlApplicationContext</span>(<span class="hljs-keyword">String</span> configLocation);<br>复制代码<br></code></pre></td></tr></table></figure><p>configLocation参数用来指定Spring配置文件的名称和位置</p><ul><li>FileSystemXmlApplicationContext 该类从指定的文件系统路径中寻找指定的xml文件</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">* ApplicationContext applicationContext = <span class="hljs-keyword">new</span> <span class="hljs-type">FileSystemXmlApplicationContext</span>(<span class="hljs-keyword">String</span> configLocation);<br><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>ClassPathXmlApplicationContext和FileSystemXmlApplicationContext的区别</strong> 在读取Spring的配置文件时，ClassPathXmlApplicationContext从ClassPath中读取配置文件，而FileSystemXmlApplicationContext通过configLocated参数的值从文件系统中读取xml文件。</p><p><strong>在Java项目中，通常使用ClassPathXmlApplicationContext类实例化ApplicationContext容器，而在web项目中，ApplicationContext容器的实例化工作交给web服务器完成，web服务器实例化ApplicationContext容器通常使用基于ContextLoaderListener实现的方式，只需要编辑web。xml文件即可</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定Spring配置文件的位置，有多个配置文件时，以逗号分隔--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--spring将加载spring目录下的applicationContext.xml文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span><br>        classpath:spring/applicationContext.xml<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-comment">&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span><br>        org.springframework.web.context.ContextLoaderListener<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>BeanFactory和ApplicationContext的区别</strong> 如果Bean的某一个属性没有注入，则使用BeanFactory加载后，在第一次调用getBean方法时会抛出异常，而ApplicationContext会在初始化时检查，有利于检查所依赖的属性是否注入。</p><h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><p>依赖注入和控制反转含义相同，他们是从两个角度描述同一个概念。 当某个对象实例需要另外一个对象实例时，传统的方法是由调用者创建被调用者的实例，比如使用new，而使用Spring框架后，被调用者的实例不再有调用者创建，而是交给了Spring容器，者称为控制反转。 Spring容器在创建被调用实例时，会自动将调用者需要的对象实例注入为调用者，这样，通过  Spring容器获得被调用者实例，成为依赖注入。</p><p><strong>依赖注入的实现方式</strong></p><ul><li>属性setter注入</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//创建类A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;正在初始化类A，调用无参构造器A。。。&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;调用了类A的print方法。。。&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//创建类B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setA</span>(<span class="hljs-params">A a</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) &#123;<br>        a.<span class="hljs-title function_">print</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//配置Beans.xml</span><br>    &lt;bean id=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;com.ssm.ioc.A&quot;</span>/&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.ssm.ioc.B&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;a&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="hljs-comment">//测试</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>        B b = (B) context.<span class="hljs-title function_">getBean</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        b.<span class="hljs-title function_">print</span>();<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>构造构造器注入</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//配置Beans.xml</span><br>    &lt;bean id=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;com.ssm.ioc.A&quot;</span>/&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.ssm.ioc.B&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;a&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="hljs-comment">//测试</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>        B b = (B) context.<span class="hljs-title function_">getBean</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        b.<span class="hljs-title function_">print</span>();<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>静态工厂方式实例化</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//创建工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> A <span class="hljs-title function_">createCoffer</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//配置Beans.xml</span><br>&lt;bean id=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;com.ssm.ioc.MyBeanFactory&quot;</span> factory-method=<span class="hljs-string">&quot;createA&quot;</span>/&gt;<br><span class="hljs-comment">//测试</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>        A a = (A) context.<span class="hljs-title function_">getBean</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>实例工厂实例化</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//创建工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanFactory</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBeanFactory</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;A工厂实例化中。。。&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> A <span class="hljs-title">createBean</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> A();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//配置Beans.xml</span><br>    &lt;bean id=<span class="hljs-string">&quot;myBeanFactory&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;com.ssm.ioc.MyBeanFactory&quot;</span>/&gt;<br>    &lt;bean id=<span class="hljs-string">&quot;a&quot;</span> factory-bean=<span class="hljs-string">&quot;myBeanFactory&quot;</span> factory-method=<span class="hljs-string">&quot;createBean&quot;</span>/&gt;<br><span class="hljs-comment">//测试</span><br>    @Test<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>()</span> &#123;<br>        A a = (A) context.getBean(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="Bean的会话状态"><a href="#Bean的会话状态" class="headerlink" title="Bean的会话状态"></a>Bean的会话状态</h4><ul><li>有状态会话的Bean 每个用户有自己特有的一个实例，在用户的生存期内，bean保持可用户的信息，即”有状态”，一旦用户灭亡(调用结束或实例结束)，bean的生命周期也会结束。</li><li>无状态会话的Bean bean一旦被实例化就被加到会话池中，各个用户可以公用，即使用户死亡，bean的生命周期也不一定结束，他可能依然存在于会话池中，供其他用户使用，由于没有特定的用户，也就没办法保存用户的状态，所以叫无状态Bean，但无状态Bean并非没有状态，如果它有自己的属性，那么这些属性就会受到所有调用它的用户的影响。</li></ul><h4 id="Servlet的线程安全问题"><a href="#Servlet的线程安全问题" class="headerlink" title="Servlet的线程安全问题"></a>Servlet的线程安全问题</h4><p>Servlet体系结构是建立在Java多线程机制上的，它的生命周期是由web容器负责的，一个Servlet类Application中只有一个实例存在，也就是有多个线程在使用这个实例，这是单例模式的使用。Servlet本身是无状态的，无状态的单例是线程安全的，但是如果在Servlet中使用了实例变量，那么就会变成有状态了，是非线程安全的。</p><h4 id="如何解决Servlet的线程安全问题"><a href="#如何解决Servlet的线程安全问题" class="headerlink" title="如何解决Servlet的线程安全问题"></a>如何解决Servlet的线程安全问题</h4><ul><li>避免使用实例变量</li><li>避免使用非线程安全集合</li><li>在多个Servlet中对某个外部对象的修改进行加锁操作</li></ul><h4 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h4><ul><li>在Spring配置文件中，使用的scope属性设置Bean的作用域</li><li>singleton 单例模式，使用singleton定义的Bean在Spring容器中只有一个实例，这也是Bean的默认作用域，所有的Bean请求，只要id与该Bean定义相匹配，就只会返回Bean的同一个实例。适用于无回话状态的Bean，例如(DAO层、Service层)。</li><li>prototype 原型模式，每次通过Spring容器获取prototype定义的Bean时，容器都会创建一个新的Bean实例，适用于需要需要保持会话状态的Bean(比如Struts2的Action类)。</li><li>request 在一次HTTP请求中，容器会返回该Bean的同一个实例，而对于不同的HTTP请求，会返回不同的实例，该作用域仅在当前HttpRequest内有效</li><li>session 在一次HttpSession中，容器会返回该Bean的同一个实例，而对于不同的HTTP请求，会返回不同的实例，该作用域仅在当前HttpSession内有效</li><li>global Session 在一个全局的session中，容器会返回该Bean的同一个实例，该作用域仅在使用portlet context时有效。</li></ul><h4 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h4><ul><li>Spring容器可以管理singleton作用域Bean的生命周期，在此作用域下，Spring能够精确的知道该Bean何时被创建，何时初始化完成，以及何时被销毁。</li><li>而对于prototype作用域的Bean，Spring只负责创建，当容器创建了Bean的实例后，Bean的实例就交给客户端代码管理，Spring容器不再跟踪其生命周期，每次客户端请求prototype作用域的bean时，Spring容器都会创建一个新的Bean，并且不会管那些被配置成prototype作用域的Bean的生命周期。</li></ul><p><strong>当一个Bean被加载到Spring容器时，就具有了生命周期，而Spring容器在保证一个Bean能够使用之前，会进行很多工作</strong></p><p><img src="01.png" alt="01"></p><h5 id="Bean的生命周期的执行过程"><a href="#Bean的生命周期的执行过程" class="headerlink" title="Bean的生命周期的执行过程"></a>Bean的生命周期的执行过程</h5><ul><li>根据配置文件的配置调用Bean的构造方法或者工厂方法实例化Bean</li><li>利用依赖注入完成Bean中所有属性值的配置注入</li><li>如果Bean实现了BeanNameAware接口，则Spring调用Bean的setBeanName方法传入当前Bean的id值</li><li>如果Bean实现了BeanFactoryAware接口，则Spring调用setBeanFactory方法传入当前工厂实例的引用</li><li>如果Bean实现了ApplicationContextAware接口，则Spring调用setApplicationContext方法传入当前ApplicationContext实例的引用</li><li>如果BeanPostProcessor和Bean关联，则Spring将调用该接口的预初始化方法postProcessBeforeInitialization对Bean进行加工，Spring AOP就是利用它实现的</li><li>如果Bean实现了InitializingBean接口，则Spring调用afterPropertiesSet方法</li><li>如果在配置文件中通过init-method属性指定了初始化方法，则调用该初始化方法</li><li>如果BeanPostProcessor 和Bean关联，则Spring将调用该接口的初始化方法postPrecessAfterInitialization，此时，Bean已经可以使用</li><li>如果在中指定了该Bean的作用范围为scope=”singleton”，则将该Bean放入Spring IOC的缓存池中，将触发Spring对该Bean的生命周期管理，若在中指定了该Bean的作用范围为scope=”prototype”，则将该Bean交给调用者，调用者管理该Bean的生命周期，Spring不再管理该Bean</li><li>如果Bean实现了DisposableBean接口，则Spring会调用destroy方法将Spring中的Bean销毁，如果在配置文件中通过destroy-method属性指定了Bean的销毁方法，则Spring将调用该方法对Bean进行销毁</li></ul><h3 id="Spring基于XML装配Bean"><a href="#Spring基于XML装配Bean" class="headerlink" title="Spring基于XML装配Bean"></a>Spring基于XML装配Bean</h3><h4 id="设值注入和构造器注入"><a href="#设值注入和构造器注入" class="headerlink" title="设值注入和构造器注入"></a>设值注入和构造器注入</h4><p><strong>在实例化Bean的过程中，首先调用默认的构造方法实例Bean对象，然后通过java的反射机制调用setter方法对属性进行注入，因此设置注入要求一个Bean的对应类必须满足以下两点要求</strong></p><ul><li>必须提供一个默认的无参构造方法</li><li>必须为需要注入的属性提供setter方法</li></ul><p>使用设值注入时，在Spring配置文件中，需要使用元素的子元素元素为每个属性注入值，而使用构造注入时，在配置文件中，主要使用标签定义构造方法的参数，可以使用value属性设置该参数的值。</p><h4 id="Annotation-注解-注入"><a href="#Annotation-注解-注入" class="headerlink" title="Annotation(注解)注入"></a>Annotation(注解)注入</h4><p><strong>JDK1.5之后，提供了Annotation功能，Spring也提供了对Annotation的全面支持，Spring3中定义了一系列注解</strong></p><ul><li>@Component：可以使用此注解描述Spring中的Bean，但它是一个泛化的概念，仅仅表示一个组件(Bean)，并且可以用在任何层次</li><li>@Repository：用于将数据访问层(DAO层)的类标示为Spring中的Bean</li><li>@Service：通常用作在业务层(Service层)，用于将业务层的类标示为Spring中的Bean</li><li>@Controlle：通常作用在控制层,用于将控制层的类标示为Spring中的Bean</li><li>@Autowired：用于Bean的属性变量、属性的Set方法及构造函数进行标注，配合对应的注解处理器完成Bean的自动配置工作，默认按照Bean的类型进行装配</li><li>@Resource：作用与Autowired一样，区别是@Autowired默认按照Bean的类型装配，@而Resource默认按照Bean的实例类型进行装配，@Resource有name、type属性，Spring将name属性解析为Bean实例名称，将type属性解析为Bean的梳理类型，如果指定name属性，则按照实例名称进行装配，如果指定type属性，按照Bean类型进行装配，如果都不指定，则先按照Bean实例名称装配，如果不能装配，则按照Bean的类型进行装配，如果都不能匹配，抛出NoSuchBeanDefinitionException异常</li><li>@Qualifier：与@Autowired配合使用，会将默认的按照Bean配型装配修改为按Bean的实例名称装配，Bean的实例名称由@qualifier注解的参数指定</li></ul><h4 id="Resource和-Autowired的区别"><a href="#Resource和-Autowired的区别" class="headerlink" title="@Resource和@Autowired的区别"></a>@Resource和@Autowired的区别</h4><ul><li>@Resource和@Autowired都是做bean的注入时使用</li><li>@Resource不是Spring中的注解，但是Spring支持该注解，而@Autowired是Spring的注解</li><li>@Autowired是按照类型(byType)来装配Bean的，不回去匹配name，默认情况下他要求依赖对象必须存在，如果需允许null，可以设置它的required属性为false，如果想让@Autowired按照名称（byName）来装配，则需要配合@Qualifier一起使用</li></ul><h4 id="Resource注解装配步骤"><a href="#Resource注解装配步骤" class="headerlink" title="@Resource注解装配步骤"></a>@Resource注解装配步骤</h4><ul><li>如果同时指定了name和type属性，则从Spring上下文中找到唯一匹配的Bean进行装配，找不到抛出异常</li><li>如果指定了name，则从上下文中查找名称(id)匹配的Bean进行装配，找不到抛出异常</li><li>如果指定了type，则从上下文查找类型匹配的唯一Bean进行装载，找不到或者是找到了多个，抛出异常</li><li>如果即没有指定name，也没有指定type，则默认按照byName进行查找并装载，如果没有匹配，则按照byType进行匹配并装载</li></ul><h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p><strong>自动装配是指Spring容器可以自动装配(autowire)相互协作的Bean之间的关系，将一个Bean注入其他Bean的Property中。</strong> 要使用自动装配，就需要配置元素的autowire值，autowire属性有五个</p><ul><li>byName：根据Property的name自动装配，如果一个Bean的name和另外一个Bean中的Property相同，则会自动装配这个Bean到Property中</li><li>byType：根据Property的数据类型自动装配，如果一个Bean的数据类型兼容另外一个Bean中Property的数据类型，则自动装配</li><li>constructor：根据构造方法的参数的数据类型，进行byType模式的自动装配</li><li>autodetect：如果发现默认的构造方法，则用constructor，否则有byType</li><li>no：默认情况下，不实用自动装配，Bean依赖必须通过ref元素定义</li></ul><h3 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h3><h4 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h4><ul><li>AOP和OOP类似，也是一种编程模式，Spring AOP是基于AOP编程模式的一个框架，它的使用有效减少了系统间的重复代码，达到了模块间解耦的作用。</li><li>AOP的全程是”Aspect Oriented Programming”，即面向切面编程，它将业务逻辑的各部分进行隔离，使开发人员在编写业务逻辑时可以专心核心业务，从而提高开发基础。</li><li>AOP采取横向抽取机制，取代了传统的纵向继承体系，其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。</li><li>目前最流行的AOP有Spring AOP和AspectJ</li><li>Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强的代码。</li><li>AspectJ是一个基于Java语言的AOP框架，从Spring2.0开始，Spring AOP引入了对AspectJ的支持。</li></ul><h4 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h4><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Joinpoint(连接点)</td><td>指那些被拦截到的点，在Spring中，可以被动态代理拦截目标类的方法</td></tr><tr><td>Pointcut(切入点)</td><td>指要对哪些Joinpoint进行拦截，即被拦截的连接点</td></tr><tr><td>Advice(通知)</td><td>指拦截到Joinpoint之后要做的事情，即对切入点增强的内容</td></tr><tr><td>Target(目标)</td><td>指代理的目标对象</td></tr><tr><td>Weaving(植入)</td><td>指把增强代码应用到目标上，生成代理对象的过程</td></tr><tr><td>Proxy(代理)</td><td>指生成的代理对象</td></tr><tr><td>Aspect(切面)</td><td>切入点和通知的结合</td></tr></tbody></table><p><strong>JDK动态代理是通过JDK中的Java.lang.reflect.Proxy实现的</strong></p><h4 id="使用JDK中的Proxy实现动态代理"><a href="#使用JDK中的Proxy实现动态代理" class="headerlink" title="使用JDK中的Proxy实现动态代理"></a>使用JDK中的Proxy实现动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomerDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 删除</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 查询</span><br>&#125;<br><br><span class="hljs-comment">//创建接口实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CustomerDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;添加客户...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;修改客户...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;删除客户...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;修改客户...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建切面类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myBefore</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法执行之前&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myAfter</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法执行之后&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建代理类</span><br><span class="hljs-keyword">import</span> com.mengma.dao.CustomerDao;<br><span class="hljs-keyword">import</span> com.mengma.dao.CustomerDaoImpl;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CustomerDao <span class="hljs-title function_">getBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//准备目标类</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CustomerDao</span> <span class="hljs-variable">customerDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomerDaoImpl</span>();<br>        <span class="hljs-comment">//创建切面类实例</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">MyAspect</span> <span class="hljs-variable">myAspect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAspect</span>();<br>        <span class="hljs-comment">//使用代理类，进行增强</span><br>        <span class="hljs-keyword">return</span> (CustomerDao) Proxy.newProxyInstance(<br>                <span class="hljs-comment">//当前类加载器</span><br>                MyBeanFactory.class.getClassLoader(),<br>                <span class="hljs-comment">//所创建实例的实现类接口</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;CustomerDao.class&#125;,<br>                <span class="hljs-comment">//需要增强的方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>                    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                        myAspect.myBefore();<br>                        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(customerDao, args);<br>                        myAspect.myBefore();<br>                        <span class="hljs-keyword">return</span> obj;<br>                    &#125;<br>                &#125;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建测试类</span><br><span class="hljs-keyword">import</span> com.mengma.dao.CustomerDao;<br><span class="hljs-keyword">import</span> com.mengma.jdk.MyBeanFactory;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAOP</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CustomerDao</span> <span class="hljs-variable">customerDao</span> <span class="hljs-operator">=</span> MyBeanFactory.getBean();<br>        customerDao.add();<br>        customerDao.delete();<br>        customerDao.find();<br>        customerDao.update();<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong> evernotecid://73D3823C-134C-4C14-AE11-0F871EA0D1DE/appyinxiangcom/27476071/ENResource/p4</p><p><img src="02.png" alt="02"></p><p><strong>在调用目标类的方法前后，成功调用了增强的代码</strong></p><h4 id="使用JDK自带的Proxy实现动态代理的局限性"><a href="#使用JDK自带的Proxy实现动态代理的局限性" class="headerlink" title="使用JDK自带的Proxy实现动态代理的局限性"></a>使用JDK自带的Proxy实现动态代理的局限性</h4><ul><li>JDK动态代理必须要实现一个或多个接口，如果不希望实现接口，可以使用CGLIB代理</li><li>CGLIB代理底层是通过使用一个小而快的字节码处理框架ASM(Java 字节码操控框架)转换字节码并生成新的类。因此CGLIB要依赖于ASM的jar包</li><li>Spring的core核心包中已经集成了CGLIB所需要的包</li></ul><h4 id="CGLIB实现动态代理"><a href="#CGLIB实现动态代理" class="headerlink" title="CGLIB实现动态代理"></a>CGLIB实现动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建目标类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodsDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;添加商品...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;修改商品...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;删除商品...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;修改商品...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建切面类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myBefore</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法执行之前&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myAfter</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法执行之后&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建代理类</span><br><span class="hljs-keyword">import</span> com.mengma.dao.GoodsDao;<br><span class="hljs-keyword">import</span> com.mengma.jdk.MyAspect;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodProxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GoodsDao <span class="hljs-title function_">getBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//创建目标类</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">GoodsDao</span> <span class="hljs-variable">goodsDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GoodsDao</span>();<br>        <span class="hljs-comment">//创建切面类实例</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">MyAspect</span> <span class="hljs-variable">myAspect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAspect</span>();<br>        <span class="hljs-comment">//生成代理类，CGLIB在运行时，生成指定对象的子类，增强</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">//确定需要增强的类</span><br>        enhancer.setSuperclass(goodsDao.getClass());<br>        <span class="hljs-comment">//添加回调函数</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInterceptor</span>() &#123;<br>            <span class="hljs-comment">//intercept相当于jdk invoke</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                myAspect.myBefore();<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(goodsDao, args);<br>                myAspect.myAfter();<br>                <span class="hljs-keyword">return</span> obj;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">GoodsDao</span> <span class="hljs-variable">goodsDaoProxy</span> <span class="hljs-operator">=</span> (GoodsDao) enhancer.create();<br>        <span class="hljs-keyword">return</span> goodsDaoProxy;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建测试类</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCGLIB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GoodsDao</span> <span class="hljs-variable">goodsDao</span> <span class="hljs-operator">=</span> com.mengma.cglib.MyBeanFactory.getBean();<br>        goodsDao.add();<br>        goodsDao.delete();<br>        goodsDao.find();<br>        goodsDao.update();<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="03.png" alt="03"></p><h4 id="Spring通知类型"><a href="#Spring通知类型" class="headerlink" title="Spring通知类型"></a>Spring通知类型</h4><p><strong>通知(Advice)是对目标切入点进行增强的内容。Spring为通知(Advice)提供了Advice接口，Spring通知按照在目标类方法的连接点位置，可分为五种类型</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>MethodBeforeAdvice(前置通知)</td><td>在方法之前自动执行的通知成为前置通知，可以应用于权限管理功能</td></tr><tr><td>AfterReturningAdvice(后置通知)</td><td>在方法执行之后自动执行的通知成为后置通知，可用于关闭流、上传文件、删除临时文件等功能</td></tr><tr><td>MethodInterceptor(环绕通道)</td><td>在方法前后自动执行的通知成为环绕通知，可以应用于日志、事务管理等功能</td></tr><tr><td>ThrowsAdvice(异常通知)</td><td>在方法抛出异常时自动执行的通知成为异常通知，可以应用于处理异常记录日志等功能</td></tr><tr><td>IntroductionInterceptor(引介通知)</td><td>在目标类中添加一些新的方法和属性，可以应用于修改旧版本程序(增强类)</td></tr></tbody></table><h4 id="生命Spring-AOP"><a href="#生命Spring-AOP" class="headerlink" title="生命Spring AOP"></a>生命Spring AOP</h4><p><strong>Spring创建了一个AOP代理的基本方法是使用ProxyFactoryBean，这个类对应的切入点和通知提供了完整的控制能力，并可以生成指定的内容</strong></p><h5 id="ProxyFactoryBean类中的常用可配置属性"><a href="#ProxyFactoryBean类中的常用可配置属性" class="headerlink" title="ProxyFactoryBean类中的常用可配置属性"></a>ProxyFactoryBean类中的常用可配置属性</h5><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>target</td><td>代理的目标对象</td></tr><tr><td>proxyInterfaces</td><td>代理要实现的接口，如果有多个接口，则可以使用list标签赋值</td></tr><tr><td>proxyTargetClass</td><td>是否对类代理而不是接口，设置为true时，使用CGLIB代理</td></tr><tr><td>interceptorNames</td><td>需要植入目标的Advice</td></tr><tr><td>singleton</td><td>返回的代理是否为单例，默认为true(单例)</td></tr><tr><td>optimize</td><td>设置为true时，强制使用CGLIB</td></tr></tbody></table><h3 id="环绕通知案例"><a href="#环绕通知案例" class="headerlink" title="环绕通知案例"></a>环绕通知案例</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//倒入Spring-aop依赖</span><br>        &lt;!-- <span class="hljs-attr">https</span>:<span class="hljs-comment">//mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span><br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br>复制代码<br><span class="hljs-comment">//创建切面类</span><br><span class="hljs-comment">//需要实现接口，确定哪个通知，及告诉Spring应该执行哪个方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-title class_">MethodInvocation</span> mi) throws <span class="hljs-title class_">Throwable</span> &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;方法执行之前&quot;</span>);<br>        <span class="hljs-comment">// 执行目标方法</span><br>        <span class="hljs-title class_">Object</span> obj = mi.<span class="hljs-title function_">proceed</span>();<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;方法执行之后&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>在上述代码中，MyAspect实现了MethodInterceptor接口，并重写了invoke方法，MethodInterceptor是Spring AOP的jar包提供的，而invoke方法用于确定目标方法mi，并告诉Spring要在目标方法前后执行哪些方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml">//创建Spring配置文件<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--目标类 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customerDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.dao.CustomerDaoImpl&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 通知 advice --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.factorybean.MyAspect&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--生成代理对象 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customerDaoProxy&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--代理实现的接口 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;proxyInterfaces&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mengma.dao.CustomerDao&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--代理的目标对象 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;customerDao&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--用通知增强目标 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;myAspect&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 如何生成代理，true:使用cglib; false :使用jdk动态代理 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;proxyTargetClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>首先配置了目标类和通知，然后使用ProxyFactoryBean类生成代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建测试类</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAOP</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">CustomerDao</span> <span class="hljs-variable">customerDao</span> <span class="hljs-operator">=</span> (CustomerDao) applicationContext.getBean(<span class="hljs-string">&quot;customerDaoProxy&quot;</span>);<br>        customerDao.update();<br>        customerDao.find();<br>        customerDao.delete();<br>        customerDao.add();<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>执行结果</strong></p><p><img src="04.png" alt="04"></p><h4 id="Spring使用AspectJ开发AOP，基于XML和Annotation"><a href="#Spring使用AspectJ开发AOP，基于XML和Annotation" class="headerlink" title="Spring使用AspectJ开发AOP，基于XML和Annotation"></a>Spring使用AspectJ开发AOP，基于XML和Annotation</h4><h5 id="使用AspectJ开发AOP的两种方式"><a href="#使用AspectJ开发AOP的两种方式" class="headerlink" title="使用AspectJ开发AOP的两种方式"></a>使用AspectJ开发AOP的两种方式</h5><ul><li>基于XML的声明式</li><li>基于Annotation的声明式</li></ul><h6 id="基于XML的声明式开发"><a href="#基于XML的声明式开发" class="headerlink" title="基于XML的声明式开发"></a>基于XML的声明式开发</h6><p>基于XML的声明式是指通过Spring配置文件的方式定义切面、切入点及声明通知，而所有的切面和通知都必须定义在<a href="https://link.juejin.cn/?target=undefined">aop:config</a>元素中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//倒入spring-aspects依赖</span><br>        &lt;dependency&gt;<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br>        &lt;/dependency&gt;<br>复制代码<br><span class="hljs-comment">//创建切面类</span><br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">JoinPoint</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">ProceedingJoinPoint</span>;<br><span class="hljs-comment">//切面类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>    <span class="hljs-comment">// 前置通知</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myBefore</span>(<span class="hljs-params">JoinPoint joinPoint</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;前置通知，目标：&quot;</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(joinPoint.<span class="hljs-title function_">getTarget</span>() + <span class="hljs-string">&quot;方法名称:&quot;</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(joinPoint.<span class="hljs-title function_">getSignature</span>().<span class="hljs-title function_">getName</span>());<br>    &#125;<br>    <span class="hljs-comment">// 后置通知</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myAfterReturning</span>(<span class="hljs-params">JoinPoint joinPoint</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;后置通知，方法名称：&quot;</span> + joinPoint.<span class="hljs-title function_">getSignature</span>().<span class="hljs-title function_">getName</span>());<br>    &#125;<br>    <span class="hljs-comment">// 环绕通知</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">myAround</span>(<span class="hljs-title class_">ProceedingJoinPoint</span> proceedingJoinPoint)<br>            throws <span class="hljs-title class_">Throwable</span> &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;环绕开始&quot;</span>); <span class="hljs-comment">// 开始</span><br>        <span class="hljs-title class_">Object</span> obj = proceedingJoinPoint.<span class="hljs-title function_">proceed</span>(); <span class="hljs-comment">// 执行当前目标方法</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;环绕结束&quot;</span>); <span class="hljs-comment">// 结束</span><br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <span class="hljs-comment">// 异常通知</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myAfterThrowing</span>(<span class="hljs-params">JoinPoint joinPoint, Throwable e</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;异常通知&quot;</span> + <span class="hljs-string">&quot;出错了&quot;</span> + e.<span class="hljs-title function_">getMessage</span>());<br>    &#125;<br>    <span class="hljs-comment">// 最终通知</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myAfter</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;最终通知&quot;</span>);<br>    &#125;<br>&#125;<br>复制代码<br><span class="hljs-comment">//创建Spring配置文件</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/beans</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/aop</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--目标类 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customerDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.dao.CustomerDaoImpl&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--切面类 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.aspectJ.xml.MyAspect&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--AOP 编程 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--配置切入点，通知最后增强哪些方法--&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution ( * com.mengma.dao.*.* (..))&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myPointCut&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--前置通知，关联通知Advice和切入点PointCut--&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;myBefore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointCut&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--后置通知，在方法返回后执行，就可以获得返回值returning属性--&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;myAfterReturning&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointCut&quot;</span> <span class="hljs-attr">returning</span>=<span class="hljs-string">&quot;joinPoint&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--环绕通知--&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;myAround&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointCut&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--抛出通知：用于处理程序发生异常，可以接收当前方法产生的异常 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- *注意：如果程序没有异常，则不会执行增强 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- * throwing属性：用于设置通知第二个参数的名称，类型Throwable --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;myAfterThrowing&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointCut&quot;</span> <span class="hljs-attr">throwing</span>=<span class="hljs-string">&quot;e&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--最终通知：无论程序发生任何事情，都将执行 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;myAfter&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointCut&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br>复制代码<br><span class="hljs-comment">//创建测试类</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">testAspectJForXml</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">ApplicationContext</span> applicationContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);<br>        <span class="hljs-title class_">CustomerDao</span> customerBean = (<span class="hljs-title class_">CustomerDao</span>) applicationContext.<span class="hljs-title function_">getBean</span>(<span class="hljs-string">&quot;customerDao&quot;</span>);<br>        customerBean.<span class="hljs-title function_">add</span>();<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>执行结果</strong></p><p><img src="05.png" alt="05"></p><h6 id="基于Annotation的声明式"><a href="#基于Annotation的声明式" class="headerlink" title="基于Annotation的声明式"></a>基于Annotation的声明式</h6><p><strong>AspectJ允许使用注解定义切面、切入点和增强处理，而Spring框架可以识别并根据注解生成AOP代理</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>@Aspect</td><td>用于定义一个切面</td></tr><tr><td>@Before</td><td>用于定义前置通知，相当于BeforeAdvice</td></tr><tr><td>@AfterReturning</td><td>用于定义后置通知，相当于AfterReturningAdvice</td></tr><tr><td>@Around</td><td>用于定义环绕通知，相当于MethodInterceptor</td></tr><tr><td>@AfterThrowing</td><td>用于定义抛出异常，相当于ThrowAdvice</td></tr><tr><td>@After</td><td>用于定义最终final通知，不管是否异常，该通知都会执行</td></tr><tr><td>DeclareParents</td><td>用于定义引介通知，相当于IntroductionInterceptor</td></tr></tbody></table><h6 id="开发案例"><a href="#开发案例" class="headerlink" title="开发案例"></a>开发案例</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//创建切面类</span><br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">JoinPoint</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">ProceedingJoinPoint</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">After</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">AfterReturning</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">AfterThrowing</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Around</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Aspect</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Before</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">aspectj</span>.<span class="hljs-property">lang</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Pointcut</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Component</span>;<br><span class="hljs-comment">//切面类</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>    <span class="hljs-comment">// 用于取代：&lt;aop:pointcut</span><br>    <span class="hljs-comment">// expression=&quot;execution(*com.mengma.dao..*.*(..))&quot; id=&quot;myPointCut&quot;/&gt;</span><br>    <span class="hljs-comment">// 要求：方法必须是private，没有值，名称自定义，没有参数</span><br>    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">&quot;execution(*com.mengma.dao..*.*(..))&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myPointCut</span>(<span class="hljs-params"></span>) &#123;<br>    &#125;<br>    <span class="hljs-comment">// 前置通知</span><br>    <span class="hljs-meta">@Before</span>(<span class="hljs-string">&quot;myPointCut()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myBefore</span>(<span class="hljs-params">JoinPoint joinPoint</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;前置通知，目标：&quot;</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(joinPoint.<span class="hljs-title function_">getTarget</span>() + <span class="hljs-string">&quot;方法名称:&quot;</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(joinPoint.<span class="hljs-title function_">getSignature</span>().<span class="hljs-title function_">getName</span>());<br>    &#125;<br>    <span class="hljs-comment">// 后置通知</span><br>    <span class="hljs-meta">@AfterReturning</span>(value = <span class="hljs-string">&quot;myPointCut()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myAfterReturning</span>(<span class="hljs-params">JoinPoint joinPoint</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;后置通知，方法名称：&quot;</span> + joinPoint.<span class="hljs-title function_">getSignature</span>().<span class="hljs-title function_">getName</span>());<br>    &#125;<br>    <span class="hljs-comment">// 环绕通知</span><br>    <span class="hljs-meta">@Around</span>(<span class="hljs-string">&quot;myPointCut()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">myAround</span>(<span class="hljs-title class_">ProceedingJoinPoint</span> proceedingJoinPoint)<br>            throws <span class="hljs-title class_">Throwable</span> &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;环绕开始&quot;</span>); <span class="hljs-comment">// 开始</span><br>        <span class="hljs-title class_">Object</span> obj = proceedingJoinPoint.<span class="hljs-title function_">proceed</span>(); <span class="hljs-comment">// 执行当前目标方法</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;环绕结束&quot;</span>); <span class="hljs-comment">// 结束</span><br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <span class="hljs-comment">// 异常通知</span><br>    <span class="hljs-meta">@AfterThrowing</span>(value = <span class="hljs-string">&quot;myPointCut()&quot;</span>, throwing = <span class="hljs-string">&quot;e&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myAfterThrowing</span>(<span class="hljs-params">JoinPoint joinPoint, Throwable e</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;异常通知&quot;</span> + <span class="hljs-string">&quot;出错了&quot;</span> + e.<span class="hljs-title function_">getMessage</span>());<br>    &#125;<br>    <span class="hljs-comment">// 最终通知</span><br>    <span class="hljs-meta">@After</span>(<span class="hljs-string">&quot;myPointCut()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">myAfter</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;最终通知&quot;</span>);<br>    &#125;<br>&#125;<br>复制代码<br><span class="hljs-comment">//在CustomerDaoImpl目标类中添加注解@Repository(&quot;customerDao&quot;)</span><br>复制代码<br><span class="hljs-comment">//创建ApplicationContext.xml文件</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/aop</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/context</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--扫描含com.mengma包下的所有注解--&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.mengma&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 使切面开启自动代理 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br>复制代码<br>/。创建测试类<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">testAspectJForAnnottion</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">ApplicationContext</span> applicationContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);<br>        <span class="hljs-title class_">CustomerDao</span> customerDao = (<span class="hljs-title class_">CustomerDao</span>) applicationContext.<span class="hljs-title function_">getBean</span>(<span class="hljs-string">&quot;customerDao&quot;</span>);<br>        customerDao.<span class="hljs-title function_">add</span>();<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>执行结果</strong></p><p><img src="06.png" alt="06"></p><h3 id="Spring-JDBCTemplate"><a href="#Spring-JDBCTemplate" class="headerlink" title="Spring JDBCTemplate"></a>Spring JDBCTemplate</h3><h4 id="Spring-JDBCTemplate概述"><a href="#Spring-JDBCTemplate概述" class="headerlink" title="Spring JDBCTemplate概述"></a>Spring JDBCTemplate概述</h4><ul><li>Spring框架针对数据库开发中的应用提供了JDBCTemplate类，该类是Spring对JDBC支持的核心，提供了对所有数据库操作功能的支持。</li><li>Spring框架提供的JDBC支持主要由四个包组成，分别是core(核心包)、object(对象包)、dataSource(数据源包)和support(支持包)，JdbcTemplate类在核心包中，作为Spring JDBC的核心，JdbcTemplate类包含了所有数据库操作的基本方法。</li><li>JdbcTemplate类继承自抽象类JdbcAccessor，同时实现了JdbcOperations接口，直接父类JdbcAccessor为子类提供了一些访问数据库时使用的公共属性</li></ul><h4 id="JdbcAccessor提供的公共属性"><a href="#JdbcAccessor提供的公共属性" class="headerlink" title="JdbcAccessor提供的公共属性"></a>JdbcAccessor提供的公共属性</h4><ul><li>DataSource：获取数据库连接，具体实现时还可以引入对数据库连接的缓冲池和分布式事务的支持，它可以作为访问数据库资源的标准接口</li><li>SQLExceptionTranslator：SQLExceptiontranslator接口负责对SQLException进行转译工作，通过必要的设置或者获取SQLExceptionTranslator中的方法，可以使JdbcTemplate在需要处理SQLException时，委托SQLExceptionTranslator的实现类完成相关的转译工作。</li><li>JdbcOperations接口定义了在JdbcTemplate类中可以使用的操作集合，包括添加、修改、查询和删除工作</li></ul><h4 id="Spring中JDBC的相关配置"><a href="#Spring中JDBC的相关配置" class="headerlink" title="Spring中JDBC的相关配置"></a>Spring中JDBC的相关配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http:/www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span> <br>   <br>    <span class="hljs-comment">&lt;!-- 配置数据源 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.dataSource.DriverManagerDataSource&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库驱动--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span> <br>        <span class="hljs-comment">&lt;!--连接数据库的url--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>= <span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost/spring&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!--连接数据库的用户名--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!--连接数据库的密码--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置JDBC模板--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.jdbcTemplate&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--默认必须使用数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置注入类--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><h4 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h4><p><strong>Spring的事务管理是基于AOP实现的，而AOP是以方法为单位的，Spring的事务属性分别为传播行为、隔离界别、只读和超时属性，这些属性提供了事务的方法和描述策略</strong></p><h6 id="Spring事务管理的三个核心接口"><a href="#Spring事务管理的三个核心接口" class="headerlink" title="Spring事务管理的三个核心接口"></a>Spring事务管理的三个核心接口</h6><ul><li>PlatformTransactionManager：Spring提供的平台事务管理器，用于管理事务，提供了三个方法：getTransaction用于获取事务状态信息，commit用于提交事务，rollback用于事务的回滚，在项目中，Spring将xml中配置的事务详细信息封装到对象TransactionDefinition中，然后通过事务管理器的getTransaction方法获取事务的状态(TransactionStatus)，并对事务进行下一步的操作</li><li>TransactionDefinition接口是事务定义的接口，提供了获取事务相关信息的方法</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>getName</td><td>获取事务对象名称</td></tr><tr><td>getIsolationLevel</td><td>获取事务的隔离级别</td></tr><tr><td>getPropagationBehavior</td><td>获取事务的传播行为</td></tr><tr><td>getTimeout</td><td>获取事务的超时时间</td></tr><tr><td>isReadOnly</td><td>获取事务是否只读</td></tr></tbody></table><p><strong>事务的传播行为是指在同一个方法中，不同操作前后所使用的事务</strong></p><table><thead><tr><th>属性名称</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>required</td><td>支持当前事务。如果 A 方法已经在事务中，则 B 事务将直接使用。否则将创建新事务</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>supports</td><td>支持当前事务。如果 A 方法已经在事务中，则 B 事务将直接使用。否则将以非事务状态执行</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>mandatory</td><td>支持当前事务。如果 A 方法没有事务，则抛出异常</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>requires_new</td><td>将创建新的事务，如果 A 方法已经在事务中，则将 A 事务挂起</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>not_supported</td><td>不支持当前事务，总是以非事务状态执行。如果 A 方法已经在事务中，则将其挂起</td></tr><tr><td>PROPAGATION_NEVER</td><td>never</td><td>不支持当前事务，如果 A 方法在事务中，则抛出异常</td></tr><tr><td>PROPAGATION.NESTED</td><td>nested</td><td>嵌套事务，底层将使用 Savepoint 形成嵌套事务</td></tr></tbody></table><p><strong>在事务管理过程中，传播行为可以控制是否需要创建事务以及如何创建事务，通常情况下，数据的查询不会改变事务的传播行为，所以不需要进行事务管理，而对于数据的增加、修改和删除等操作，必须进行事务管理，如果没有指定事务的传播行为，Spring默认的传播行为是required。</strong></p><ul><li>TransactionStatus，描述事务的状态，它描述了某一时间点上事务的状态信息，包含六个操作</li></ul><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>flush</td><td>刷新事务</td></tr><tr><td>hasSavepoint</td><td>获取事务是否在保存点</td></tr><tr><td>isCompleted</td><td>获取事务是否完成</td></tr><tr><td>isNewTransaction</td><td>获取是否是新事务</td></tr><tr><td>isRollbackOnly</td><td>获取是否回滚</td></tr><tr><td>setRollbackonly</td><td>设置事务回滚</td></tr></tbody></table><h5 id="Spring的事务管理由两种方式"><a href="#Spring的事务管理由两种方式" class="headerlink" title="Spring的事务管理由两种方式"></a>Spring的事务管理由两种方式</h5><ul><li>传统的编程式事务管理，通过编写代码实现的事务管理</li><li>基于AOP技术实现声明式的事务</li></ul><h5 id="基于AOP的声明式事务的实现方式"><a href="#基于AOP的声明式事务的实现方式" class="headerlink" title="基于AOP的声明式事务的实现方式"></a>基于AOP的声明式事务的实现方式</h5><ul><li>基于XML方式的声明式事务</li><li>通过Annotation注解方式的事务管理</li></ul><h4 id="基于XML方式的声明式事务"><a href="#基于XML方式的声明式事务" class="headerlink" title="基于XML方式的声明式事务"></a>基于XML方式的声明式事务</h4><p><strong>以银行转帐为例展示Spring的声明式事务</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//新建一个数据库<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> spring;<br>USE spring;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> account (<br>    id <span class="hljs-type">INT</span> (<span class="hljs-number">11</span>) <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-type">money</span> <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> account <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> account <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-number">1000</span>);<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="07.png" alt="07"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//创建 c3p0-db.properties</span><br>jdbc.<span class="hljs-property">driverClass</span> = com.<span class="hljs-property">mysql</span>.<span class="hljs-property">jdbc</span>.<span class="hljs-property">Driver</span><br>jdbc.<span class="hljs-property">jdbcUrl</span> = <span class="hljs-attr">jdbc</span>:<span class="hljs-attr">mysql</span>:<span class="hljs-comment">//localhost:3306/spring</span><br>jdbc.<span class="hljs-property">user</span> = root<br>jdbc.<span class="hljs-property">password</span> = root<br>复制代码<br><span class="hljs-comment">//实现 DAO</span><br><span class="hljs-comment">//创建 AccountDao 接口</span><br><span class="hljs-comment">//创建一个名为 com.mengma.dao 的包，在该包下创建一个接口 AccountDao</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountDao</span> &#123;<br>    <span class="hljs-comment">// 汇款</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">out</span>(<span class="hljs-title class_">String</span> outUser, int money);<br>    <span class="hljs-comment">// 收款</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">in</span>(<span class="hljs-title class_">String</span> inUser, int money);<br>&#125;<br><span class="hljs-comment">//创建DAO层接口实现类</span><br><span class="hljs-comment">//创建一个名为 com.mengma.dao.impl 的包，在该包下创建实现类 AccountDaoImpl</span><br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">jdbc</span>.<span class="hljs-property">core</span>.<span class="hljs-property">JdbcTemplate</span>;<br><span class="hljs-keyword">import</span> com.<span class="hljs-property">mengma</span>.<span class="hljs-property">dao</span>.<span class="hljs-property">AccountDao</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountDao</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">JdbcTemplate</span> jdbcTemplate;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setJdbcTemplate</span>(<span class="hljs-params">JdbcTemplate jdbcTemplate</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">jdbcTemplate</span> = jdbcTemplate;<br>    &#125;<br>    <span class="hljs-comment">// 汇款的实现方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">out</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> outUser, int money</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">jdbcTemplate</span>.<span class="hljs-title function_">update</span>(<span class="hljs-string">&quot;update account set money =money-?   where username =?&quot;</span>, money, outUser);<br>    &#125;<br>    <span class="hljs-comment">// 收款的实现方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">in</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> inUser, int money</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">jdbcTemplate</span>.<span class="hljs-title function_">update</span>(<span class="hljs-string">&quot;update account set money =money+?     where username =?&quot;</span>, money, inUser);<br>    &#125;<br>&#125;<br>复制代码<br><span class="hljs-comment">//实现 Service</span><br><span class="hljs-comment">//创建 Service 层接口</span><br><span class="hljs-comment">//创建一个名为 com.mengma.service 的包，在该包下创建接口 AccountService</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountService</span> &#123;<br>    <span class="hljs-comment">// 转账</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-title class_">String</span> outUser, <span class="hljs-title class_">String</span> inUser, int money);<br>&#125;<br><span class="hljs-comment">//创建 Service 层接口实现类</span><br><span class="hljs-comment">//创建一个名为 com.mengma.service.impl 的包，在该包下创建实现类AccountServiceImpl</span><br><br><span class="hljs-keyword">import</span> com.<span class="hljs-property">mengma</span>.<span class="hljs-property">dao</span>.<span class="hljs-property">AccountDao</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">AccountDao</span> accountDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAccountDao</span>(<span class="hljs-params">AccountDao accountDao</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">accountDao</span> = accountDao;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> outUser, <span class="hljs-built_in">String</span> inUser, int money</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">accountDao</span>.<span class="hljs-title function_">out</span>(outUser, money);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">accountDao</span>.<span class="hljs-title function_">in</span>(inUser, money);<br>    &#125;<br>&#125;<br>复制代码<br><span class="hljs-comment">//创建 Spring 配置文件</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/context</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/tx</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/aop</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 加载properties文件 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:c3p0-db.properties&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 配置数据源，读取properties文件信息 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.jdbcUrl&#125;&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.user&#125;&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 配置jdbc模板 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 配置dao --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 配置service --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mengma.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;accountDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;accountDao&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 事务管理器，依赖于数据源 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txManager&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 编写通知：对事务进行增强（通知），需要编写切入点和具体执行事务的细节 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，propagation用于设置传播行为，read-only表示隔离级别，是否只读 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;find*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;Exception&quot;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">&quot;DEFAULT&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 切入点 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.mengma.service.*.*(..))&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txPointCut&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 切面：将切入点与通知整合 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;txPointCut&quot;</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br>复制代码<br><span class="hljs-comment">// 创建测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 获得Spring容器，并操作</span><br>        <span class="hljs-title class_">String</span> xmlPath = <span class="hljs-string">&quot;applicationContext.xml&quot;</span>;<br>        <span class="hljs-title class_">ApplicationContext</span> applicationContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<br>                xmlPath);<br>        <span class="hljs-title class_">AccountService</span> accountService = (<span class="hljs-title class_">AccountService</span>) applicationContext<br>                .<span class="hljs-title function_">getBean</span>(<span class="hljs-string">&quot;accountService&quot;</span>);<br>        accountService.<span class="hljs-title function_">transfer</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>执行结果</strong></p><p><img src="08.png" alt="08"></p><p><strong>模拟转账失败</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//将transfer方法修改为如下</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(<span class="hljs-type">String</span> outUser, <span class="hljs-type">String</span> inUser, <span class="hljs-type">int</span> money)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.accountDao.<span class="hljs-built_in">out</span>(outUser, money);<br>    <span class="hljs-comment">//模拟断电</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>.accountDao.<span class="hljs-built_in">in</span>(inUser, money);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>执行结果</strong></p><p><img src="09.png" alt="09"></p><p><strong>由此可知，表中数据并没有发生改变，则表示事务不能正常提交，Spring事务管理生效</strong></p><h4 id="基于Annotation实现声明式事务"><a href="#基于Annotation实现声明式事务" class="headerlink" title="基于Annotation实现声明式事务"></a>基于Annotation实现声明式事务</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//修改applicationContext.xml</span><br><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/context</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/tx</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">            &quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 加载properties文件 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:c3p0-db.properties&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--扫描含com.mengma包下的所有注解--&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.mengma&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 配置数据源，读取properties文件信息 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.jdbcUrl&#125;&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 配置jdbc模板 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 事务管理器，依赖于数据源 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txManager&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 注册事务管理驱动 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;txManager&quot;</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br>复制代码<br><span class="hljs-comment">//加注解</span><br><span class="hljs-keyword">import</span> com.<span class="hljs-property">mengma</span>.<span class="hljs-property">dao</span>.<span class="hljs-property">AccountDao</span>;<br><span class="hljs-keyword">import</span> com.<span class="hljs-property">mengma</span>.<span class="hljs-property">service</span>.<span class="hljs-property">AccountService</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Autowired</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Service</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">transaction</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Isolation</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">transaction</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Propagation</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">transaction</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Transactional</span>;<br><span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRED</span>, isolation = <span class="hljs-title class_">Isolation</span>.<span class="hljs-property">DEFAULT</span>, readOnly = <span class="hljs-literal">false</span>)<br><span class="hljs-meta">@Service</span>(<span class="hljs-string">&quot;accountService&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">AccountDao</span> accountDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAccountDao</span>(<span class="hljs-params">AccountDao accountDao</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">accountDao</span> = accountDao;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> outUser, <span class="hljs-built_in">String</span> inUser, int money</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">accountDao</span>.<span class="hljs-title function_">out</span>(outUser, money);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">accountDao</span>.<span class="hljs-title function_">in</span>(inUser, money);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Autowired</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">jdbc</span>.<span class="hljs-property">core</span>.<span class="hljs-property">JdbcTemplate</span>;<br><span class="hljs-keyword">import</span> com.<span class="hljs-property">mengma</span>.<span class="hljs-property">dao</span>.<span class="hljs-property">AccountDao</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Repository</span>;<br><span class="hljs-keyword">import</span> javax.<span class="hljs-property">annotation</span>.<span class="hljs-property">Resource</span>;<br><span class="hljs-meta">@Repository</span>(<span class="hljs-string">&quot;accountDao&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountDao</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">JdbcTemplate</span> jdbcTemplate;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setJdbcTemplate</span>(<span class="hljs-params">JdbcTemplate jdbcTemplate</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">jdbcTemplate</span> = jdbcTemplate;<br>    &#125;<br>    <span class="hljs-comment">// 汇款的实现方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">out</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> outUser, int money</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">jdbcTemplate</span>.<span class="hljs-title function_">update</span>(<span class="hljs-string">&quot;update account set money =money-? where username =?&quot;</span>, money, outUser);<br>    &#125;<br>    <span class="hljs-comment">// 收款的实现方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">in</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> inUser, int money</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">jdbcTemplate</span>.<span class="hljs-title function_">update</span>(<span class="hljs-string">&quot;update account set money =money+? where username =?&quot;</span>, money, inUser);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>执行结果和使用XML实现结果相同</strong></p>]]></content>
    
    
    <categories>
      
      <category>java面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>那些关于Autowired你可能不知道的事</title>
    <link href="/2022/03/23/%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8EAutowired%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <url>/2022/03/23/%E9%82%A3%E4%BA%9B%E5%85%B3%E4%BA%8EAutowired%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="那些关于Autowired你可能不知道的事"><a href="#那些关于Autowired你可能不知道的事" class="headerlink" title="那些关于Autowired你可能不知道的事"></a>那些关于Autowired你可能不知道的事</h1><h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TalkService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">talk</span><span class="hljs-params">(String content)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(value = &quot;withSisterTalkService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WithSisterTalkService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TalkService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">talk</span><span class="hljs-params">(String content)</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.getClass().getName() + <span class="hljs-string">&quot;:&quot;</span> + content);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(value = &quot;withGirlFriendTalkService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WithGirlFriendTalkService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TalkService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">talk</span><span class="hljs-params">(String content)</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.getClass().getName() + <span class="hljs-string">&quot;:&quot;</span> + content);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TalkServiceStrategyContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TalkService</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> Map&lt;String, TalkService&gt; strategyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TalkServiceStrategyContext</span><span class="hljs-params">(Map&lt;String, TalkService&gt; strategyMap)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategyMap.clear();<br>        <span class="hljs-built_in">this</span>.strategyMap.putAll(strategyMap);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">talk</span><span class="hljs-params">(String content)</span> &#123;<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Map&lt;String, TalkService&gt; talkServiceMap;<br> <br><span class="hljs-meta">@GetMapping(value = &quot;doTest&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doTest</span><span class="hljs-params">()</span> &#123;<br>    Set&lt;String&gt; strings = talkServiceMap.keySet();<br>    <span class="hljs-keyword">for</span> (String string : strings) &#123;<br>        System.out.println(string + <span class="hljs-string">&quot;:&quot;</span> + talkServiceMap.get(string).toString());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getClass().getName();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其访问测试controller后，打印的信息如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">talkServiceStrategyContext:com.haiyang.onlinejava.complier.service.impl.TalkServiceStrategyContext@2f0b1419<br>withGirlFriendTalkService:com.haiyang.onlinejava.complier.service.impl.WithGirlFriendTalkService@1cf19a02<br>withSisterTalkService:com.haiyang.onlinejava.complier.service.impl.WithSisterTalkService@1ef3c76d<br></code></pre></td></tr></table></figure><p><strong>看了后感觉很奇怪，在上方只定义了一个map&lt;String,TalkService&gt;的map,居然它就能自动找到实现了TalkService的所有bean,并将service的beanName作为了key，感觉还是牛逼啊，spring的注解居然还能这样用。</strong></p><p><strong>然后简单看了下Autowired的源码，其javaDoc文档里也有说明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.annotation;<br> <br><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Marks a constructor, field, setter method or config method as to be</span><br><span class="hljs-comment"> * autowired by Spring&#x27;s dependency injection facilities.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Only one constructor (at max) of any given bean class may carry this</span><br><span class="hljs-comment"> * annotation, indicating the constructor to autowire when used as a Spring</span><br><span class="hljs-comment"> * bean. Such a constructor does not have to be public.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Fields are injected right after construction of a bean, before any</span><br><span class="hljs-comment"> * config methods are invoked. Such a config field does not have to be public.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Config methods may have an arbitrary name and any number of arguments;</span><br><span class="hljs-comment"> * each of those arguments will be autowired with a matching bean in the</span><br><span class="hljs-comment"> * Spring container. Bean property setter methods are effectively just</span><br><span class="hljs-comment"> * a special case of such a general config method. Such config methods</span><br><span class="hljs-comment"> * do not have to be public.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;In the case of multiple argument methods, the &#x27;required&#x27; parameter is</span><br><span class="hljs-comment"> * applicable for all arguments.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;In case of a &#123;<span class="hljs-doctag">@link</span> java.util.Collection&#125; or &#123;<span class="hljs-doctag">@link</span> java.util.Map&#125;</span><br><span class="hljs-comment"> * dependency type, the container will autowire all beans matching the</span><br><span class="hljs-comment"> * declared value type. In case of a Map, the keys must be declared as</span><br><span class="hljs-comment"> * type String and will be resolved to the corresponding bean names.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Note that actual injection is performed through a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor</span><br><span class="hljs-comment"> * BeanPostProcessor&#125; which in turn means that you &lt;em&gt;cannot&lt;/em&gt;</span><br><span class="hljs-comment"> * use &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Autowired</span>&#125; to inject references into</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor</span><br><span class="hljs-comment"> * BeanPostProcessor&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor&#125;</span><br><span class="hljs-comment"> * types. Please consult the javadoc for the &#123;<span class="hljs-doctag">@link</span> AutowiredAnnotationBeanPostProcessor&#125;</span><br><span class="hljs-comment"> * class (which, by default, checks for the presence of this annotation).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Juergen Hoeller</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mark Fisher</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2.5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> AutowiredAnnotationBeanPostProcessor</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Qualifier</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Autowired &#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Declares whether the annotated dependency is required.</span><br><span class="hljs-comment"> * &lt;p&gt;Defaults to &#123;<span class="hljs-doctag">@code</span> true&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关注这句：</strong></p><p><strong>In case of a java.util.Collection or java.util.Map dependency type, the container will autowire all beans matching the declared value type. In case of a Map, the keys must be declared as type String and will be resolved to the corresponding bean names.</strong></p><p><strong>读不懂没关系，翻译一下</strong></p><p><strong>对于java.util.Collection或java.util.Map依赖类型，容器将自动装配所有与声明的值类型匹配的bean。对于Map，键必须声明为String类型，并解析为相应的bean名称。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>它大致是说Autowired当使用在Collection里时，会将所申明类的所有实现类都放在那个指定的Collection里；如果Autowired和map使用的话呢，它将它bean的名称作为key,所有的bean作为value.</strong></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个被困扰了一天的问题</title>
    <link href="/2022/03/17/%E4%B8%80%E4%B8%AA%E8%A2%AB%E5%9B%B0%E6%89%B0%E4%BA%86%E4%B8%80%E5%A4%A9%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/17/%E4%B8%80%E4%B8%AA%E8%A2%AB%E5%9B%B0%E6%89%B0%E4%BA%86%E4%B8%80%E5%A4%A9%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们公司是做金融系统的，我现在在做的呢是数据平台补录，就是一些简单的增删改查。然后呢这周的开发任务是配置导入导出功能，重点来了！！ 这是我最想吐槽的。这里的导入导出跟你们想的用一个excel注解不一样，正常开发是</p><ol><li>用一个excel注解</li><li>文件上传</li><li>工具类将excel转换成一个对象数组</li><li>对数据库进行操作</li></ol><p><strong>我们公司的神操作来了！！！前方高能！！！！</strong></p><p>我们公司的操作是</p><ol><li>在数据库文件模板表里面加一条记录字段包括你要导入的excel的模板的一些元数据</li><li>配置导入文字字段详情，就是excel表和数据库表的对应关系</li><li>配置导出文件字段的对应关系</li></ol><p>有人可能要说了，这看着也没啥问题啊0..0</p><p><strong>问题来了</strong></p><p>一般的一张表几十个字段，多个要上百个字段，那要插到啥时候。。。。。当场裂开开。</p><p>我昨天就是在做这个事，，，，</p><p>插了一百多条记录，真的是眼睛都要瞎了0..0</p><p><strong>当然，肯定不会让你这么轻松的就搞完的</strong></p><p>不出所料，我成功的插错了两条记录。。。。错把两条非主键字段设置为了主键字段，导致在插入的时候主键重复差不进去。这个问题我过了好久才发现，昨天晚上搞到十二点。</p><blockquote><p>那为什么我会那么久没发现这个问题呢？</p></blockquote><p><strong>系统的日志不详细！！！</strong></p><p>我反复查看了后端日志信息，没有一条报错信息，就很离谱，唯一的一条就是说“总条数1；失败条数：1”</p><p>我裂开，没有报错原因，没有异常。。。。。</p><p><strong>从这里看出，一个系统有一个完整日志的重要性啊！！！！</strong></p>]]></content>
    
    
    <categories>
      
      <category>开发中遇到的各种神BUG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>令人脑瓜子嗡嗡的BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/03/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><p>软件工程中，设计模式是对软件设计中普遍存在反复出现的各种问题，<strong>所提出的解决方案</strong>。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p><h2 id="设计模式常用的七大原则"><a href="#设计模式常用的七大原则" class="headerlink" title="设计模式常用的七大原则"></a>设计模式常用的七大原则</h2><ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转原则</li><li>里氏替换原则</li><li>开闭原则OCP</li><li>迪米特原则</li><li>合成复用原则</li></ol><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ol><li>降低类的复杂度，一个类只负责一项职责</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应该遵循单一职责原则，只有逻辑足够简单才可以在代码级违反单一职责原则；只有类中的方法数量足够少才可以在方法级别保持单一职责原则。</li></ol><h2 id="创造者模式"><a href="#创造者模式" class="headerlink" title="创造者模式"></a>创造者模式</h2><p>创造者模式的关注点是如何创造对象，其核心思想是要把对象的使用和创建分离，这样使得两者可以独立的变换。</p><h3 id="创造者模式包括"><a href="#创造者模式包括" class="headerlink" title="创造者模式包括"></a>创造者模式包括</h3><ul><li>工厂方法 Factory Method</li><li>抽象工厂 Abstarct Factory</li><li>建造者 Builder</li><li>原型 Prototype</li><li>单例 Singleton</li></ul>]]></content>
    
    
    <categories>
      
      <category>java高阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>若依如何实现的数据范围过滤</title>
    <link href="/2022/03/13/%E8%8B%A5%E4%BE%9D%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E8%BF%87%E6%BB%A4/"/>
    <url>/2022/03/13/%E8%8B%A5%E4%BE%9D%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E8%BF%87%E6%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>/**</p><ul><li><p>数据过滤处理</p></li><li></li><li><p>@author sj</p></li><li><p>/<br>@Aspect<br>@Component<br>public class DataScopeAspect<br>{<br>  /**</p><ul><li>全部数据权限</li><li>/<br>public static final String DATA_SCOPE_ALL = “1”;</li></ul><p>  /**</p><ul><li>自定数据权限</li><li>/<br>public static final String DATA_SCOPE_CUSTOM = “2”;</li></ul><p>  /**</p><ul><li>部门数据权限</li><li>/<br>public static final String DATA_SCOPE_DEPT = “3”;</li></ul><p>  /**</p><ul><li>部门及以下数据权限</li><li>/<br>public static final String DATA_SCOPE_DEPT_AND_CHILD = “4”;</li></ul><p>  /**</p><ul><li>仅本人数据权限</li><li>/<br>public static final String DATA_SCOPE_SELF = “5”;</li></ul><p>  /**</p><ul><li>数据权限过滤关键字</li><li>/<br>public static final String DATA_SCOPE = “dataScope”;</li></ul><p>  // 配置织入点<br>  @Pointcut(“@annotation(com.sj.common.annotation.DataScope)”)<br>  public void dataScopePointCut()<br>  {<br>  }<br>  // 在织入点之前进行织入<br>  @Before(“dataScopePointCut()”)<br>  public void doBefore(JoinPoint point) throws Throwable<br>  {</p><div class="code-wrapper"><pre><code class="hljs">  // 在织入点之前执行，根据当前登录的用户判断是否数据权限过滤  handleDataScope(point);</code></pre></div><p>  }</p><p>  protected void handleDataScope(final JoinPoint joinPoint)<br>  {</p><div class="code-wrapper"><pre><code class="hljs">  // 获得注解  DataScope controllerDataScope = getAnnotationLog(joinPoint);  if (controllerDataScope == null)  &#123;      return;  &#125;  // 获取当前的用户  LoginUser loginUser = SpringUtils.getBean(TokenService.class).getLoginUser(ServletUtils.getRequest());  if (StringUtils.isNotNull(loginUser))  &#123;      SysUser currentUser = loginUser.getUser();      // 如果当前登录的用户不是管理员那就进行数据范围过滤      if (StringUtils.isNotNull(currentUser) &amp;&amp; !currentUser.isAdmin())      &#123;          dataScopeFilter(joinPoint, currentUser, controllerDataScope.deptAlias(),                  controllerDataScope.userAlias());      &#125;  &#125;</code></pre></div><p>  }</p><p>  /**</p><ul><li>数据范围过滤</li><li></li><li>@param joinPoint 切点</li><li>@param user 用户</li><li>@param userAlias 别名</li><li>/<br>public static void dataScopeFilter(JoinPoint joinPoint, SysUser user, String deptAlias, String userAlias)<br>{<br>  // 构建字符串<br>  StringBuilder sqlString = new StringBuilder();<br>  // 遍历角色，一个用户可以有多个角色<br>  for (SysRole role : user.getRoles())<br>  {<div class="code-wrapper"><pre><code class="hljs">  // 获取到数据权限范围  String dataScope = role.getDataScope();  // 如果是全部数据权限则不需要构造拼接字符串  if (DATA_SCOPE_ALL.equals(dataScope))  &#123;      sqlString = new StringBuilder();      break;  &#125;  else if (DATA_SCOPE_CUSTOM.equals(dataScope))  &#123;      sqlString.append(StringUtils.format(              &quot; OR &#123;&#125;.dept_id IN ( SELECT dept_id FROM sys_role_dept WHERE role_id = &#123;&#125; ) &quot;, deptAlias,              role.getRoleId()));  &#125;  // 本部门的数据  else if (DATA_SCOPE_DEPT.equals(dataScope))  &#123;      sqlString.append(StringUtils.format(&quot; OR &#123;&#125;.dept_id = &#123;&#125; &quot;, deptAlias, user.getDeptId()));  &#125;  // 本部门及本部门以下  else if (DATA_SCOPE_DEPT_AND_CHILD.equals(dataScope))  &#123;      // dept_id等于本本部门的id或者dept_id在祖级列表里面      sqlString.append(StringUtils.format(              &quot; OR &#123;&#125;.dept_id IN ( SELECT dept_id FROM sys_dept WHERE dept_id = &#123;&#125; or find_in_set( &#123;&#125; , ancestors ) )&quot;,              deptAlias, user.getDeptId(), user.getDeptId()));  &#125;  else if (DATA_SCOPE_SELF.equals(dataScope))  &#123;      if (StringUtils.isNotBlank(userAlias))      &#123;          sqlString.append(StringUtils.format(&quot; OR &#123;&#125;.user_id = &#123;&#125; &quot;, userAlias, user.getUserId()));      &#125;      else      &#123;          // 数据权限为仅本人且没有userAlias别名不查询任何数据          sqlString.append(&quot; OR 1=0 &quot;);      &#125;  &#125;</code></pre></div>  }  // 将sqlString转换为String且当不为空时<br>  if (StringUtils.isNotBlank(sqlString.toString()))<br>  {<div class="code-wrapper"><pre><code class="hljs">  // 获取连接点的参数，  Object params = joinPoint.getArgs()[0];  // 如果参数不为空并且是一个实体  if (StringUtils.isNotNull(params) &amp;&amp; params instanceof BaseEntity)  &#123;      // 将参数转换为实体      BaseEntity baseEntity = (BaseEntity) params;      // 将拼接的Sql语句放到参数列表      baseEntity.getParams().put(DATA_SCOPE, &quot; AND (&quot; + sqlString.substring(4) + &quot;)&quot;);  &#125;</code></pre></div>  }<br>}</li></ul><p>  /**</p><ul><li>是否存在注解，如果存在就获取</li><li>/<br>private DataScope getAnnotationLog(JoinPoint joinPoint)<br>{<br>  // 获取封装了签名信息的对象，在该对象中可以获取到目标方法名，所属类的class等信息<br>  Signature signature = joinPoint.getSignature();<br>  // 将签名对象转换为方法签名对象<br>  MethodSignature methodSignature = (MethodSignature) signature;<br>  // 获取到目标方法<br>  Method method = methodSignature.getMethod();<br>  // 如果目标方法不为空则返回目标方法上的注解<br>  if (method != null)<br>  {<div class="code-wrapper"><pre><code class="hljs">  return method.getAnnotation(DataScope.class);</code></pre></div>  }<br>  // 否则返回空<br>  return null;<br>}<br>}</li></ul></li></ul><p>// 作为前置知识需要了解角色管理页面中，可以配置下面几种数据范围<br> /**<br>     * 全部数据权限<br>     <em>/<br>    public static final String DATA_SCOPE_ALL = “1”;<br> /</em>*<br>     * 自定数据权限<br>     */<br>    public static final String DATA_SCOPE_CUSTOM = “2”;</p><p>查询 部门角色对应表中，用户具备的角色可以管理那些部门<br> OR d.dept_id IN ( SELECT dept_id FROM sys_role_dept WHERE role_id = {rolelist} )    </p><p>/**<br>     * 部门数据权限<br>     */<br>    public static final String DATA_SCOPE_DEPT = “3”;</p><p>查询部门编号=用户所在部门编号的数据<br>OR {}.dept_id = {}  </p><p>  /**<br>     * 部门及以下数据权限<br>     */<br>    public static final String DATA_SCOPE_DEPT_AND_CHILD = “4”;</p><p>查询部门和子部门的权限</p><div class="code-wrapper"><pre><code class="hljs">/** * 仅本人数据权限 */public static final String DATA_SCOPE_SELF = &quot;5&quot;;if (StringUtils.isNotBlank(userAlias))</code></pre></div><p>{<br>    sqlString.append(StringUtils.format(“ OR {}.user_id = {} “, userAlias, user.getUserId()));<br>}<br>else<br>{<br>    // 数据权限为仅本人且没有userAlias别名不查询任何数据<br>    sqlString.append(“ OR 1=0 “);<br>}</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringAop</title>
    <link href="/2022/03/13/SpringAop/"/>
    <url>/2022/03/13/SpringAop/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><blockquote><p>什么是AOP  </p></blockquote><p>AOP意为：面向切面编程，通过预编译和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是对OOP的一种延续。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务之间的耦合性降低，提高代码的重用性。</p><p><img src="D:\笔记\SpringBoot\SpringAOP原理\springAOP原理.assets\image-20210627110949962.png" alt="image-20210627110949962">  </p><blockquote><p>AOP在Spring中的作用</p></blockquote><p><strong>提供声明式事务；允许用户自定义切面</strong></p><p><strong>以下名词需要了解</strong></p><ul><li><p>横切关注点：跨越应用程序多个模块的方法或功能。即是与我们业务逻辑无关的，但是我们需要关注的部分就是横切点。如日志，安全，缓存，事务等。</p></li><li><p>切面： 横切关注点被模块化的特殊对象。他是一个类。</p></li><li><p>通知（advice）：切面必须要完成的工作。他是类中的一个方法。</p></li><li><p>目标（target）：被通知的对象。</p></li><li><p>代理（proxy）: 向目标应用通知之后创建的对象。</p></li><li><p>切入点（Point Cut）：切面通知执行的<code>地点</code>的定义。</p></li><li><p>连接点（JionPoint）：与切面点匹配的执行点。</p></li></ul><blockquote><p>使用Spring实现Aop</p></blockquote><p>  <strong>使用AOP织入，需要导入一个依赖包</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs xm">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;<br>&lt;dependency&gt;<br>   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;<br>   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;<br>   &lt;version&gt;1.9.4&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><ol><li><p><strong>通过SpringAPI实现</strong></p><p>首先编写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;增加用户&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;删除用户&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;更新用户&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;查询用户&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们写一个增强类，一个前置增强，一个后置强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br><br>   <span class="hljs-comment">//method : 要执行的目标对象的方法</span><br>   <span class="hljs-comment">//objects : 被调用的方法的参数</span><br>   <span class="hljs-comment">//Object : 目标对象</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>       System.out.println( o.getClass().getName() + <span class="hljs-string">&quot;的&quot;</span> + method.getName() + <span class="hljs-string">&quot;方法被执行了&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AfterReturningAdvice</span> &#123;<br>   <span class="hljs-comment">//returnValue 返回值</span><br>   <span class="hljs-comment">//method被调用的方法</span><br>   <span class="hljs-comment">//args 被调用的方法的对象的参数</span><br>   <span class="hljs-comment">//target 被调用的目标对象</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>       System.out.println(<span class="hljs-string">&quot;执行了&quot;</span> + target.getClass().getName()<br>       +<span class="hljs-string">&quot;的&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法,&quot;</span><br>       +<span class="hljs-string">&quot;返回值：&quot;</span>+returnValue);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后把我们写的增强类在spring的文件中注册，并实现AOP切入实现，注意导入约束：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--注册bean--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.service.UserServiceImpl&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.log.Log&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.log.AfterLog&quot;</span>/&gt;</span><br><br>   <span class="hljs-comment">&lt;!--aop的配置--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--切入点 告诉aop从哪里切入 expression:表达式匹配要执行的方法--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br>       <span class="hljs-comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>AOP就是把公共业务（日志，事务等）和领域业务结合起来，当执行领域业务的时候，把公共业务加进来。实现公共业务的重复利用，领域业务更加纯粹！其本质就是动态代理！</strong></p><ol><li><p><strong>自定义类来实现AOP</strong></p><p>目标业务不变依旧是userServiceIml</p><p>第一步写我们的切入类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiyPointcut</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行前---------&quot;</span>);<br>  &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行后---------&quot;</span>);<br>  &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>在spring中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第二种方式自定义实现--&gt;</span><br><span class="hljs-comment">&lt;!--注册bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.DiyPointcut&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--aop的配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;diy&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;diyPonitcut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>就是自己写一个切入类，切入类写好通知方法，把它注册为一个javabeen然后把它定义为一个切面，首先配置他的切入点，再配置通知advice，通知对用的method就是我们在切入类里面写的方法！</strong></p></li></ol></li><li><p>使用注解实现</p><p>编写一个注解实现的增强类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.config;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationPointcut</span> &#123;<br>   <span class="hljs-meta">@Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行前---------&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;---------方法执行后---------&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint jp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>       System.out.println(<span class="hljs-string">&quot;环绕前&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;签名:&quot;</span>+jp.getSignature());<br>       <span class="hljs-comment">//执行目标方法proceed</span><br>       <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> jp.proceed();<br>       System.out.println(<span class="hljs-string">&quot;环绕后&quot;</span>);<br>       System.out.println(proceed);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步：在spring配置文件中，注册bean 并增加支持注解的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第三种方式:注解实现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;annotationPointcut&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.config.AnnotationPointcut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>aop:aspectj-autoproxy说明</strong></p><p>通过aop命名空间的aop:aspectj-aotuproxy声明自动为spring容器中那些配置@aspectj切面的bean创建代理，组织切面。当然，spring内部依旧采用AnnotationAwareAspectjAotuProxyCreator进行自动代理的创建工作，但是具体实现的细节已经被aop:aspectj-autoproxy 隐藏起来了</p><p>aop：aspectj-autoproxy有一个pro-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配 为aop:aspectj-autoproxy proxy-target-class=true时，表示使用CGLIB动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标没有声明接口。则spring将自动使用cglib动态代理。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2022/03/13/Linux/"/>
    <url>/2022/03/13/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="直接上图片"><a href="#直接上图片" class="headerlink" title="直接上图片"></a>直接上图片</h1><p><img src="01_Linux%E5%9F%BA%E7%A1%80%E7%AF%87%E7%9F%A5%E8%AF%86.png" alt="01_Linux基础篇知识"><br><img src="02_%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4.png" alt="02_帮助命令"><br><img src="03_%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86.png" alt="03_文件与目录管理"><br><img src="04_%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%862.png" alt="04_文件与目录管理2"><br><img src="05_%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86.png" alt="05_权限管理"><br><img src="06_Vim%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="06_Vim文本编辑器"><br><img src="07_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE.png" alt="07_文件系统和文件查找"><br><img src="08_%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%861.png" alt="08_系统管理1"><br><img src="08_%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%862.png" alt="08_系统管理2"><br><img src="09_%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86-%E5%85%A8.png" alt="09_系统管理-全"><br><img src="10_%E7%A3%81%E7%9B%98%E3%80%81%E9%80%BB%E8%BE%91%E5%8D%B7%E5%92%8C%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D.png" alt="10_磁盘、逻辑卷和故障修复"><br><img src="11_%E8%AE%A4%E8%AF%86BASH%E5%92%8CShell%E5%91%BD%E4%BB%A4%E7%9B%B8%E5%85%B3.png" alt="11_认识BASH和Shell命令相关"><br><img src="12_Shell%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3.png" alt="12_Shell脚本操作相关"><br><img src="12_Shell%E5%BE%AA%E7%8E%AF%E6%93%8D%E4%BD%9C.png" alt="12_Shell循环操作"><br><img src="13_%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%AF%87.png" alt="13_文本操作篇"><br><img src="14_sed%E5%9F%BA%E7%A1%80.png" alt="14_sed基础"><br><img src="15_AWK.png" alt="15_AWK"> </p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reactor</title>
    <link href="/2022/03/13/Reactor/"/>
    <url>/2022/03/13/Reactor/</url>
    
    <content type="html"><![CDATA[<h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><p>reactive 是一种观察者模式的扩展    </p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>指多个对象间存在<strong>一对多的依赖关系</strong>，<strong>当一个对象的状态发生改变时，所有依赖他的对象都得到通知并被自动更新</strong>。这种模式有时又称作为发布-订阅者模式</p><h2 id="四种角色"><a href="#四种角色" class="headerlink" title="四种角色"></a>四种角色</h2><ol><li>Publisher: 发布者</li><li>Subscriber： 订阅者</li><li>Subscription：订阅的控制器</li><li>Processor：处理器</li></ol><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ol><li>onSubscribe(): 订阅事件</li><li>onNext(): 数据达到事件</li><li>onComplete(): 订阅完成事件</li><li>onError(): 订阅异常</li><li>request(): 请求</li><li>cancel（）：取消</li></ol><blockquote><p>Supplier Consumer Function</p></blockquote><ul><li>Supplier 只出不进</li><li>Consumer 只进不出</li><li>Function 又进又出</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><blockquote><p>map</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reactorMapTest</span><span class="hljs-params">()</span>&#123;<br>        StepVerifier.create(Flux.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>                .map(v-&gt;v+<span class="hljs-number">1</span>))<br>                .expectNext(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>                .expectComplete()<br>                .verify();<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里的map就是对每一个元素进行加一操作，用于元素的转换</p><blockquote><p>flatmap</p></blockquote><p>flatmap也是对元素的转换但是不同的是，flatmap是将元素转换为流，再将流合并为一个大的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reactorFlatMapTest</span><span class="hljs-params">()</span>&#123;<br>       StepVerifier.create(Flux.just(<span class="hljs-string">&quot;crabman&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;hero&quot;</span>)<br>               .flatMap(v-&gt;Flux.fromArray(v.split(<span class="hljs-string">&quot;&quot;</span>)))<br>               .doOnNext(System.out::println))<br>               .expectNextCount(<span class="hljs-number">13</span>)<br>               .verifyComplete();<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p>tips: flatmap和map 的区别</p></blockquote><p>map就是一个function函数，输入一个输出一个，对于flatmap来说他接受的是一个输出为Publisher的function，也就是说他输入一个值，输出的是一个Publisher的function，所以map是一对一的关系，而flatmap是一对多或者多对多的关系，并且两者输出的也不一样。flatmap的应用场景，例如一个接口，入参是List<id> 用户id合集，需求是返回每个id对应的具体的信息，所以代码就是这样的 a.flatmap( id -&gt; id.getUserInfo(id))</p><ul><li>map 接受Function &lt;T，U&gt;并返回Flux</li><li>flatMap 接受Function &lt;T，Publisher &gt;并返回Flux</li></ul><p>flatmap期望每个传来的T都有一个publisher。flatMap知道如何处理它：订阅他并在输出序列中传播其元素，所以，flatmap左后总会返回Flux<V>类型，flatmap将把每个内部publisher<strong>展平</strong>为所有V的输出序列</p><blockquote><p>concat </p></blockquote><p>public static <T> Flux<T> concat(Publisher&lt;? extends T&gt;… sources)</p><p>用于连接一个流。与combineLatest不同的是，concat都是在<strong>前一个流完成后再连接新的流</strong>。而combineLatest则是<strong>哪一个最先到哪个先处理。</strong></p><p><strong>参数</strong>：</p><ul><li>T 事件的类型</li><li>source：一系列的发布者</li><li>returns：一个新的Flux连接了所有得发布者，并传递给下游</li></ul><blockquote><p>concatDelayError</p></blockquote><p>拥有与concat类似得方法，不同得是，遇到问题不提前拦截，而是等到最后发布得事件处理完成后</p><blockquote><p>create,push</p></blockquote><p>public static <T> Flux<T> create(Consumer&lt;? super FluxSink<T>&gt; emitter)</p><p>通过FluxSink API，以同步或者异步的方式创建flux</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Flux.&lt;String&gt; create (emitter -&gt;&#123;<br>    <span class="hljs-type">ActionListener</span> <span class="hljs-variable">al</span> <span class="hljs-operator">=</span> e -&gt;&#123;<br>        emitter.next(textField.getText());<br>    &#125;<br>    <span class="hljs-comment">// without cleanup support</span><br>    <br>    button.addActionListener(al);<br>    <br>    <span class="hljs-comment">// add with cleanup support</span><br>    button.addActionListener(al);<br>    emiter.onDispose( () -&gt; &#123;<br>        buton.removeListener(al);<br>    &#125; )<br>&#125;)<br></code></pre></td></tr></table></figure><p><em>create(Consumer&lt;? super FluxSink<T>&gt; emitter, FluxSink.OverflowStrategy backpressure) 设置背压方式</em></p><p>push方法用处与使用方法与create几乎一致，他们唯一的区别就是CreateMode类型create为PUSH_PULL而push为PUSH_ONLY文档中也可以一个为多线程一个为单线程</p><blockquote><h5 id="backpressure-背压-概念的理解"><a href="#backpressure-背压-概念的理解" class="headerlink" title="backpressure(背压)概念的理解"></a>backpressure(背压)概念的理解</h5></blockquote><p>这里，我摘自一位大神的话，背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，<strong>一种告诉上游的被观察者降低发送速度的策略</strong>。简而言之，背压是<strong>流速控制的一种策略</strong>。</p><p>为什么会有背压策略，如果没有背压策略，当被观察者发送的事件速度远快于观察者处理速度的时候，会造成观察者这边事件堆积，造成内存占用过高。</p><p><strong>需要强调两点：</strong></p><ul><li>背压策略的前提是<strong>异步环境</strong>，也就是说，被观察者和观察者处于不同的线程环境中</li><li>背压并不是一个像flatmap一样可以在程序中直接使用的操作符，他只是一种控制事件流速的策略</li><li>interval操作符本身不支持背压策略，他发送事件的速度是不受控制的，而range这类操作符是支持背压的，它发送事件的速度是可以控制的</li></ul><blockquote><p>defer</p></blockquote><p>public static <T> Flux<T> defer(Supplier&lt;? extends Publisher<T>&gt; supplier)</p><p>这个方法提供了一种惰性策略，发布者不会一开始发布消息，知道订阅者创建实例</p><p><img src="1.png" alt="1"></p><p><strong>参数</strong>：</p><ul><li>T 发布者或者订阅者接收的类型</li><li>supplier 一个发布者的供应者，当订阅的时候回调</li><li>return: 一个惰性的Flux</li></ul><blockquote><h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h4></blockquote><p>public static <T> Flux<T> empty()<br>创建一个不含任何事件的流.</p><blockquote><p>error</p></blockquote><p>public static <T> Flux<T> error(Throwable error)<br>返回一个带着立即终止标识和错误信息的流</p><blockquote><p>first</p></blockquote><p>挑选出第一个发布者，由其提供事件。能有效的避免多个源的冲突。</p><p><img src="2.png" alt="2"></p><blockquote><p>from </p></blockquote><p>从一个发布者创建一个flux流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Flux&lt;T&gt; <span class="hljs-title function_">from</span><span class="hljs-params">(Publisher&lt;? extends T&gt; source)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Flux&lt;T&gt; <span class="hljs-title function_">fromIterable</span><span class="hljs-params">(Iterable&lt;? extends T&gt; it)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Flux&lt;T&gt; <span class="hljs-title function_">fromStream</span><span class="hljs-params">(Stream&lt;? extends T&gt; s)</span><br></code></pre></td></tr></table></figure><blockquote><h4 id="fromArray，fromIterable，fromStream"><a href="#fromArray，fromIterable，fromStream" class="headerlink" title="fromArray，fromIterable，fromStream"></a>fromArray，fromIterable，fromStream</h4></blockquote><p>public static <T> Flux<T> fromArray(T[] array)<br>通过一个数组，或者一个可迭代的元素，或者一个流，创建 flux 流.</p><p><img src="3.png" alt="3"></p><blockquote><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Flux&lt;T&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(Consumer&lt;SynchronousSink&lt;T&gt;&gt; generator)</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通过消费者回调逐一生成信号，以编程方式创建 Flux。<br></code></pre></td></tr></table></figure><p><img src="4.png" alt="4"></p><blockquote><p>interval</p></blockquote><p>public static Flux<Long> interval(Duration period)</p><p>间隔一定的事件，发送事件</p><p><img src="5.png" alt="5"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/03/13/Docker/"/>
    <url>/2022/03/13/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前的流程： Docker –&gt; Dockerfile —&gt; build –&gt; run 全部是手动操作，单个容器！</p><p> Docker Compose 来轻松高效的管理容器。定义运行多个容器！</p><blockquote><p>使用Docker Compose 的三部曲</p></blockquote><ol><li>使用 定义您的应用程序的环境，<code>Dockerfile</code>以便它可以在任何地方复制。<ul><li>Dockerfile保证我们的项目在任何地方运行</li></ul></li><li>定义组成您的应用程序的服务，<code>docker-compose.yml</code> 以便它们可以在隔离的环境中一起运行。<ul><li>service 什么是服务</li><li>docker-compose.yml这个文件怎么写</li></ul></li><li>使用Docker-compose up启动</li></ol><p>作用：批量容器编排！</p><blockquote><p>理解</p></blockquote><p>Compose是Docker官方的开源项目，需要安装！</p><blockquote><p>compose 的重要概念</p></blockquote><ul><li>服务service ，容器应用。（web、redis、mysql）</li><li>项目project。一组关联的容器。博客</li></ul><h2 id="安装compose"><a href="#安装compose" class="headerlink" title="安装compose"></a>安装compose</h2><ol><li><p><img src="1.png" alt="1"></p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot;</span> -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose<br></code></pre></td></tr></table></figure></li><li><p>授权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x docker-compose<br></code></pre></td></tr></table></figure></li><li><p>安装成功</p><p><img src="2.png" alt="2"></p></li></ol><h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><ol><li><p>给我们的项目创建一个文件夹</p></li><li><p>在项目文件夹下创建一个文件，app.py</p></li><li><p>在我们的项目目录下requirements.txt文件，并且黏贴 flask redis。这个是python的依赖文件，项目依赖的都放在这里，就是pip install 的时候下载的就是这里的。</p></li><li><p>创建一个Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM python:3.7-alpine<br>WORKDIR /code<br>ENV FLASK_APP=app.py<br>ENV FLASK_RUN_HOST=0.0.0.0<br>RUN apk add --no-cache gcc musl-dev linux-headers<br>COPY requirements.txt requirements.txt<br>RUN pip install -r requirements.txt<br>EXPOSE 5000<br>COPY . .<br>CMD [&quot;flask&quot;, &quot;run&quot;]<br></code></pre></td></tr></table></figure><p>这是告诉docker：</p><ul><li>从Python3.7开始构建镜像</li><li>将工作目录设置为 /code</li><li>设置flask命令使用的环境变量</li><li>安装gcc和其他依赖</li><li>复制requirements.txt并安装Python其他依赖项</li><li>将元数据添加到镜像以描述容器正在监听5000端口</li><li>将项目中的当前目录复制到镜像中的工作目录</li><li>将容器的默认命令设置为 flask run</li></ul></li><li><p>创建一个docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.9&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;redis:alpine&quot;</span><br></code></pre></td></tr></table></figure><p>这个yml定义了两个服务，一个web服务和一个redis服务，web服务是用本地的Dockerfile文件build的，如果Dockerfile文件的名字本身就是Dockerfile那么build的时候可以不用指定文件名</p><p><strong>Web</strong></p><p>该web服务使用从Dockerfile当前目录结构中的镜像文件。然后它将容器和主机绑定到暴漏的端口5000，此示例使用flask web服务器的默认端口5000</p><p><strong>Redis</strong></p><p>该redis服务使用的是从Docker hub注册表中提取的公共的Redis镜像。</p></li><li><p>使用Compose构建并运行应用程序</p><ol><li><p>从项目目录下，通过指令 docker-compose up 启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 给我们创建了一个Docker网络<br>Creating network &quot;composetest_default&quot; with the default driver<br>// 创建web服务<br>Building web<br>Sending build context to Docker daemon  5.632kB<br>Step 1/10 : FROM python:3.7-alpine<br>3.7-alpine: Pulling from library/python<br>29291e31a76a: Pull complete<br>3626a090061d: Pull complete<br>dccff05a79ae: Pull complete<br>328cb1305811: Pull complete<br>e91eabc5840c: Pull complete<br>Digest: sha256:cb74758aca3c66b1213e5d84fb943f425c7d44a07ba4949e4cf5c690cd855cae<br>Status: Downloaded newer image for python:3.7-alpine<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">9231c59cd582</span><br>Step 2/10 : WORKDIR /code<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 997c380ce6eb</span><br>Removing intermediate container 997c380ce6eb<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">257507eadcdc</span><br>Step 3/10 : ENV FLASK_APP=app.py<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 7b760f227db1</span><br>Removing intermediate container 7b760f227db1<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">f18da21d848a</span><br>Step 4/10 : ENV FLASK_RUN_HOST=0.0.0.0<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 40dbe5f5170c</span><br>Removing intermediate container 40dbe5f5170c<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">486a51ae8e63</span><br>Step 5/10 : RUN apk add --no-cache gcc musl-dev linux-headers<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> b08135697f69</span><br>fetch https://dl-cdn.alpinelinux.org/alpine/v3.14/main/x86_64/APKINDEX.tar.gz<br>fetch https://dl-cdn.alpinelinux.org/alpine/v3.14/community/x86_64/APKINDEX.tar.gz<br>(1/13) Installing libgcc (10.3.1_git20210424-r2)<br>(2/13) Installing libstdc++ (10.3.1_git20210424-r2)<br>(3/13) Installing binutils (2.35.2-r2)<br>(4/13) Installing libgomp (10.3.1_git20210424-r2)<br>(5/13) Installing libatomic (10.3.1_git20210424-r2)<br>(6/13) Installing libgphobos (10.3.1_git20210424-r2)<br>(7/13) Installing gmp (6.2.1-r0)<br>(8/13) Installing isl22 (0.22-r0)<br>(9/13) Installing mpfr4 (4.1.0-r0)<br>(10/13) Installing mpc1 (1.2.1-r0)<br>(11/13) Installing gcc (10.3.1_git20210424-r2)<br>(12/13) Installing linux-headers (5.10.41-r0)<br>(13/13) Installing musl-dev (1.2.2-r3)<br>Executing busybox-1.33.1-r3.trigger<br>OK: 140 MiB in 48 packages<br>Removing intermediate container b08135697f69<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">fd47d993b371</span><br>Step 6/10 : COPY requirements.txt requirements.txt<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">1e7a7c4aa5cc</span><br>Step 7/10 : RUN pip install  -r requirements.txt<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> ce3c8b5b666c</span><br>Collecting flask<br>  Downloading Flask-2.0.1-py3-none-any.whl (94 kB)<br>Collecting redis<br>  Downloading redis-3.5.3-py2.py3-none-any.whl (72 kB)<br>Collecting Jinja2&gt;=3.0<br>  Downloading Jinja2-3.0.1-py3-none-any.whl (133 kB)<br>Collecting Werkzeug&gt;=2.0<br>  Downloading Werkzeug-2.0.1-py3-none-any.whl (288 kB)<br>Collecting click&gt;=7.1.2<br>  Downloading click-8.0.1-py3-none-any.whl (97 kB)<br>Collecting itsdangerous&gt;=2.0<br>  Downloading itsdangerous-2.0.1-py3-none-any.whl (18 kB)<br>Collecting importlib-metadata<br>  Downloading importlib_metadata-4.6.4-py3-none-any.whl (17 kB)<br>Collecting MarkupSafe&gt;=2.0<br>  Downloading MarkupSafe-2.0.1.tar.gz (18 kB)<br>Collecting zipp&gt;=0.5<br>  Downloading zipp-3.5.0-py3-none-any.whl (5.7 kB)<br>Collecting typing-extensions&gt;=3.6.4<br>  Downloading typing_extensions-3.10.0.0-py3-none-any.whl (26 kB)<br>Building wheels for collected packages: MarkupSafe<br>  Building wheel for MarkupSafe (setup.py): started<br>  Building wheel for MarkupSafe (setup.py): finished with status &#x27;done&#x27;<br>  Created wheel for MarkupSafe: filename=MarkupSafe-2.0.1-cp37-cp37m-linux_x86_64.whl size=14616 sha256=843490b6047c7c0e0d1585883ac846f7dc827a7aa018a8b74ac3cdf69d96ce9a<br>  Stored in directory: /root/.cache/pip/wheels/1a/18/04/e3b5bd888f000c2716bccc94a565239f9defc47ef93d9e7bea<br>Successfully built MarkupSafe<br>Installing collected packages: zipp, typing-extensions, MarkupSafe, importlib-metadata, Werkzeug, Jinja2, itsdangerous, click, redis, flask<br>Successfully installed Jinja2-3.0.1 MarkupSafe-2.0.1 Werkzeug-2.0.1 click-8.0.1 flask-2.0.1 importlib-metadata-4.6.4 itsdangerous-2.0.1 redis-3.5.3 typing-extensions-3.10.0.0 zipp-3.5.0<br>WARNING: Running pip as the &#x27;root&#x27; user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv<br>Removing intermediate container ce3c8b5b666c<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">99033542c096</span><br>Step 8/10 : EXPOSE 5000<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> b66e733039a0</span><br>Removing intermediate container b66e733039a0<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">56b2d4c0c31f</span><br>Step 9/10 : COPY . .<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">3b613f01e9cd</span><br>Step 10/10 : CMD [&quot;flask&quot;, &quot;run&quot;]<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 68654b0c33c8</span><br>Removing intermediate container 68654b0c33c8<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">1ec852680c44</span><br>Successfully built 1ec852680c44<br>Successfully tagged composetest_web:latest<br>WARNING: Image for service web was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.<br>Pulling redis (redis:alpine)...<br>alpine: Pulling from library/redis<br>29291e31a76a: Already exists<br>16bbd9479e91: Pull complete<br>d4bb2b90a23b: Pull complete<br>011b05d94792: Pull complete<br>3a615fd1f2fd: Pull complete<br>bd76b8efa6e9: Pull complete<br>Digest: sha256:b658aeb0824fa240bd04b5017de2379d9707a433cb7040332328996d63c265f6<br>Status: Downloaded newer image for redis:alpine<br>// 启动了两个服务<br>Creating composetest_web_1   ... done<br>Creating composetest_redis_1 ... done<br>Attaching to composetest_redis_1, composetest_web_1<br>redis_1  | 1:C 25 Aug 2021 14:00:36.627 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo<br>redis_1  | 1:C 25 Aug 2021 14:00:36.627 # Redis version=6.2.5, bits=64, commit=00000000, modified=0, pid=1, just started<br>redis_1  | 1:C 25 Aug 2021 14:00:36.627 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf<br>redis_1  | 1:M 25 Aug 2021 14:00:36.628 * monotonic clock: POSIX clock_gettime<br>redis_1  | 1:M 25 Aug 2021 14:00:36.629 * Running mode=standalone, port=6379.<br>redis_1  | 1:M 25 Aug 2021 14:00:36.629 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.<br>redis_1  | 1:M 25 Aug 2021 14:00:36.629 # Server initialized<br>redis_1  | 1:M 25 Aug 2021 14:00:36.629 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.<br>redis_1  | 1:M 25 Aug 2021 14:00:36.629 * Ready to accept connections<br>web_1    |  * Serving Flask app &#x27;app.py&#x27; (lazy loading)<br>web_1    |  * Environment: production<br>web_1    |    WARNING: This is a development server. Do not use it in a production deployment.<br>web_1    |    Use a production WSGI server instead.<br>web_1    |  * Debug mode: off<br>web_1    |  * Running on all addresses.<br>web_1    |    WARNING: This is a development server. Do not use it in a production deployment.<br>// 至此启动成功<br>web_1    |  * Running on http://172.18.0.2:5000/ (Press CTRL+C to quit)<br></code></pre></td></tr></table></figure><p>这里有一个警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">WARNING: Image for service web was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.<br></code></pre></td></tr></table></figure><p>重新build一下,然后再up</p><p><img src="3.png" alt="3"></p><p>启动成功！</p><blockquote><p>看一下Docker为我们下载了哪些东西</p></blockquote><p><img src="4.png" alt="4"></p><p><strong>Docker 为我们自动下载了docker-compose.yml里面所需要的依赖</strong></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><img src="5.png" alt="5"></p><p>compomse为我们生成了一个默认的网络，项目中的内容在同一个网络下，可以通过域名访问。</p><blockquote><p>查看一下网络细节</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network inspect composetest_default<br><br>[<br>    &#123;<br>        &quot;Name&quot;: &quot;composetest_default&quot;,<br>        &quot;Id&quot;: &quot;8976c9ff627bb4b9ed59e37fe2bd85fb9d44d80cf69d2c4c58fd34ee34b982dd&quot;,<br>        &quot;Created&quot;: &quot;2021-08-25T21:56:27.082056201+08:00&quot;,<br>        &quot;Scope&quot;: &quot;local&quot;,<br>        &quot;Driver&quot;: &quot;bridge&quot;,<br>        &quot;EnableIPv6&quot;: false,<br>        &quot;IPAM&quot;: &#123;<br>            &quot;Driver&quot;: &quot;default&quot;,<br>            &quot;Options&quot;: null,<br>            &quot;Config&quot;: [<br>                &#123;<br>                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,<br>                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;<br>                &#125;<br>            ]<br>        &#125;,<br>        &quot;Internal&quot;: false,<br>        &quot;Attachable&quot;: true,<br>        &quot;Ingress&quot;: false,<br>        &quot;ConfigFrom&quot;: &#123;<br>            &quot;Network&quot;: &quot;&quot;<br>        &#125;,<br>        &quot;ConfigOnly&quot;: false,<br>        // 两个服务在同一个网络下，在访问的的时候就可以通过域名访问<br>        &quot;Containers&quot;: &#123;<br>            &quot;a841fa30f1638622b3940e6e0878305fb760f7442cd3f288245af4e709e85dd2&quot;: &#123;<br>                &quot;Name&quot;: &quot;composetest_redis_1&quot;,<br>                &quot;EndpointID&quot;: &quot;f79f990ac02776b47914b59f85fae80762e4eabf3f65c1fad553a0a9c58364e2&quot;,<br>                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,<br>                &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,<br>                &quot;IPv6Address&quot;: &quot;&quot;<br>            &#125;,<br>            &quot;bf24d8a60dfe24a83d08cff57cf761fa41d18beade38a0ab9fb18cb9f1562c53&quot;: &#123;<br>                &quot;Name&quot;: &quot;composetest_web_1&quot;,<br>                &quot;EndpointID&quot;: &quot;2daacdf34e07ead0712a74b091c5e25d57f52f37094bdb30e4abc33cb8809780&quot;,<br>                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,<br>                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,<br>                &quot;IPv6Address&quot;: &quot;&quot;<br>            &#125;<br>        &#125;,<br>        &quot;Options&quot;: &#123;&#125;,<br>        &quot;Labels&quot;: &#123;<br>            &quot;com.docker.compose.network&quot;: &quot;default&quot;,<br>            &quot;com.docker.compose.project&quot;: &quot;composetest&quot;,<br>            &quot;com.docker.compose.version&quot;: &quot;1.29.2&quot;<br>        &#125;<br>    &#125;<br>]<br><br></code></pre></td></tr></table></figure><p><img src="6.png" alt="6"></p><blockquote><p>再次理解compose</p></blockquote><p>以前都是单个容器，项目启动的时候你得一个一个的启动，就 很麻烦，现在有了compose，就可以一件启停。所以说docker-compose里面放着我们这个项目所需要的所有的容器</p><h3 id="Docker小结"><a href="#Docker小结" class="headerlink" title="Docker小结"></a>Docker小结</h3><ol><li>images  run =&gt; 容器</li><li>Dockerfile build 构建镜像</li><li>docker-compose 启动项目</li><li>Docker网络</li></ol><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><blockquote><p>什么是Dockerfile</p></blockquote><p>Dockerfile是用来描述文件构成的文本文档</p></li></ol></li></ol><p><img src="7.png" alt="7"></p><h3 id="如何优雅的编写Dockerfile"><a href="#如何优雅的编写Dockerfile" class="headerlink" title="如何优雅的编写Dockerfile"></a>如何优雅的编写Dockerfile</h3><ul><li>文件不宜太长，层级越多制作出来的镜像就越大</li><li>构建出来的镜像不要包含不需要的内容，如日志、安装临时文件等</li><li>尽量使用运行时的基础镜像，不需要将构建时的过程也放到运行时的Dockerfile里</li></ul><blockquote><p>对比一下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM ubuntn:16.04<br>RUN apt-get update<br>RUN apt-get install -y apt-utils libjeg-dev \<br>python-pip<br>RUN pip install --upgrade pip<br>RUN easy_install -U setuptools<br>run apt-get clean<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">form ubuntu:16.04<br>run apt-get update &amp;&amp; apt-get install -y apt-utils \ <br>   libjpeg-dev python-pip \<br>   &amp;&amp;  pip install --upgrade pip \<br>    &amp;&amp; easy_install -U setuptools \<br>    &amp;&amp; apt-get clean<br></code></pre></td></tr></table></figure><p>分析一下</p><ol><li>第一分全部分层写的，我们知道docker 就像是堆积木是一层一层的，那么第一份就相当于堆了很多层，那么就会占用相对多的内存，当然这点内存对我们来说也不算什么。</li><li>说一下优点，因为第一层分层了，那么当镜像出现错误的时候需要重修build是，那些没有出错的层就不用重新build了，那么就节省了重构的时间。但是如果Dockerfile非常长的话就要考虑减少层次了，因为Dockerfile做高只能有127层</li></ol><p>分析一下第二份</p><ol><li>这一份和第一份最大的区别在于，他都放在一层写了，那就导致如果这一层有出错的话，就得全部重构那么就比较耗时了，虽然他占用的内存比较少。</li></ol><h3 id="如何优雅的写Docker-compose-yml"><a href="#如何优雅的写Docker-compose-yml" class="headerlink" title="如何优雅的写Docker-compose.yml"></a>如何优雅的写Docker-compose.yml</h3><blockquote><p>什么是docker-compoes</p></blockquote><p>docker-compose 把所有需要的镜像包括各种参数和顺序写在一个yml文件里，直接运行这一个配置文件就可以按照你所需要的方法和步骤运行容器。所以称<strong>docker-compose为一种镜像编排的方式</strong>。</p><p>看一下实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &quot;3&quot;<br>services:<br>  web:<br>    image: beginor/geoserver:2.11.1<br>    container_name: geoserver-web<br>    hostname:geosover-web<br>    ports:<br>      -8080:8080<br>    volumes:<br>      - ./web/data_dir: /geoserver/data_dir<br>      - ./web/logs: /geoserver/logs<br>    restart: unless-stopped<br>    links:<br>      - database:database<br>   database:<br>     iamge: beginor/postgis:9.3<br>     container_name: postgis<br>     hostname: postgis<br>     ports:<br>       - 5432:5432<br>     volumes:<br>       - ./database/data: /var/lib/postgresql/data<br>     environment:<br>       POSTGRES_PASSWORD: 123456<br>     restart: unless-stopped<br></code></pre></td></tr></table></figure><h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><h1 id="Docker-Stack"><a href="#Docker-Stack" class="headerlink" title="Docker Stack"></a>Docker Stack</h1><h1 id="Docker-Secret"><a href="#Docker-Secret" class="headerlink" title="Docker Secret"></a>Docker Secret</h1><h1 id="Docker-Config"><a href="#Docker-Config" class="headerlink" title="Docker Config"></a>Docker Config</h1><h1 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h1>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC</title>
    <link href="/2022/03/13/JUC/"/>
    <url>/2022/03/13/JUC/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程下保证数据的一致性"><a href="#多线程下保证数据的一致性" class="headerlink" title="多线程下保证数据的一致性"></a>多线程下保证数据的一致性</h1><blockquote><p>使用synchronized关键字</p></blockquote><p>比如对num变量进行操作，如果没有synchronized关键字，即使是使用volatile修饰变量。输出的值也会小于1000，因为volatile虽然可以保证可见性以及顺序性但是不能保证变量的原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>    num++;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用Lock锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>    lock.lock();<br>    num++;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用Atomic原子类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInter</span> <span class="hljs-variable">ai</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>    ai.getAndIncrement();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多线程情况下调用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadUse</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">time1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>().getTime();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">10000</span>; j++)&#123;<br>                    increment();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>    <span class="hljs-comment">// 确保所有线程调用结束</span><br>    <span class="hljs-keyword">while</span>(Thread.activeCount()&gt;<span class="hljs-number">1</span>)<br>        Thread.yield();<br>    <span class="hljs-comment">// 打印出执行所用时间</span><br>    System.out.println(<span class="hljs-string">&quot;time=&quot;</span>+(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getTiem - time1))；<br>&#125;<br></code></pre></td></tr></table></figure><p>分别调用上述三种情况，输出的都是10000，但是执行所花费的时间是不一致的，发现synchronized和lock使用的时间是基本相同，使用Atomic原子类所花费的时间相对是两种的一半，但是当执行量越来越大的时候发现使用synchronized所花费的时间低于Atomic。</p><blockquote><p>总结</p></blockquote><ul><li>synchronized: 重量级操作，基于悲观锁，可重入锁</li><li>AtomicInteger: 乐观,用CAS实现，当并发大的时候Atomic出错的概率会增大，不断校验更费时间</li></ul><h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><p>多个线程对同一个变量进行操作（称为共享变量），但是这多个线程有可能会被分配到多个处理器中运行那么编译器会对代码进行优化，当线程要处理该变量时，多个处理器会将变量从主存复制一份分别存储到自己的存储器中，等到进行完操作后，再赋值回主存。</p><p><strong>问题：</strong> 如果两个线程t1和t2分别被安排到不同的处理器上面，那么t1与t2对于变量A的操作就相对是不可见的，如果t1给A赋值，然后t2又给A赋值，那么t2的操作就会把t1的操作覆盖掉那就会产生不可预料的后果。</p><p>因此需要保证变量的可见性，<strong>一个线程对共享变量的修改能够及时的被其他线程看到</strong></p><p><strong>共享数据的访问权限必须定义为private</strong></p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>当多个线程操作共享数据时，可以保证内存中的数据可见。用这个关键字修饰共享数据，就会及时的把线程缓存中的数据刷新到主存中去， 也可以理解为，就是直接操作主存中的数据。所以在不想使用锁的情况下，可以使用volatile关键字，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">falg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>这样就可以解决内存可见性的问题了。</p><p>内存包括共享主存和高速缓存（工作内存），volatile关键字标识的变量，是指CPU从缓存读取数据时，要判断数据是否有效。如果缓存没有数据，再从主存读取。主存就不存在是否有效的说法了。而<strong>内存一致性协议也是针对缓存的协议</strong>。</p><blockquote><p>如何解决的内存可见性</p></blockquote><p>对其他核心数立即可见，这个意思是，当一个CPU核心A修改完volatile变量，并且立即同步回主存，如果另一个CPU核心B的工作内存中也缓存了这个变量，那么B的这个变量会立即失效，当B想要修改这个变量的时候，B必须从主存中重新获取变量的值。除此之外，即便是单线程读取volatile变量，在变量值不变的情况下，也都是从主存读取。因此这里面有两种情况，一是已读取，失效；二是再读取，从主存读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// falg未使用volatile关键字修饰，内存不可见</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (flag) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end......&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileTest</span>()).start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        flag = <span class="hljs-literal">false</span>;<br>        System.out.println(<span class="hljs-string">&quot;end main......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子，子线程会一直卡住，原因是flag不具备可见性。主线程和子线程刚开始都缓存了flag，并且值都是true，后来主线程把值修改为了false，但是子线程并不知道，仅此而已！！！如果flag用volatile关键字修饰，那么主线程在修改成false后，子线程再次while循环的时候，就会发现他缓存的flag已经失效了，他会从主存中重新读取flag的值。</p><blockquote><p>实现原理</p></blockquote><p>实现的原理是基于CPU的MESI协议的（缓存一致性协议），其中E表示独占Exclusive,S表示Shared，M表示Modify，I表示Invalid，如果一个核心修改了数据，那么其他核心的数据状态就会更新成M，同时其他核心上的状态更新成I，这个是通过CPU多核之间的嗅探机制实现的。</p><p>但是，这样是否就能保证多线程操作一个共享变量的时候，保证线程安全呢？其实不然，否则我怎么说是仅此而已呢！</p><p>volatile限定的是从缓存读取时刻的校验，如果两个CPU同时从各自缓存读取一个变量 n = 1（此时，变量n在各个CPU缓存都是有效的），并且同时修改了变量 n = n + 1，再写回缓存，这个时候n的值等于2，而不是等于3。因此，在多线程操作共享变量的时候，正确的方式是使用同步或者Atomic。</p><h2 id="指令有序性"><a href="#指令有序性" class="headerlink" title="指令有序性"></a>指令有序性</h2><p>这个涉及到内存屏障，内存屏障有两个能力：</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java高阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go</title>
    <link href="/2022/03/12/Go/"/>
    <url>/2022/03/12/Go/</url>
    
    <content type="html"><![CDATA[<h1 id="go学习"><a href="#go学习" class="headerlink" title="go学习"></a>go学习</h1><h2 id="了解go环境"><a href="#了解go环境" class="headerlink" title="了解go环境"></a>了解go环境</h2><h3 id="环境变量GOROOT-和GOPATH的区别"><a href="#环境变量GOROOT-和GOPATH的区别" class="headerlink" title="环境变量GOROOT 和GOPATH的区别"></a>环境变量GOROOT 和GOPATH的区别</h3><p><font>GOPATH不应该指向go的安装路径，而是指向你的工作空间.</font>每当你使用<font>go get</font> 或者<font>go install</font>的时候他就会被扔到GOPATH里面去。如果没有区分开在运行代码的时候会警告你。</p><p><img src="1.png" alt="1"></p><p>设置新的环境变量，然后重启电脑。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><br>setx GOPATN xxxx<br><br></code></pre></td></tr></table></figure><h2 id="GO-ENV"><a href="#GO-ENV" class="headerlink" title="GO ENV"></a>GO ENV</h2><p><img src="5.png" alt="5"></p><h3 id="GO-MODULE"><a href="#GO-MODULE" class="headerlink" title="GO MODULE"></a>GO MODULE</h3><p>go1.11的时候推出了 GO MODULE来解决依赖管理问题。通过GO111MODULE这个变量来控制 GO Module的开启和关闭，取值为off,on 或者auto。</p><p>从Go1.13开始，GO MODULE 开始做为GoLang的中标准的包管理器。</p><h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><p>在Go项目了一般源码放在src目录下，所以我们在工作目录下新建一个src目录存放我们的源码文件，目录结构如下：</p><p><img src="2.png" alt="2"></p><p>这里我是新建了一个hello文件夹用于存放测试案例hello.go。</p><blockquote><p>测试hello.go是否能够正常运行</p></blockquote><p><img src="3.png" alt="3"></p><p>在cmd终端下使用go run 指令直接运行。</p><h3 id="go的编译过程"><a href="#go的编译过程" class="headerlink" title="go的编译过程"></a>go的编译过程</h3><ol><li>go build  —–&gt;   go run</li><li>直接  go run </li></ol><p><img src="4.png" alt="4"></p><p>测试OK!</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es</title>
    <link href="/2022/03/12/es/"/>
    <url>/2022/03/12/es/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><blockquote><p>ElasticSearch和Lucene的关系</p></blockquote><p>ElasticSearch是基于Lucene做了一些封装和增强的</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ol><li>索引</li><li>字段类型（mapping）</li><li>文档</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Node-与-Cluster"><a href="#Node-与-Cluster" class="headerlink" title="Node 与 Cluster"></a>Node 与 Cluster</h3><p>Elastic本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个elastic实例。单个elastic称为一个节点（node）。一组节点构成一个集群（cluster）</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p><strong>Elastic会索引所有字段，经过处理后会写入一个反向索引</strong>（inverted index）。查找数据的时候，直接查找该索引。所以，Elastic数据管理顶层单位就叫做index索引。他是单个数据库的同义词。每个index即数据库的名字必须是小写。通过一下命令查看所有的索引</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">GET &#x27;127.0.0.1:9200/_cat/indices?v&#x27;<br></code></pre></td></tr></table></figure><h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><p><strong>Index里面的单条记录又称为Document（文档），多条document构成了一个Index。</strong></p><p>Document使用Json格式表示</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;zhangsan&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;工程师&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>同一个index里面的document不要求有相同的结构scheme，但是最好保持相同，这样有利于提高搜索效率。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>Document可以分组，比如weather这个index里面可以按城市分组（北京上海），也可以按照其后分组，这种分组叫做type，他是虚拟的逻辑分组，用来过滤document。</p><p>不同的type应该有相似的结构scheme，举例来说，id字段不能 在这个组里是字符串在另一个组里是数值。这与关系型数据库截然不同。MySQL里面不同表里的相同字段的类型是不受彼此影响的。现在在elastic里面性质完全不同的数据比如product和logs应该存成两个index而不是一个index里面的两个type（虽然可以做到）</p><p>下面可以列出每个index所包含的type</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl &quot;127.0.0.1:9200/_mapping?pretty=true&quot;<br></code></pre></td></tr></table></figure><p>在elastic 6.X中每个index只允许包含一个type，7.X版本将彻底移除type</p><p>简称es,<strong>是一个开源的高扩展的分布式全文检索</strong>引擎，它可以近乎实时的存储、检索数据；本身的扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也是用Java开发并使用Lucene作为其核心来实现所有的索引和搜索的功能，但是他的目的是通过简单的restfulAPI来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，她便跟着去了。在找工作的过程中为了给妻子构建一个食谱的搜索引擎，他便开始构建一个早期版本的Luence。</p><p>直接基于Luence的工作比较困难，所以Shay开始抽象Luence代码以便Java程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目叫做<strong>Compass</strong></p><p>后来Shay找到一份工作，这份工作在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然的。然后他决定重写Compass库使其成为一个独立的服务叫做<strong>ElasticSearch</strong></p><p>第一个公开版本出现于2010年二月分，在那之后ElasticSearch已经成为GitHub上最受欢迎的项目之一，代码贡献者超过300人。一家主营ElasticSearch的公司就此成立，他们一边提供服务一边开发新功能</p><h2 id="ElasticSearch和solr的差别"><a href="#ElasticSearch和solr的差别" class="headerlink" title="ElasticSearch和solr的差别"></a>ElasticSearch和solr的差别</h2><p>Elasticsearch是一个实时分布式搜索和分析引擎。它让你以前所未有的速度处理大数据成为可能。它用于全文搜索、结构化搜索、分析以及将这三者混合使用︰维基百科使用Elasticsearch提供全文搜索并高亮关键字，以及输入实时搜索(search-asyou-type)和搜索纠错(did-you-mean)等搜索建议功能。英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了解公众对新发表的文章的回应。StackOverflow结合全文搜索与地理位置查询，以及more-like-this功能来找到相关的问题和答案。Github使用Elasticsearch检索1300亿行的代码。但是Elasticsearch不仅用于大型企业，它还让像DataDog以及Klout这样的创业公司将最初的想法变成可扩展的解决方案。Elasticsearch可以在你的笔记本上运行，也可以在数以百计的服务器上处理PB级别的数据。Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。Elasticsearch也使用lava开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。Elasticsearch也使用lava开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><h2 id="Solr简介"><a href="#Solr简介" class="headerlink" title="Solr简介"></a>Solr简介</h2><p>Solr是Apache下的一个顶级开源项目，采用lava开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化Solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中，Solr索引的实现方法很简单，用POST方法向Solr服务器发送一个描述Field及其内容的XML文档，Solr根据xml文档添加、删除、更新索引。Solr搜索只需要发送HTTP GET请求，然后对Solr返回Xml、json等格式的查询结果进行解析，组织页面布局。Solr不提供构建UI的功能，Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的文件，生成索引;也可以通过提出查找请求，并得到返回结果。Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的文件，生成索引;也可以通过提出查找请求，并得到返回结果。</p><h2 id="ElasticSearch和Solr的比较"><a href="#ElasticSearch和Solr的比较" class="headerlink" title="ElasticSearch和Solr的比较"></a>ElasticSearch和Solr的比较</h2><img src="C:\Users\Lenovo\hexo-blog\source\_posts\es.assets\image-20210818170935687.png" alt="image-20210818170935687" style="zoom:80%;" /><img src="C:\Users\Lenovo\hexo-blog\source\_posts\es.assets\image-20210818171053767.png" alt="image-20210818171053767" style="zoom:80%;" /><p>ElasticSearch VS Solr总结</p><ol><li>es 开箱即用，解压就可以用，非常简单。Solr安装比较复杂</li><li>Solr利用zookeeper进行分布式管路，而ElasticSearch自身带有分布式协调管理的功能</li><li>Solr支持更多的格式，比如Json、xml、CSV、,而es仅支持JSON但是当前用的最多 的还是JSON</li><li>Solr提供更多的功能，而ES本身更注重于核心功能，高级的功能由第三方插件提供比如IK，和图形界面kibana</li><li>Solr查询快，但是更新索引时慢（即插入删除慢），用于电商等查询多的应用；ES建立索引快（即查询快）及时性查询快，用于Facebook新浪等搜索。Solr是传统搜索应用的有利解决方案，但是ElasticSearch更适用于新型的实时搜索应用</li><li>Solr比较成熟没有一个更大、更成熟的用户、开发和贡献者社区，而es相对开发维护者比较少，更新太快学习成本高</li></ol><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818173234918.png" alt="image-20210818173234918"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">/bin 启动文件<br>/config 配置文件<br>      /log4j2  日志文件<br>      /jvm.options java虚拟机相关的配置 内存小的可以配置 -Xms <br>      /elasticsearch.yml es的配置文件 默认9200端口 跨域问题<br>/lib 相关jar包<br>/logs 日志<br>/modules 功能模块<br>/plugins 插件 ik<br></code></pre></td></tr></table></figure><p>默认情况下ES只允许本机访问，如果需要远程访问可以修改ES安装目录下面的config/elasticsearch.yml文件，去掉network.host的注释，将他的值改为0.0.0.0，然后重新启动</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 0.0.0.0可以让任何人访问，上线时应该时具体的IP地址</span><br><span class="hljs-string">network.host:0.0.0.0</span><br></code></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>双击/bin/elasticsearch.bat 文件</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818175204320.png" alt="image-20210818175204320"></p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818175433324.png" alt="image-20210818175433324"></p><blockquote><p>安装可视化界面</p></blockquote><ol><li><p>配置跨域</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 打开跨域支持</span><br><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 设置为允许所有人访问</span><br><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818181524735.png" alt="image-20210818181524735"></p></li><li><p>启动指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> npm install<br><span class="hljs-number">2.</span> net run start <br></code></pre></td></tr></table></figure></li></ol><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818182617047.png" alt="image-20210818182617047"></p><p>初学可以把es当作数据库，可以建立索引（库），文档（库中的数据）<strong>这个head我们就把它当作数据展示工具</strong></p><blockquote><p>了解Elk</p></blockquote><p>ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。市面上也被成为Elastic Stack。其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为es。Logstash是ELK的中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件/MQ/redis/elasticsearch/kafka等 )。Kibana可以将elasticsearch的数据通过友好的页面展示出来，提供实时分析的功能。市面上很多开发只要提到ELK能够一致说出它是一个日志分析架构技术栈总称，但实际上ELK不仅仅适用于日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性。并非唯一性。</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818195903364.png" alt="image-20210818195903364"></p><blockquote><p>安装Kibana</p></blockquote><p>Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana ,可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板( dashboard )实时显示Elasticseaich查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</p><blockquote><p>目录</p></blockquote><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818201754160.png" alt="image-20210818201754160"></p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818202509587.png" alt="image-20210818202509587"></p><p><strong>在/config/kibana.yml里面进行汉化</strong></p><blockquote><p>elasticsearch是面向文档的，关系型数据库和elasticsearch的对比</p></blockquote><table><thead><tr><th>关系型数据库</th><th>ElasticSearch</th></tr></thead><tbody><tr><td>数据库 DB</td><td>索引（includes）</td></tr><tr><td>表（tables）</td><td>types（慢慢在弃用）</td></tr><tr><td>行（rows）</td><td>document</td></tr><tr><td>字段（columns）</td><td>fields</td></tr></tbody></table><p>elasticsearch（集群）中可以包含多个索引（数据库），每个索引中可以包含多个类型（表），每个类型下又包含多个文档（行），每个文档中又包括多个字段（列）</p><h2 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h2><p>elasticsearch在后台把每个 <strong>索引划分成多个分片</strong> ，每分分片可以在集群中的不同服务器间迁移，一个人就是一个集群！默认的集群名就是elasticsearch </p><blockquote><p>文档</p></blockquote><p>就是我们的一条条数据</p><p>之前说es是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch中，文档有几个重要属性</p><ul><li>自我包含，一篇文档同时包含字段和对应的值，也就是同时包含key:value</li><li>可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的。{就是一个json对象，fastjson进行自动转换！}</li><li>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新字段。</li></ul><p>尽管我们可以灵活的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型可以是字符串也可以是整形，因为elasticsearch会保存字段和类型之间的映射及其他设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型</p><blockquote><p>类型</p></blockquote><p><strong>类型是文档的逻辑容器</strong>，<strong>就像关系型数据库一样，表格是行的容器</strong>。类型中对于字段的定义称为映射，比如name映射为字符串类型。我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整形。但是elasticsearch也可能猜不对，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。</p><blockquote><p>索引</p></blockquote><p><strong>就是数据库</strong> 索引是映射类型的容器。elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。然后他们被存储到各个分片上了。我们来研究下分片是如何工作的</p><p><strong>物理设计：节点和分片如何工作</strong></p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818213035706.png" alt="image-20210818213035706"></p><p>一个集群这至少有一个节点，而一个 节点就是一个elasticsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有五个分片（primary shard,又称主分片）构成的，每一个主分片 会有一个副本（replica shard，又称复制分片）</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818212805059.png" alt="image-20210818212805059"></p><h2 id="倒排锁引"><a href="#倒排锁引" class="headerlink" title="倒排锁引"></a>倒排锁引</h2><p>elasticsearch使用的是一种称为倒排锁引的结构，采用Luence倒排锁引作为底层。这种结构适用于快速的全文搜索，一个锁引有文档中所有不重复的列表构成，对于每一个词，都有一个包含他的文档列表。例如，现在有两个文档，每个文档包含如下内容：</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818214001508.png" alt="image-20210818214001508"></p><p>为了创建倒排锁引，我们首先要将每个文档拆分成独立的词（或称为词条或者tokens），然后创建一个包含所有不重复的词条的排序列表，然后列出每个词条出现哪个文档：</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818214631688.png" alt="image-20210818214631688"></p><p>现在我们试图搜索to forever,只需要查看包含每个词条的文档 score</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210818214940948.png" alt="image-20210818214940948"></p><p>​    两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在，这两个包含关键字的文档都将返回。</p><h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><blockquote><p>安装 </p></blockquote><ol><li><p><a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p></li><li><p>下载完毕之后解压放到elasticsearch插件中即可</p></li><li><p>重启ElasticSearch</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210819155215150.png" alt="image-20210819155215150"></p></li><li><p>也可以通过elasticsearch-plugin list来查看加载进来的插件</p></li><li><p>使用kibana测试</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json">GET _analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dean&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>GET _analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;隔壁老樊&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;tokens&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;隔壁&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;老&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_CHAR&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;樊&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_CHAR&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>IK分词器增加自己的配置</p><ul><li><p>新建一个.dic文件</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210819162238583.png" alt="image-20210819162238583"></p></li><li><p>在里面添加我们需要的词语</p></li><li><p>把我们的字典配置ik的配置文件中</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210819162734350.png" alt="image-20210819162734350"></p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210819163140511.png" alt="image-20210819163140511"></p></li><li><p>再次测试</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210819164610288.png" alt="image-20210819164610288"></p></li></ul><h2 id="Rest风格说明"><a href="#Rest风格说明" class="headerlink" title="Rest风格说明"></a>Rest风格说明</h2><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210819164828608.png" alt="image-20210819164828608"></p><blockquote><p>基础测试</p></blockquote><ol><li><p>创建一个索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">PUT /索引名/类型名/文档<span class="hljs-built_in">id</span><br>&#123;请求体&#125;<br>PUT /test1/type1/1<br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Dean超给力&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>:18<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210819165444903.png" alt="image-20210819165444903"></p></li><li><p>~~~ json<br>// 新建一个索引，这一个就相当于是一种规范对字段有约束，就类似于MySQL类里面的字段类型<br>PUT /test2<br>{<br>  “mappings”: {</p><div class="code-wrapper"><pre><code class="hljs">&quot;properties&quot;: &#123;  &quot;name&quot;:&#123;    &quot;type&quot;: &quot;text&quot;  &#125;,  &quot;age&quot;:&#123;    &quot;type&quot;: &quot;long&quot;  &#125;,  &quot;birthday&quot;:&#123;    &quot;type&quot;: &quot;date&quot;  &#125;&#125;</code></pre></div><p>  }<br>}</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>   如果我们的文档字段没有指定类型，那么es就会给我们配置默认的字段类型<br><br>**扩展**：通过命令查看elasticsearch索引情况<br><br>~~~ bash<br><span class="hljs-built_in">GET</span> _cat/<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>修改</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /test2/_doc/<span class="hljs-number">2</span>/_update<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;法外狂徒王五&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>查</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 查找所有的</span><br>POST /test2/_doc/_search<br><span class="hljs-comment">// 获取指定id的</span><br>GET /test2/_doc/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><blockquote><p>删除索引</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE test1<br><span class="hljs-comment">// 删除指定的文档</span><br>DELETE /test2/_doc/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="关于文档的操作"><a href="#关于文档的操作" class="headerlink" title="关于文档的操作"></a>关于文档的操作</h2><blockquote><p>添加数据</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /test2/_doc/<span class="hljs-number">5</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;王富国&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;birthday&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1999-03-07&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>查询数据</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 查询所有的数据</span><br>POST /test2/_search<br><span class="hljs-comment">// 查询指定的 </span><br>GET /test2/_doc/<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><blockquote><p>更新数据</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /test2/_doc/<span class="hljs-number">5</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;王国副&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;birthday&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1999-03-07&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><img src="C:\Users\Lenovo\hexo-blog\source\_posts\es.assets\image-20210819175705264.png" alt="image-20210819175705264" style="zoom:80%;" /></li></ol><h2 id="集成springboot"><a href="#集成springboot" class="headerlink" title="集成springboot"></a>集成springboot</h2><blockquote><p>导入依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;-- 导入依赖，一个高级客户端的依赖，一个服务的依赖，两个都必须要导入--&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.14.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.14.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>配置配置类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dean.config;<br><br><br><span class="hljs-keyword">import</span> org.apache.http.HttpHost;<br><span class="hljs-keyword">import</span> org.elasticsearch.client.RestClient;<br><span class="hljs-keyword">import</span> org.elasticsearch.client.RestHighLevelClient;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ElasticSearchConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestHighLevelClient <span class="hljs-title function_">restHighLevelClient</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">RestHighLevelClient</span> <span class="hljs-variable">restHighLevelClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(<br>                RestClient.builder(<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHost</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9200</span>, <span class="hljs-string">&quot;http&quot;</span>),<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHost</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9201</span>, <span class="hljs-string">&quot;http&quot;</span>)));<br>        <span class="hljs-keyword">return</span> restHighLevelClient;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>测试</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建索引请求</span><br>        <span class="hljs-type">CreateIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateIndexRequest</span>(<span class="hljs-string">&quot;dean3_index&quot;</span>);<br>        <span class="hljs-comment">// 执行请求</span><br>        <span class="hljs-type">CreateIndexResponse</span> <span class="hljs-variable">createIndexResponse</span> <span class="hljs-operator">=</span> restHighLevelClient<br>            .indices()<br>            .create(request, RequestOptions.DEFAULT);<br>        System.out.println(<span class="hljs-string">&quot;1111111111111110&quot;</span>);<br>        System.out.println(createIndexResponse);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>获取客户端索引是否存在</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">testExistIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-type">GetIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetIndexRequest</span>(<span class="hljs-string">&quot;dean3_index&quot;</span>);<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> restHighLevelClient.indices()<br>               .exists(request, RequestOptions.DEFAULT);<br>       System.out.println(exists);<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\es.assets\image-20210821114536794.png" alt="image-20210821114536794"></p><blockquote><p>添加一个文档</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddDoc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Dean&quot;</span>,<span class="hljs-number">18</span>);<br>        <span class="hljs-comment">// 创建请求</span><br>        <span class="hljs-type">IndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;dean_index&quot;</span>);<br>        <span class="hljs-comment">// 规则</span><br>        request.id(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-comment">// 设置超时时间</span><br>        request.timeout(<span class="hljs-string">&quot;1s&quot;</span>);<br>        <span class="hljs-comment">// 将我们的数据放入请求 json</span><br>        <span class="hljs-comment">// 把我们的数据转换为json，然后放到resource中</span><br>        request.source(JSON.toJSONString(user),XContentType.JSON);<br>        <span class="hljs-comment">// 客户端发送请求</span><br>        <span class="hljs-type">IndexResponse</span> <span class="hljs-variable">indexResponse</span> <span class="hljs-operator">=</span> restHighLevelClient.index(request, RequestOptions.DEFAULT);<br>        System.out.println(indexResponse.toString());<br><br>        <span class="hljs-comment">// 对应我们命令的返回状态CREATED</span><br>        System.out.println(indexResponse.status());<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们可以将需要添加的文档写成一个java实体，然后将 Java实体转换为json然后再放到请求体中</p><blockquote><p>判断文档是否存在</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span> <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDocExit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 首先构造一个get请求</span><br>        <span class="hljs-type">GetRequest</span> <span class="hljs-variable">getRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetRequest</span>(<span class="hljs-string">&quot;dean_index&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-comment">// 然后在判断是否存在</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> restHighLevelClient.exists(getRequest, RequestOptions.DEFAULT);<br>        System.out.println(exists);<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>获取文档的相关信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-comment">// 首先还是构建get请求，哪个索引，哪个文档</span><br>       <span class="hljs-type">GetRequest</span> <span class="hljs-variable">getRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetRequest</span>(<span class="hljs-string">&quot;dean_index&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>       <span class="hljs-comment">// 获得请求响应</span><br>       <span class="hljs-type">GetResponse</span> <span class="hljs-variable">getResponse</span> <span class="hljs-operator">=</span> restHighLevelClient.get(getRequest, RequestOptions.DEFAULT);<br>       <span class="hljs-comment">//  响应里面有文档里所有的内容我们可以选择查看</span><br>       System.out.println(getResponse.getSource());<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p>查询操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSearch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 新建一个查询请求</span><br>        <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">searchRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;dean_index&quot;</span>);<br><br>        <span class="hljs-comment">// 构建搜索查询</span><br>        <span class="hljs-type">SearchSourceBuilder</span> <span class="hljs-variable">searchSourceBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchSourceBuilder</span>();<br><br>        <span class="hljs-comment">// 构造查询条件，我们可以使用QueryBuilder工具来实现</span><br>        <span class="hljs-comment">// QueryBuilders.termQuery精确查询</span><br>        <span class="hljs-comment">// QueryBuilders.matchAllQuery匹配所有</span><br>        <span class="hljs-type">TermQueryBuilder</span> <span class="hljs-variable">termQueryBuilder</span> <span class="hljs-operator">=</span> QueryBuilders.termQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;dean&quot;</span>);<br>        searchSourceBuilder.query(termQueryBuilder);<br>        <span class="hljs-comment">// 设置查询超时时间</span><br>        searchSourceBuilder.timeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeValue</span>(<span class="hljs-number">60</span>, TimeUnit.SECONDS));<br><br>        searchRequest.source(searchSourceBuilder);<br>        <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">searchResponse</span> <span class="hljs-operator">=</span> restHighLevelClient.search(searchRequest,RequestOptions.DEFAULT);<br>        System.out.println(JSON.toJSONString(searchResponse.getHits()));<br>        System.out.println(<span class="hljs-string">&quot;===============&quot;</span>);<br>        <span class="hljs-keyword">for</span> (SearchHit documentFields : searchResponse.getHits().getHits()) &#123;<br>            System.out.println(documentFields.getSourceAsMap());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 这个就是searchReponse.getHits()</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;fragment&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hits&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;fragment&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;highlightFields&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;matchedQueries&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;primaryTerm&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;rawSortValues&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1.540445</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;seqNo&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">-2</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;sortValues&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;sourceAsMap&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;dean&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;sourceAsString&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&#123;\&quot;age\&quot;:1,\&quot;name\&quot;:\&quot;dean\&quot;&#125;&quot;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;sourceRef&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;fragment&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-keyword">true</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;_doc&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">-1</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;maxScore&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1.540445</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalHits&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;relation&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;EQUAL_TO&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><blockquote><p>数据问题？数据库获取，消息队列获取，都可以成为数据源</p></blockquote><p>爬取数据：获取请求返回的页面信息，筛选出我们想要的数据</p><p><strong>jsoup包</strong></p><ol><li><p>导入依赖</p></li><li><p>写一个爬取网页的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dean.deanjd.utils;<br><br><span class="hljs-keyword">import</span> com.dean.deanjd.pojo.Content;<br><span class="hljs-keyword">import</span> org.jsoup.Jsoup;<br><span class="hljs-keyword">import</span> org.jsoup.nodes.Document;<br><span class="hljs-keyword">import</span> org.jsoup.nodes.Element;<br><span class="hljs-keyword">import</span> org.jsoup.select.Elements;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HtmlPraseUtils</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlPraseUtils</span>().PraseJD(<span class="hljs-string">&quot;java&quot;</span>).forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Content&gt;  <span class="hljs-title function_">PraseJD</span><span class="hljs-params">(String keywords)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        HashMap&lt;String, String&gt; header = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        header.put(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>);<br>        header.put(<span class="hljs-string">&quot;Accept-Language&quot;</span>, <span class="hljs-string">&quot;zh-cn,zh;q=0.5&quot;</span>);<br>        header.put(<span class="hljs-string">&quot;Accept-Charset&quot;</span>, <span class="hljs-string">&quot;GB2312,utf-8;q=0.7,*;q=0.7&quot;</span>);<br>        header.put(<span class="hljs-string">&quot;Connection&quot;</span>, <span class="hljs-string">&quot;keep-alive&quot;</span>);<br>        header.put(<span class="hljs-string">&quot;cookie&quot;</span>,<span class="hljs-string">&quot;qrsc=3&quot;</span>);<br>        header.put(<span class="hljs-string">&quot;user-agent&quot;</span>, <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36&quot;</span>);<br>        <span class="hljs-comment">// 构建url</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://search.jd.com/Search?keyword=&quot;</span> + keywords;<br><br>        <span class="hljs-comment">// 解析网页 （jsoup返回的Document就是浏览器的document对象）</span><br>        <span class="hljs-comment">// 直接请求会跳转至登录界面因为请求头里没有cookie或者token请求会被拦截</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> Jsoup.connect(url).headers(header).get();<br>        <span class="hljs-type">Element</span> <span class="hljs-variable">jGoodsList</span> <span class="hljs-operator">=</span> document.getElementById(<span class="hljs-string">&quot;J_goodsList&quot;</span>);<br>        <span class="hljs-comment">// 获取所有的li标元素</span><br>        <span class="hljs-type">Elements</span> <span class="hljs-variable">elements</span> <span class="hljs-operator">=</span> jGoodsList.getElementsByTag(<span class="hljs-string">&quot;li&quot;</span>);<br>        <span class="hljs-comment">// 获取元素中的内容，这里的el就是每一个li标签了</span><br>        ArrayList&lt;Content&gt; goodList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Element el : elements) &#123;<br>            <span class="hljs-comment">// 关于这种图片特别多的网站，所有的图片都是延迟加载的</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">img</span> <span class="hljs-operator">=</span> el.getElementsByTag(<span class="hljs-string">&quot;img&quot;</span>).eq(<span class="hljs-number">0</span>).attr(<span class="hljs-string">&quot;data-lazy-img&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> el.getElementsByClass(<span class="hljs-string">&quot;p-price&quot;</span>).eq(<span class="hljs-number">0</span>).text();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">title</span> <span class="hljs-operator">=</span> el.getElementsByClass(<span class="hljs-string">&quot;p-name&quot;</span>).eq(<span class="hljs-number">0</span>).text();<br><br>            <span class="hljs-type">Content</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Content</span>();<br>            content.setImg(img);<br>            content.setPrice(price);<br>            content.setTitle(title);<br>            goodList.add(content);<br>        &#125;<br>        <span class="hljs-keyword">return</span> goodList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说一下这里需要注意的问题</p><ol><li>现在的网页想要请求服务器，后端服务器会对请求先进行拦截，看你有没有携带cookie或者token，如果没有cookie或者token直接拒绝访问请求，要求重新登录。所以这里有的时候是不能直接进行connect的有的时候要设置头部信息</li><li>一般有大量图片的网站，他们的图片都不是直接加载的，都是懒加载，所以想要获取图片的时候要注意它对应的属性</li><li>通过connect获得页面后我们就可以像js一样操作页面了<ul><li>getElementsByTag获取指定的标签</li><li>getElementById获取指定id的元素</li><li>el.getElementsByTag(“img”).eq(0).attr(“data-lazy-img”)，意思是获取img标签里的data-lazy-img的属性值</li><li>el.getElementsByClass(“p-price”).eq(0).text();获取类p-price的文字，eq(0）代表第一个</li></ul></li></ol></li><li><p>编写服务层将爬取到的数据插入到es</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把解析的数据放到es中，并返回是否插入成功</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">praseContent</span><span class="hljs-params">(String keywords)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 解析数据</span><br>        List&lt;Content&gt; contentList = htmlPraseUtils.PraseJD(<span class="hljs-string">&quot;java&quot;</span>);<br>        <span class="hljs-type">BulkRequest</span> <span class="hljs-variable">bulkRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BulkRequest</span>();<br>        bulkRequest.timeout(<span class="hljs-string">&quot;2m&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Content content : contentList) &#123;<br>            bulkRequest.add(<br>                <span class="hljs-comment">// 需要操作的数据库</span><br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;good_list&quot;</span>)<br>                <span class="hljs-comment">// 往数据库插入的内容</span><br>                            .source(JSON.toJSONString(content), XContentType.JSON)<br>            );<br>        &#125;<br>        <span class="hljs-comment">// 执行请求</span><br>        <span class="hljs-type">BulkResponse</span> <span class="hljs-variable">responses</span> <span class="hljs-operator">=</span> restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);<br>        <span class="hljs-keyword">return</span> !responses.hasFailures();<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>查找数据</p><p>前面我们已经爬取到了数据，并 把数据存到了es里面，现在我们要从es里面是把数据读出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">指定搜索哪个索引<br>        <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">searchRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;good_list&quot;</span>);<br><br>        <span class="hljs-comment">// 新建一个搜索</span><br>        <span class="hljs-type">SearchSourceBuilder</span> <span class="hljs-variable">searchSourceBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchSourceBuilder</span>();<br><br>        <span class="hljs-comment">// 构造搜索条件</span><br>        <span class="hljs-type">TermQueryBuilder</span> <span class="hljs-variable">termQueryBuilder</span> <span class="hljs-operator">=</span> QueryBuilders.termQuery(<span class="hljs-string">&quot;title&quot;</span>, keywords);<br><br>        <span class="hljs-comment">// 指定搜索的分页</span><br>        searchSourceBuilder.from(pageNum);<br>        searchSourceBuilder.size(pageSize);<br><br>        <span class="hljs-comment">// 根据查询条件构造出一个完整的查询</span><br>        searchSourceBuilder.query(termQueryBuilder);<br>        searchSourceBuilder.timeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeValue</span>(<span class="hljs-number">60</span>, TimeUnit.SECONDS));<br><br>        <span class="hljs-comment">//  把这个完整的搜索和索引结合起来</span><br>        searchRequest.source(searchSourceBuilder);<br>        <span class="hljs-comment">// 客户端执行搜索</span><br>        <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">searchResponse</span> <span class="hljs-operator">=</span> restHighLevelClient.search(searchRequest,RequestOptions.DEFAULT);<br><br>        ArrayList&lt;Map&lt;String, Object&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 获取返回的结果</span><br>        <span class="hljs-keyword">for</span> (SearchHit hit : searchResponse.getHits().getHits()) &#123;<br>            list.add(hit.getSourceAsMap());<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>前端调用后端es查询的接口，前端拿到数据后直接把数据渲染到模板上去。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jetlinks</title>
    <link href="/2022/03/12/jetlinks/"/>
    <url>/2022/03/12/jetlinks/</url>
    
    <content type="html"><![CDATA[<h1 id="Jetlinks"><a href="#Jetlinks" class="headerlink" title="Jetlinks"></a>Jetlinks</h1><p>消息上报流程</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\jetlinks.assets\image-20210830092842457.png" alt="image-20210830092842457"></p><blockquote><p>设备消息对应事件总线topic</p></blockquote><p>协议包将设备上报的报文解析成平台统一处理的消息后，会将消息转换为对应的topic，并发送到对应的事件总线，可以同过从事件总线订阅消息来处理这些消息。</p><p><strong>注意</strong>：</p><ol><li>此topic和mqtt的topic没有任何关系，仅仅作为内部通知方式。</li></ol><h2 id="设备接入流程"><a href="#设备接入流程" class="headerlink" title="设备接入流程"></a>设备接入流程</h2><p><img src="http://doc.jetlinks.cn/assets/img/device-flow.ab1da967.svg" alt="flow">    </p><h2 id="Reactor中的Mono和Flux"><a href="#Reactor中的Mono和Flux" class="headerlink" title="Reactor中的Mono和Flux"></a>Reactor中的Mono和Flux</h2><h3 id="相应流的特点"><a href="#相应流的特点" class="headerlink" title="相应流的特点"></a>相应流的特点</h3><ol><li>响应流必须是无阻塞的</li><li>响应流必须是一个数据流</li><li>他必须可以异步执行</li><li>他也应该可以处理背压</li></ol><blockquote><p>什么是背压</p></blockquote><p>背压是一个反应流的重要概念，可以理解为生产者可以感受到消费者消费的压力，并根据压力进行动态的调整生产速率。如下图：</p><p><img src="C:\Users\Lenovo\hexo-blog\source_posts\jetlinks.assets\image-20210831230354966.png" alt="image-20210831230354966"></p><h3 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h3><p>由于向应流的特点，我们不能在返回一个简单的POJO对象来表式结果了。必须返回一个java中类似Future的概念。在有结果可用时通知消费者进行消费响应。Reactor中这种规范被定义为Publisher<T> ,Publisher<T>是一个可以提供0-N个序列元素的提供者，并根据其订阅者Subscriber<super T>的需求进行推送。 一个publisher支持多个订阅者，并可以根据订阅者的逻辑进行判断推送元素序列，如下面的Exel表格。</p><p>​    <img src="C:\Users\Lenovo\hexo-blog\source_posts\jetlinks.assets\image-20210831231128802.png" alt="image-20210831231128802"></p><p> <strong>我的理解</strong>：A1到A9是发布者，A10-A13是订阅者，当只有发布者时是没有任何意义的，就比如这个例子里面，如果没有订阅者的话，这些数字就是毫无意义的，只有有了订阅者这些数据才是有意义的，这就像廖雪峰说的惰性计算，在前面是不进进行计算的，只有到了订阅这里才会计算。    </p><p>而Mono和Flux都是publisher在reactor 3 实现。publisher提供了subscribe方法，允许消费者在有结果可用的时候进行消费。如果没有消费者时不做作任何事情。他根据消费者的情况进行响应。publisher可以返回零个或者多个，甚至可能是无限个，为了更清楚的表示返回结果就引入了两个模型Mono和Flux .</p><h3 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h3><p>他是一个可以发出0-n个元素组成的异步序列的publisher，可以被onError或者onCompelete信号所终止，在响应流中有三种给下游消费者调用的方法，onNext,onCompelete,onError.下面这张图表示了Flux的抽象模型：</p><p><img src="https://segmentfault.com/img/bVbOXFm" alt="img"></p><p>就是说流像一个流水线，他们在传送带上等着被处理，operator就相当于流水线工人，当流水线执行完时，这条流水线就会终止，如果在流水作业中发生异常也会提前终止。只不过一次时正常结束，一个是异常终止。</p><blockquote><p>与之前写法对比</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;ClientUser&gt; <span class="hljs-title function_">allUsers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientUser</span>(<span class="hljs-string">&quot;felord.cn&quot;</span>, <span class="hljs-string">&quot;reactive&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientUser</span>(<span class="hljs-string">&quot;Felordcn&quot;</span>, <span class="hljs-string">&quot;Reactor&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个list 里面也有很多个item但是呢如果你想获得item你得主动的去get，获取或者不获取取决于自己</p><p><strong>流式数据处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Stream&lt;ClientUser&gt; <span class="hljs-title function_">allUsers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span>  Stream.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientUser</span>(<span class="hljs-string">&quot;felord.cn&quot;</span>, <span class="hljs-string">&quot;reactive&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientUser</span>(<span class="hljs-string">&quot;Felordcn&quot;</span>, <span class="hljs-string">&quot;Reactor&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>和传统的内容一样但是呢，这个更像是吃旋转小火锅，他是一个流，不需要我们去主动的get，不过我们可以搭配着吃。</p><p><strong>反应式数据处理</strong></p><p>在reactor中我们可以改写成Flux:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Flux&lt;ClientUser&gt; <span class="hljs-title function_">allUsers</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> Flux.just(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientUser</span>(<span class="hljs-string">&quot;felord.cn&quot;</span>, <span class="hljs-string">&quot;reactive&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientUser</span>(<span class="hljs-string">&quot;Felordcn&quot;</span>, <span class="hljs-string">&quot;Reactor&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这根旋转小火锅又有区别了，旋转小火锅有的的东西我们不喜欢吃但是他仍然会有， 那么Flux就是需要我们点餐，只点我们喜欢吃的，而且可以根据我们的饭量进行调整，如果没有食客订餐那么厨师就什么都不用做了。当然flux的特性不止这一点。</p><h3 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h3><p>Mono是一个可以发出0-1个元素的publisher，可以被onCompelete和onError信号所终止</p><p><img src="https://segmentfault.com/img/bVbOXFn" alt="img"></p><p>这里整体和Flux差不多，就是Mono只会发出0-1个元素。 也就是说就是有或者没有。    </p><p><strong>传统数据处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ClientUser <span class="hljs-title function_">currentUser</span> <span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> isAuthenticated ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientUser</span>(<span class="hljs-string">&quot;felord.cn&quot;</span>, <span class="hljs-string">&quot;reactive&quot;</span>) : <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Optional 的处理方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Optional&lt;ClientUser&gt; <span class="hljs-title function_">currentUser</span> <span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> isAuthenticated ? Optional.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientUser</span>(<span class="hljs-string">&quot;felord.cn&quot;</span>, <span class="hljs-string">&quot;reactive&quot;</span>))<br>            : Optional.empty();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>Optional</code>我觉得就有反应式的那种味儿了，当然它并不是反应式。当我们不从返回值<code>Optional</code>取其中具体的对象时，我们不清楚里面到底有没有，但是<code>Optional</code>是一定客观存在的, 不会出现 <strong>NPE</strong> 问题。</p><p><strong>反应式数据处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Mono&lt;ClientUser&gt;currentUser&#123;<br>    <span class="hljs-keyword">return</span> isAuthenticated ？Mono.just(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientUser</span>(<span class="hljs-string">&quot;felord.cn&quot;</span>,<span class="hljs-string">&quot;reactive&quot;</span>))<br>           ：Mono.empty();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    Mono、Flux是推送给消费者的，而我们之前则是通过拉的方式。这种范式让数据有了新特性，比如基于发布订阅的事件驱动、异步驱动、背压等等。同时我们也可以通过map,flatmap去操作他们。    </p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty</title>
    <link href="/2022/03/12/netty/"/>
    <url>/2022/03/12/netty/</url>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><blockquote><p>什么是套接字</p></blockquote><p>所谓套接字（socket），就是对网络中<strong>不同主机上的应用进程之间进行双向通信的断点</strong>的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制  。</p><p>socket原意是“插座”或“插孔”，在网络中每台服务器相当于一间房子，房子中有着不同的插口，每个插口都有一个编号，且负责某个功能。例如充电插口、网线插口、电话插口等。也就是说，使用不同的插口连接到对应的插口，就可以获得对应的服务。其实，插口就是socket服务，插口的编号就是端口号，而插头也是一个socket服务。</p><p><img src="1.png" alt="1"></p><p>所以说，socket的含义就是两个应用程序通过一个双向的通信连接实现数据的交换，连接的一段就是一个socket，又称套接字。实现一个socket连接通信至少需要两个套接字，一个运行在服务器（插孔），一个运行在客户端（插头）</p><p><strong>socket用于描述IP地址和端口，是一个通信链的句柄</strong>。应用程序通过套接字向网络发出请求或应答网络请求。注意的是套接字既不是程序也不是协议，只是操作系统提供给通信层的一组抽象API接口。</p><blockquote><p>C10K问题</p></blockquote><p>即单机1万个并发连接问题。互联网的基础就是网络通信，最初的服务器都是基于进程/线程模型的，新到来一个TCP连接就需要分配一个进程或线程。然而，进程又是操作系统最昂贵的资源，一台机器无法创建很多的进程。</p><p>C10K问题的最大特点是，设计不够良好的程序，其性能和连接数及机器性能的关系往往是非线性的。</p><p>C10K问题本质上是操作系统的问题，对于Web1.0/2.0时代的操作系统而言，传统的同步堵塞I/O模型都是一样的，处理的方式都是Requests Per Second，并发10K和100的区别关键在于CPU。创建的进程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、堵塞），进程或线程上下文切换消耗大，导致操作系统崩溃，这就是C10K问题的本质。</p><p>从纯粹网络编程技术角度来看，解决C10K问题的主要思路有两点</p><ul><li>每个进程或线程处理一个连接，即一个是对于每个连接处理分配一个独立的线程或进程</li><li>用同一个进程或线程来同时处理若干个连接，即IO多路复用</li></ul><blockquote><p>Socket通信</p></blockquote><p><strong>Socket是应用层于TCP/IP协议簇通信的中间抽象层，是一组接口</strong>。在设计模式中就是门面模式。Socket将复杂的TCP/IP协议簇隐藏在接口后面，对于用户而言，一组接口即可让Socket组织数据，以符合指定的协议。</p><p><img src="2.png" alt="2"></p><p><strong>解释</strong>：就相当于JDBC的作用，为了让用户方便使用，在中间加了一层，简化了用户的操作，用户不在需要关心其他的</p><ul><li><p>TCP/IP</p><p>Transmission Control Protocol/Internet Protocol—传输控制协议/网间协议，是一个工业标准的协议集 ，是为广域网WAN而设计的</p></li><li><p>UDP</p><p>用户数据报协议Hy pertext Transfer Protocol，是与TCP相对应得协议，属于TCP/IP协议簇得一员</p></li><li><p>HTTP</p><p>超文本传输协议 Hypertext Transfer Protocol是互联网的基础，也是手机网络协议之一，HTTP协议是建立在TCP协议之上的一种应用</p></li><li><p>Socket</p><p>**套接字是对TCP/IP协议的封装，自身并非协议而是一套调用的规范(API)**。通过套接字才能使用TCP/IP协议</p></li></ul><p><strong>套接字作为网络底层核心，也是TCP/IP以及底层协议的实现通道，他是计算机网络编程的基础，TCP/UDP收发消息都靠他</strong>。例如web服务器底层依赖他、关系型数据库底层依赖他、微信即时通信依赖他。。。。</p><blockquote><p>工作原理</p></blockquote><p>服务端首先初始化Socket<code>socket()</code>，然后与端口绑定<code>bind()</code>，再对端口进行监听<code>listen()</code>，接着调用<code>accept()</code>堵塞等待客户端连接。此时，若有一个客户端初始化了一个Socket，然后连接服务端<code>connect()</code>。若连接成功，此时客户端与服务端的连接就建立了。客户端发送请求<code>write()</code>，服务端接收请求并处理<code>read()</code>，然后将回应发送给客户端<code>write()</code>，客户端读取数据<code>read()</code>，最后关闭连接<code>close()</code>，一次交互结束。</p><p><img src="3.png" alt="3"></p><blockquote><p>读写过程</p></blockquote><p>当客户端和服务端使用TCP协议进行通信时，客户端封装一个请求对象<code>req</code>，将其序列化成为字节数组，然后通过套接字socket将字节数组发送到服务端，服务端通过套接字socket读取到字节数组，再反序列化成为请求对象<code>req</code>后进行处理，处理完毕后生成一个响应对应的<code>res</code>，将响应对象<code>res</code>序列化成字节数组，然后通过套接字将字节数组发送给客户端，客户端通过套接字socket读取到字节数组，再反序列化成为响应对象。</p><p><img src="4.png" alt="4"></p><p>平时我们使用的套接字只是一个引用（一个对象ID），这个套接字对象实际是放在操作系统内核中。其内部有两个重要的缓冲结构，一个是读缓冲<code>read buffer</code>,一个是写缓冲<code>write buffer</code>,他们都是有限大小的数组结构。但对客户端的socket写入字节数组时，即序列化后的请求消息对象<code>req</code>，是将字节数组拷贝到内核区套接字对象的<code>write buffer</code>中，内核网络模块会有单独的线程负责不停地将<code>write buffer</code>的数据拷贝到网卡硬件，网卡硬件再将数据传送到网线，经过一系列路由器和交换机，最终送达服务器的网卡硬件中。</p><p>同样，服务端内核的网络模块也有单独的线程不停地接收到数据拷贝到套接字的<code>read buffer</code>中等待用户层来读取，最终服务端的用户进程通过socket引用的<code>read()</code>方法将<code>read buffer</code>中的数据拷贝到用户程序内部中，进行反序列化成请求对象<code>req</code>进行处理。然后服务端将处理后的相应对象，走一个相反的流程发送给客户端。</p><p><img src="5.png" alt="5"></p><h2 id="操作系统的IO模型"><a href="#操作系统的IO模型" class="headerlink" title="操作系统的IO模型"></a>操作系统的IO模型</h2><ul><li>阻塞IO(Blocking IO)</li><li>非阻塞IO(Nonblocking IO)</li><li>I/O复用(I/O Multiplexing)</li><li>信号驱动IO(signal driven I/O)</li><li>异步IO(Asynchronous IO)</li></ul><p>对于一个读操作来说，一般会经过下面两个过程：</p><ol><li>等待数据就绪．比如说，对于一个网络连接来说，就是等待数据通过连接到达主机．当数据到达主机时，把数据拷贝到内核中的缓冲区．</li><li>将数据从内核拷贝到进程．即把数据从内核的缓冲区拷贝到应用程序的缓冲区．</li></ol><h1 id="netty介绍"><a href="#netty介绍" class="headerlink" title="netty介绍"></a>netty介绍</h1><ol><li>netty是由jboss提供的一个由Java开源框架，现为GitHub的独立项目。</li><li>__netty是一个异步的、基于事件驱动的网络应用框架__，用以快速开发高性能、高可靠的网阔io程序</li><li>netty主要针对在tcp协议下，面向clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用     </li><li>netty本质是一个NIO框架，适用于服务器通信相关的多种应用场景</li><li>要彻底理解netty，需要先学习NIO，这样我们才能阅读netty的源码</li></ol><h2 id="高性能的体现"><a href="#高性能的体现" class="headerlink" title="高性能的体现"></a>高性能的体现</h2><ol><li><p>IO线程模型</p><p>使用reactor模式，同步非阻塞。这决定了可以使用最少的资源做更多的事。</p></li><li><p>内存零拷贝</p><p>使用直接缓存（Zero-copy，在操作数据时不需要将数据buffer从一个内存区域拷贝到另一个内存区域，因为少了一次内存的拷贝，因此CPU的效率就得到提升）</p></li><li><p>内存池设计</p><p>申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况</p></li><li><p>串行化读写</p><p>串行化处理socket读写避免锁，即一个指定socket的消息是串行化处理的。这样性能比多个线程同时处理一个socket对应消息要好，因为多线程处理会有锁</p></li><li><p>提供对protobuf等高性能序列化协议的支持</p></li></ol><blockquote><p>IO多路复用</p></blockquote><p>IO 多路复用有三种实现，在介绍select、poll、epoll之前，首先介绍一下Linux操作系统中<strong>基础的概念</strong>：</p><ul><li>用户空间和内核空间</li><li>进程切换</li><li>进程的阻塞</li><li>文件描述符</li><li>缓存 I/O</li></ul><blockquote><p>用户空间/内核空间</p></blockquote><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。 操作系统的核心是内核，独立于普通的<strong>应用程序</strong>，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。(内核就是应用程序，不过他是独立于普通应用程序的，他的权限也很高)。为了保证内核的安全，操作系统将虚拟内存空间划分为了两部分，一部分内核空间，一部分用户空间。</p><p>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><blockquote><p>进程切换</p></blockquote><p>为了控制进程的执行，内核必须有能力挂起正在CPU运行的进程，并恢复以前挂起的某个进程的执行。这种行为称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密联系的，并且进程切换是非常消耗资源的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li><p>保存处理机上下文，包括程序计数器和其他寄存器。</p></li><li><p>更修PCB信息</p><p><strong>PCB</strong>：process control block 他是进程实体的一部分，是操作系统最重要的记录性数据结构。他是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建过程时，建立PCB，伴随进程运行的全过程，直到进程撤销而撤销</p></li><li><p>把进程的PCB移入相应的队列，如就绪、在某事件阻塞队列</p></li><li><p>选择另一个进程执行，更新其PCB</p></li><li><p>更新内存管理的数据结构</p></li><li><p>恢复处理机上下文</p></li></ol><blockquote><p>进程阻塞</p></blockquote><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作完成、新数据尚未到达或无新工作等，则由系统自动执行阻塞原语Block，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行状态的进程（获得了CPU资源），才能将其转换为阻塞状态。当进入阻塞状态，是不占用系统资源的。</p><blockquote><p>文件描述符</p></blockquote><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p><blockquote><p>缓存IO</p></blockquote><p>缓存IO又称标准IO，大多数文件系统的默认IO都是缓存IO，在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><blockquote><p>缓存io的缺点</p></blockquote><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</p><blockquote><p>什么是IO多路复用机制</p></blockquote><ul><li><p>IO多路复用<strong>是一种同步IO模型</strong>，实现一个线程可以监视多个文件句柄。</p><p>是什么：是一种同步IO模型</p><p>实现了什么：一个线程监听多个文件句柄</p></li><li><p>没有文件句柄就绪就会阻塞应用程序，交出CPU</p></li></ul><p><strong>多路是指网络连接，复用是指同一个线程</strong></p><blockquote><p>为什么会有IO复用机制</p></blockquote><p>没有IO多路复用机制时，有BIO、NIO两种实现机制，但是他们都有一些问题</p><h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p><strong>同步</strong>：就是烧开水，要自己来看开没开；</p><p><strong>异步</strong>：就是水开了，然后水壶响了通知你水开了。</p><p><strong>阻塞</strong>：是烧开水的过程中你不能干其他的事情（即你被阻塞住了）</p><p><strong>非阻塞</strong>：是烧开水的过程里可以干其他的事情。</p><p><strong>同步与异步说的是你获得水开了的方式不同。阻塞与非阻塞说的是你得到结果之前不能干其他的事情</strong></p><ol><li><p>同步</p><p><img src="6.png"></p><p><strong>一个请求过去，必须等结果回来才可以做其他的事情</strong></p></li><li><p>异步</p><p><img src="7.png"></p><p><strong>一个请求过去，不会因为服务器暂时没有返回结果而等待，反而可能是紧着这发另一条请求过去，或者紧接着执行下面的代码</strong></p></li></ol><h2 id="netty是一个怎样的框架"><a href="#netty是一个怎样的框架" class="headerlink" title="netty是一个怎样的框架"></a>netty是一个怎样的框架</h2><ul><li>netty底层依然是TCP/IP协议</li><li>在上一层包了一个JDK原生的IO和网络</li><li>在上一层是一个NIO的IO和网络</li><li>最上面一层才是netty</li><li><img src="8.png" alt="8">NIO对Java的IO进行了封装和优化，然后netty对 NIO有进行了封装和优化</li></ul><h2 id="java-IO编程"><a href="#java-IO编程" class="headerlink" title="java IO编程"></a>java IO编程</h2><blockquote><p>I/O模型基本说明</p></blockquote><ol><li><p>I/O模型简单来说就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</p></li><li><p>Java共支持三种网络编程模型/IO模式：BIO、NIO、AIO</p></li><li><p>Java BIO：同步并阻塞（传统阻塞型），服务器实现模式为一个链接一个线程，及客户端由链接请求时服务器会启动一个线程进行处理，如果这个链接不做任何事情就会造成不必要的线程开销(<strong>适用于链接数目比较少且固定的架构</strong>.)</p><p><img src="9.png"></p></li><li><p>java NIO: 同步非阻塞,服务器实现模式为一个线程处理多个请求,即客户端发送的连接请求都会注册到多路复用器上,多路复用器轮询到链接由I/O请求就进行处理__适用于连接数目比较多且连接时间比教短,,轻操作__</p><p><img src="10.png"></p></li><li><p>Java AIO(NIO.2): 异步非阻塞,AIO引入异步通道的概念,采用了Proactor模式,简化了程序 的编写,有效的请求才会请求起动线程,他的特点九是先由操作系统完成后才会通知服务器程序启动线程处理,一般适合于链接数较多,时间较长的应用.  </p><p><strong>适用于连接数目多,且连接比较长,,,重操作</strong></p></li></ol><h3 id="javaBIO工作机制"><a href="#javaBIO工作机制" class="headerlink" title="javaBIO工作机制"></a>javaBIO工作机制</h3><ol><li>服务器端启动一个ServerSocket</li><li>客户端启动Socket对服务器进行通讯，默认情况下服务器需要对每个客户建立一个线程与之通信</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待或者遭到拒绝</li><li>如果有响应客户端的线程会等待请求结束后才继续执行 </li></ol><h3 id="java-NIO基本介绍"><a href="#java-NIO基本介绍" class="headerlink" title="java NIO基本介绍"></a>java NIO基本介绍</h3><ol><li><p>Java NIO全称Java non-blocking IO，是指JDK提供的新API。从JDK1.4开始，就Java提供了尊贵的输入/输出的新特性，被普遍NIO（即NewIO），是同步非阻塞的。</p></li><li><p><code>NIO</code>相关类都被提包**<code>java.nio</code>**及子包下，并且对原<code>java.io</code>包中的很多类进行改写。</p></li><li><p><code>NIO</code>有三大核心部分： <code>Channel</code>（绳索）、<code>Buffer</code>（绳索）、<code>Selector</code>（选择器）。</p></li><li><p>NIO是采集的，或者汇总块的编制的。可以读取到一段时间的数据，需要在中后期移动，需要增加了处理过程中的数据，使用它可以非编程的一个式的高伸缩性网络。</p></li><li><p><code>NIO</code>是面向缓冲区，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可以在缓冲区前后移动，</p><p>这就增强了处理的灵活性，使他可以提供非阻塞是的高伸缩性网络</p></li></ol><h3 id="NIO三大核心原理"><a href="#NIO三大核心原理" class="headerlink" title="NIO三大核心原理"></a>NIO三大核心原理</h3><ul><li><p>每一个channel都会对应一个Buffer</p></li><li><p>Selector对应一个线程，一个线程对应多个channel连接</p></li><li><p>多个channel可以注册到同一个selector</p></li><li><p>程序切换到哪一个channel是由事件决定的，event就是一个重要的概念</p></li><li><p>selector会根据不同的事件在各个通道上切换</p></li><li><p>Buffer就是一个内存块，底层是有一个数组</p></li><li><p>数据的读取写入是通过Buffer，这个和BIO，BIO中要么是输入流，或者是输出流，不能双向，但是NIO的buffer是可以读写的，需要flip方法切换</p></li><li><p>channel是双向的，可以返回底层操作系统的情况，比如Linux，底层的操作系统通道就是双向的。</p><p><img src="11.png" alt="11"></p></li></ul><h3 id="NIO和BIO的比较"><a href="#NIO和BIO的比较" class="headerlink" title="NIO和BIO的比较"></a>NIO和BIO的比较</h3><ol><li>BIO以流的方式处理数据，而NIO以块的方式处理数据，块IO的效率比流IO高很多</li><li>BIO是阻塞的，NIO是非阻塞的</li><li>BIO基于字节流和字符流进行操作，而NIO基于channel（通道）和buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道中。Selector选择器用于就按听多个通道的事件。比如连接请求，数据到达等，因此使用单线程就可以监听多个客户端通道。</li></ol><h3 id="缓冲区的基本介绍"><a href="#缓冲区的基本介绍" class="headerlink" title="缓冲区的基本介绍"></a>缓冲区的基本介绍</h3><p>buffer：缓冲区本质上是一个可以读写的内存块，可以理解成是一个容器数组（含数组）该对象提供了一组方法可以轻松的使用内存块。</p><p><img src="12.png" alt="12"></p><p>buffer类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</p><ul><li>容量：可以容纳的最大数据量</li><li>limit：表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作</li><li>position：位置，下一个要被读或写的元素索引</li><li>mark：标记</li></ul><h3 id="通道channel"><a href="#通道channel" class="headerlink" title="通道channel"></a>通道channel</h3><blockquote><p>基本介绍</p></blockquote><h4 id="NIO的通道类似于流，但是有些区别"><a href="#NIO的通道类似于流，但是有些区别" class="headerlink" title="NIO的通道类似于流，但是有些区别"></a>NIO的通道类似于流，但是有些区别</h4><ul><li>通道可以同时进行读写，而流只能读或者写 </li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读取数据，也可以写数据到缓冲</li></ul><p><img src="13.png" alt="13"></p><h4 id="channel基本使案例"><a href="#channel基本使案例" class="headerlink" title="channel基本使案例"></a>channel基本使案例</h4><p><img src="14.png" alt="14"></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOFileChannel01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>         <span class="hljs-comment">//创建一个buffer</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-comment">//往buffer里面写数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hi! Dean&quot;</span>;<br>        byteBuffer.put(str.getBytes());<br>        <span class="hljs-comment">//写完以后buffer反转</span><br>        byteBuffer.flip();<br>        <span class="hljs-comment">//创建一个输出流通过输出流获取一个channel并把buffer里面的数据写到channel</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:\\file0..txt&quot;</span>);<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileOutputStreamChannel</span> <span class="hljs-operator">=</span> fileOutputStream.getChannel();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> fileOutputStreamChannel.write(byteBuffer);<br>        fileOutputStream.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过一个Stream获取Channel</strong></p><h4 id="本地文件读"><a href="#本地文件读" class="headerlink" title="本地文件读"></a>本地文件读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOFileChannel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//从指定文件读取数据到bytebuffer</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\file01.txt&quot;</span>);<br>        <span class="hljs-comment">//根据文件创建一个文件输入流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        <span class="hljs-comment">//根据文件输入流获得一个channel---&gt;实际类型是FileChannelIpml</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">inputChannle</span> <span class="hljs-operator">=</span> fileInputStream.getChannel();<br>        <span class="hljs-comment">//根据文件的长度创建一个buffer</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate((<span class="hljs-type">int</span>)file.length());<br>        <span class="hljs-comment">//读取channel并写入到buffer</span><br>        inputChannle.read(byteBuffer);<br>        <span class="hljs-comment">//将字节 转换成String</span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array()));<br>        <span class="hljs-comment">//关闭文件输入流</span><br>        fileInputStream.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用一个buffer实现文件备份"><a href="#用一个buffer实现文件备份" class="headerlink" title="用一个buffer实现文件备份"></a>用一个buffer实现文件备份</h4><p><img src="15.png" alt="15"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOFileChannel03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//指定文件</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\Lenovo\\.ssh\\id_rsa.pub&quot;</span>);<br>        <span class="hljs-comment">//读file</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        <span class="hljs-comment">//获取写channel</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileInputStreamChannel</span> <span class="hljs-operator">=</span> fileInputStream.getChannel();<br>        <span class="hljs-comment">//创建byte buffer</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate((<span class="hljs-type">int</span>) file.length());<br>        <span class="hljs-comment">//把channel里面的内容读并写到buffer里</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> fileInputStreamChannel.read(byteBuffer);<br>        System.out.println(read);<br>        <span class="hljs-comment">//创建一个输出流</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:\\file02.txt&quot;</span>);<br>        <span class="hljs-comment">//获取channel</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileOutputStreamChannel</span> <span class="hljs-operator">=</span> fileOutputStream.getChannel();<br>        <span class="hljs-comment">//把buffer里面的内容写到channel</span><br>        byteBuffer.flip();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> fileOutputStreamChannel.write(byteBuffer);<br>        fileInputStream.close();<br>        fileOutputStream.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用transferFrom复制"><a href="#使用transferFrom复制" class="headerlink" title="使用transferFrom复制"></a>使用transferFrom复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOFileChannel04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-comment">//创建相关流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\download\\rww02.jpg&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:\\download\\rww02_1.jpg&quot;</span>);<br>        <span class="hljs-comment">//获取对应得通道</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileInputStreamChannel</span> <span class="hljs-operator">=</span> fileInputStream.getChannel();<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileOutputStreamChannel</span> <span class="hljs-operator">=</span> fileOutputStream.getChannel();<br>        <span class="hljs-comment">//使用transferForm完成拷贝</span><br>       <span class="hljs-comment">//只不过是把操作封装了起来而已 fileOutputStreamChannel.transferFrom(fileInputStreamChannel,0,fileInputStreamChannel.size());</span><br>        <span class="hljs-comment">//close 相关得流和通道</span><br>        fileInputStream.close();<br>        fileOutputStream.close();<br>        fileInputStreamChannel.close();<br>        fileOutputStreamChannel.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Buffer和channel的注意细节"><a href="#Buffer和channel的注意细节" class="headerlink" title="Buffer和channel的注意细节"></a>Buffer和channel的注意细节</h3><ol><li>ByteBuffer支持类型化的put和get，put放入的是什么数据类型，get就应该使用相应的数据类型取出来。否则可能有bufferUnderflowException异常</li><li>可以将一个普通的Buffer转成只读Buffer</li><li>NIO还提供了MappedByteBuffer，可以让文件直接在堆外的内存终进行修改，而如何同步到文件由NIO来完成</li><li>NIO还支持通过多个buffer即buffer数组来完成读写操作。</li></ol><h3 id="buffer数组"><a href="#buffer数组" class="headerlink" title="buffer数组"></a>buffer数组</h3><blockquote><p>前面都是通过一个buffer完成的读写操作，NIO还支持多个buffer完成读写操作即 Scattering和Gathering</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScatteringAndGatheringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//使用ServerSocketChannel和SocketChannel网络</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">inetSocketAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">7000</span>);<br><br>        <span class="hljs-comment">//端口绑定到socket，启动,从ServerSocket通道获取Socket并绑定端口</span><br>        serverSocketChannel.socket().bind(inetSocketAddress);<br><br>        <span class="hljs-comment">//创建buffer数组</span><br>        ByteBuffer[] byteBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">//给byte buffer分配大小</span><br>        byteBuffer[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>        byteBuffer[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">//channel and buffer have been build and  wait client to test</span><br>        <span class="hljs-comment">//let channel be waiting</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">accept</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>        <span class="hljs-comment">//假定从客户端接收8个字节</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxlength</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-comment">//循环读取</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">byteRead</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(byteRead &lt; maxlength)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> accept.read(byteBuffer);<br>                byteRead += read;<br>                System.out.println(<span class="hljs-string">&quot;byteread=&quot;</span>+byteRead);<br>                <span class="hljs-comment">//打印这个buffer的position和limit</span><br>                Arrays.asList(byteBuffer).stream()<br>                        .map(buffer -&gt; <span class="hljs-string">&quot;position=&quot;</span>+buffer.position()+<span class="hljs-string">&quot;limit=&quot;</span>+buffer.limit())<br>                        .forEach(System.out::println);<br>                <span class="hljs-comment">//将buffer反转</span><br>                Arrays.asList(byteBuffer).stream()<br>                       .forEach(buffer -&gt; buffer.flip());<br>                <span class="hljs-comment">//将数据读出显示到客户端</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">byteWrite</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (byteWrite &lt; maxlength)&#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> accept.write(byteBuffer);<br>                    byteWrite += write;<br>                &#125;<br>                <span class="hljs-comment">//将所有的buffer的下标恢复一下初始值</span><br>                Arrays.asList(byteBuffer).stream()<br>                        .forEach(buffer -&gt; buffer.clear());<br>                System.out.println(<span class="hljs-string">&quot;byteRead=&quot;</span> + byteRead + <span class="hljs-string">&quot;byteWrite=&quot;</span> + byteWrite + <span class="hljs-string">&quot;maxLength=&quot;</span> + maxlength);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h3><blockquote><p>可以直接操作内存（堆外的内存）操作系统级</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MappedByteBuffer可以让文件直接在内存中（堆外内存）修改，操作系统不需要拷贝一次，系统级别的</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MappedByteBufferTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;D:\\file01.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">randomAccessFileChannel</span> <span class="hljs-operator">=</span> randomAccessFile.getChannel();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *FileChannel.MapMode.READ_WRITE : 使用读写模式</span><br><span class="hljs-comment">         * 0：可以修改的开始位置</span><br><span class="hljs-comment">         * 5：可以修改的内存大小，不是索引</span><br><span class="hljs-comment">         * mappedByteBuffer的实际类型是 DirectByteBUffer</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">mappedByteBuffer</span> <span class="hljs-operator">=</span> randomAccessFileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-type">byte</span>) <span class="hljs-string">&#x27;x&#x27;</span>);<br>        mappedByteBuffer.put(<span class="hljs-number">1</span>, (<span class="hljs-type">byte</span>) <span class="hljs-string">&#x27;b&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><blockquote><p>基本介绍</p></blockquote><ol><li>Java的NIO，用非阻塞的IO方式。可以用一个线程，处理多个客户端连接。就会用到selector</li><li>Selector能够检测多个注册的通道上是否有事件发生。（多个通道以事件的方式注册到同一个selector），如果有事件发生，便获取事件然后对每个事件进行相应的处理。这样就可以用一个单线程去管理多个通道，也就是管理多个通道与连接。</li><li>只有在连接有真正读写操作时，才会进行读写，就大大的减少了系统的开销，并且不必为每个连接就都创建一个线程，不用去维护多个线程。</li><li>避免了多线程的上下文切换，减少了时间开销。</li></ol><blockquote><p>注意事项</p></blockquote><ol><li>NIO中的ServerSocketChannel功能类似ServerSocket,SocketChannel功能类似Socket</li><li>selector相关方法说明<ul><li>selector.select()//阻塞</li><li>selector.scelect(1000)//阻塞1000毫秒，在1000后返回</li><li>selector.wakeup()//唤醒selector</li><li>selector.selectNow();//不阻塞立马返回</li></ul></li></ol><h3 id="NIO非阻塞网络编程原理分析图"><a href="#NIO非阻塞网络编程原理分析图" class="headerlink" title="NIO非阻塞网络编程原理分析图"></a>NIO非阻塞网络编程原理分析图</h3><p>NIO非阻塞网络编程相关的Selector SelectionKey ServerScoketChannel和SocketChannel关系梳理图</p><p><img src="16.png" alt="16"></p><blockquote><p>说明</p></blockquote><ol><li>当客户端连接时，会通过一个ServerSocketChannel得到一个SocketChannel</li><li>将socketChannel注册到Selector上register(Selector sel,int ops),一个selector上可以注册多个Socketchannel</li><li>注册后返回一个Selectionkey,会和该Selector关联（集合）</li><li>Selector进行监听，select方法有事件发生的通道的个数</li><li>进一步得到各个Selectionkey有时间发生的</li><li>再通过selectionKey反向获取SocketChannel channel()</li><li>可以通过得到的channel完成业务处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>         <span class="hljs-comment">//创建ServerSocketChannel ----&gt; ServerSocket</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><br>        <span class="hljs-comment">//得到一个Selector</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>        <span class="hljs-comment">//监听端口</span><br>        serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">6667</span>));<br><br>        <span class="hljs-comment">//设置为非阻塞</span><br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">//把serverSocketChannel和Selector关联起来,关心的事件为OP_ACCEPT</span><br>        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-comment">//循环等待连接</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br><br>            <span class="hljs-comment">//等待一秒钟，如果没有事件发生就返回</span><br>            <span class="hljs-keyword">if</span>(selector.select(<span class="hljs-number">1000</span>) == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;没有任何连接请求！！！&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//如果返回的&gt;0,就获取到相关得selectionKey集合</span><br>            <span class="hljs-comment">//如果&gt;0表示已经获取到关注的事件</span><br>            <span class="hljs-comment">//selector.selectKeys（）返回关注事件的集合</span><br>            <span class="hljs-comment">//通过selectionKeys反向获取通道</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br><br>            <span class="hljs-comment">//遍历selectionKeys</span><br>            Iterator&lt;SelectionKey&gt; selectionKeyIterator = selectionKeys.iterator();<br><br>            <span class="hljs-keyword">while</span> (selectionKeyIterator.hasNext())&#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> selectionKeyIterator.next();<br>                <span class="hljs-keyword">if</span>(selectionKey.isAcceptable())&#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>                    System.out.println(<span class="hljs-string">&quot;客户端连接成功生成了以一个channel&quot;</span> + socketChannel.hashCode());<br>                    socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                     socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="hljs-number">1024</span>));<br>                &#125;<br>                <span class="hljs-comment">//如果可以执行这一步说明已经建立过连接了，也就是已经关联过byte buffer了，可以直接通过key匹配到他关联的byte buffer</span><br>                <span class="hljs-keyword">if</span>(selectionKey.isReadable())&#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span>(SocketChannel) selectionKey.channel();<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> (ByteBuffer)selectionKey.attachment();<br>                    socketChannel.read(buffer);<br>                    System.out.println(<span class="hljs-string">&quot;from 客户端&quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array()));<br>                &#125;<br>                <span class="hljs-comment">//移除selectionKey,防止重复操作</span><br>                selectionKeyIterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>         <span class="hljs-comment">//得到一个网络通道</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br><br>        <span class="hljs-comment">//设置通道非阻塞</span><br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">inetSocketAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6667</span>);<br><br>        <span class="hljs-comment">//还没有连接成功</span><br>        <span class="hljs-keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;<br>            <span class="hljs-comment">//还没有完成连接</span><br>            <span class="hljs-keyword">while</span> (!socketChannel.finishConnect())&#123;<br>                System.out.println(<span class="hljs-string">&quot;因为连接需要时间客户端不会阻塞，可以做其他事情！！！！&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果连接成功就发送数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hi! Dean&quot;</span>;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(str.getBytes ());<br>        socketChannel.write(byteBuffer);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>SocketChannel向Selector注册成功后，Selector返回一个SelectionKey,<strong>可以通过selectionKey反向获取SocketChannel</strong></p><p>selector维护着三个selection keys集合</p><ol><li>key,包含着所有的selectionKey，当前所有注册到selector中的channel返回的注册关系selectionKey都包含在内，这个集合可以通过selector.keys()方法返回。</li><li>selectedKey，包含着一部分selectionKey，其中每一个Selectionkey所关联的channel在selection operation期间被检测出<strong>至少准备好了一个可以在兴趣集中匹配到的操作</strong>。这个集合可以通过调用selector.selectedKeys()方法返回。selected key 一定是key的一个子集</li><li>cancelled key也包含着一部分selectionKey，其中的每个selectionKey都已经被取消，但是所关联的channel还没有被撤销登记。cancelled key不能够被直接返回但也一定是key 的子集                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </li></ol><h3 id="SeverSocketChannel"><a href="#SeverSocketChannel" class="headerlink" title="SeverSocketChannel"></a>SeverSocketChannel</h3><ol><li><p>监听新进来的TCP连接通道</p></li><li><p>创建新的SocketChannel</p></li><li><p>ServerSocketChannel并不具备数据传输能力</p></li><li><p>创建ServerSocketChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该对象关联了一个未绑定的ServerSocket的通道</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServetSocketChannel.open();<br></code></pre></td></tr></table></figure></li><li><p>为ServerSocketChannel绑定监听端口号</p><p>JDK1.7前，需要调用ServerSocketChannel的socket方法，再调用bind()来进行关联</p><p> JDK1.7后，就可以直接调用ServerSocketChannel的bind()来进行端口绑定了。</p></li><li><p>ServerSocketChannel如何监听新进来的连接</p><p>通过ServerSocketChannel.accept()方法进行监听新进来的连接</p><p>ServerSocketChannel默认是阻塞模式</p></li><li><p>在阻塞模式下：</p><p>如果有新的连接进来，那么accept（）方法返回的是一个包含新进来的连接的SocketChannel，如果没有新的连接，那么accept（）方法就会一直阻塞在这里，直到有新的连接进来</p></li><li><p>在非阻塞模式下：</p><p>如果有新的连接进来，那么accept方法返回的是一个包含新进来的连接的SocketChannel</p><p>如果没有新的连接，那么accept方法就会立即返回null。</p></li></ol><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><ol><li><p>SocketChannel,网络IO通道，具体负责进行读写操作。NIO把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区</p></li><li><p>与ServerSocketChannel的区别，ServerSocketChannel在服务器端监听新的客户端Socket连接而SocketChannel则是负责正常的读写操作，以及其他的一些业务。</p></li><li><p>创建SocketChannel的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> 在客户端创建<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open()<br><span class="hljs-number">2.</span> 在服务器端创建<br>    ServerSocketChannel在接收到一个连接请求后得到<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.accept();<br></code></pre></td></tr></table></figure></li><li><p>将管道中的数据读取到缓存里。用的是SocketChannel的read()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> socketChannel.read(sizeBuffer);<br></code></pre></td></tr></table></figure></li><li><p>将缓存里的数据写到管道里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">socketChannel.write(sizeBuffer);<br></code></pre></td></tr></table></figure></li><li><p>相关方法</p><p><img src="17.png" alt="17"></p></li></ol><h2 id="NIO网络编程应用实例-群聊系统"><a href="#NIO网络编程应用实例-群聊系统" class="headerlink" title="NIO网络编程应用实例-群聊系统"></a>NIO网络编程应用实例-群聊系统</h2><p>实例要求</p><ol><li>编写一个NIO的群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人在线群聊</li><li>服务器端：可以监测用户上线，离线并实现消息转发功能</li><li>客户端：通过channel可以无阻塞发送消息给其他所有用户，同时可以接受其他用户发送的信息</li><li>目的：进一步理解NIO非阻塞网络编程机制。</li></ol><blockquote><p>实现思路</p></blockquote><ol><li>先编写服务器端</li><li>服务器端启动并监听6667</li><li>服务器接收客户端信息，并实现转发，同时实现上线离线提示</li><li>编写客户端</li></ol><p>相关代码 服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.dean.nio.GroupChat;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.*;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupChatServer</span> &#123;<br><br>    <span class="hljs-comment">// 定义属性</span><br>    <span class="hljs-keyword">private</span> Selector selector;<br><br>    <span class="hljs-keyword">private</span> ServerSocketChannel listenChannel;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">6667</span>;<br><br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-comment">//初始化工作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GroupChatServer</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>             <span class="hljs-comment">//得到选择器</span><br>             selector = Selector.open();<br>            <span class="hljs-comment">//ServerSocketChannel</span><br>            listenChannel = ServerSocketChannel.open();<br>            <span class="hljs-comment">//绑定端口</span><br>            listenChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port));<br>             <span class="hljs-comment">//设置非阻塞</span><br>            listenChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>             <span class="hljs-comment">//注册到Selector</span><br>            listenChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 监听就是监听有没有新的key</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listen</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-comment">// 说明有事件需要处理,如果有需要处理的则会被select select到</span><br>                <span class="hljs-keyword">if</span>(selector.select()&gt;<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 向select注册后会返回一个key  遍历得到selection Key集合</span><br>                    Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();<br>                    <span class="hljs-keyword">while</span>(keyIterator.hasNext())&#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>                        <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> listenChannel.accept();<br>                            socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                            socketChannel.register(selector,key.OP_READ);<br>                            System.out.println(socketChannel.getRemoteAddress()+<span class="hljs-string">&quot;上线&quot;</span>);<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (key.isReadable())&#123;<br>                            readData(key);<br>                        &#125;<br>                        <span class="hljs-comment">// 移除当前key，防止重复</span><br>                        keyIterator.remove();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 客户端把信息写到SocketChannel，现在是从SocketChannel读信息，然后写到buffer里面这样我们就可以获取到client发送的信息了</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readData</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 通过socketChannel反向获取到SocketChannel</span><br>            socketChannel = (SocketChannel) selectionKey.channel();<br>            <span class="hljs-comment">// 创建buffer</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">// 把数据读到byteBuffer</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> socketChannel.read(byteBuffer);<br>            <span class="hljs-keyword">if</span>(read &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// 把缓存区的数据转换成字符串</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array());<br>                System.out.println(<span class="hljs-string">&quot;form Client:&quot;</span>+msg);<br>                <span class="hljs-comment">// 获取到信息后，向其他Client转发</span><br>                send(msg,socketChannel);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            System.out.println(socketChannel.getRemoteAddress()+<span class="hljs-string">&quot;离线了...&quot;</span>);<br>            <span class="hljs-comment">// 取消注册</span><br>            selectionKey.cancel();<br>            <span class="hljs-comment">// 关闭通道</span><br>            socketChannel.close();<br>        &#125;<br>     &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg,SocketChannel self)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>         System.out.println(<span class="hljs-string">&quot;转发信息中...&quot;</span>);<br>         <span class="hljs-keyword">for</span> (SelectionKey key: selector.keys()) &#123;<br>             <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> key.channel();<br>             <span class="hljs-keyword">if</span> (channel <span class="hljs-keyword">instanceof</span> SocketChannel &amp;&amp; channel != self)&#123;<br>                 <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> (SocketChannel) channel;<br>                 <span class="hljs-comment">// 将msg存储到buffer</span><br>                 <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(msg.getBytes());<br>                 <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> socketChannel.write(byteBuffer);<br>             &#125;<br>         &#125;<br>     &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GroupChatServer</span> <span class="hljs-variable">groupChatServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatServer</span>();<br>        groupChatServer.listen();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dean.nio.GroupChat;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupChatClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HOST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6667</span>;<br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GroupChatClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        selector = Selector.open();<br>        socketChannel = <span class="hljs-built_in">this</span>.socketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(HOST, PORT));<br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        socketChannel.register(selector, SelectionKey.OP_READ);<br>        userName = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);<br>        System.out.println(userName+<span class="hljs-string">&quot;is ok&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br>        msg = userName + <span class="hljs-string">&quot;说:&quot;</span> + msg;<br>        <span class="hljs-keyword">try</span>&#123;<br>            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// select到可以select的</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> selector.select();<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> iterator.next();<br>                    <span class="hljs-comment">// 判断此key是不是可读的</span><br>                    <span class="hljs-keyword">if</span> (selectionKey.isReadable())&#123;<br>                        <span class="hljs-comment">// 通过key反向得到SocketChannel</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) selectionKey.channel();<br>                        <span class="hljs-comment">// 创建一个缓存区，用来读SocketChannel里面的内容</span><br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                        <span class="hljs-comment">// 读到</span><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(byteBuffer);<br>                        <span class="hljs-comment">// 把读到东西转换为字符串</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array());<br>                        System.out.println(s.trim());<br>                    &#125;<br>                    <span class="hljs-comment">// 防止重复操作</span><br>                    iterator.remove();<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">GroupChatClient</span> <span class="hljs-variable">chatClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatClient</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                    chatClient.read();<br>                    <span class="hljs-keyword">try</span>&#123;<br>                        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);<br>                    &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;.start();<br>        <span class="hljs-comment">// 扫描控制台</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span>(scanner.hasNextLine())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>            chatClient.send(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="NIO与零拷贝"><a href="#NIO与零拷贝" class="headerlink" title="NIO与零拷贝"></a>NIO与零拷贝</h2><ol><li>零拷贝是网络编程的关键，很多性能优化都离不开</li><li>在Java程序中，常用的零拷贝有mmap（内存映射）和sendFile。</li></ol><blockquote><p>再次理解</p></blockquote><ul><li>我们说零拷贝是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有kernel buffer有一份数据）</li><li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的CPU缓存伪共享以及无CPU校验和计算</li></ul><blockquote><p>mmap和sendFile的区别</p></blockquote><ol><li>mmap适合小数据量读写，sendFile适合大文件传输</li><li>mmap需要4次上下文切换，3次数据拷贝；sendFile需要3次上下文切换，最少两次数据拷贝</li><li>sendFile可以利用DMA方式减少CPU拷贝，mmap则不能，必须从内核拷贝到socket缓冲区。</li></ol><h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p><strong>I/O复用结合线程池</strong>就是Reactor模式基本设计思想</p><p><img src="18.png" alt="18"></p><p><strong>说明</strong>：</p><ol><li>Reactor模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li><li>服务器端程序处理传入的多个请求，并将他们同步分派到相应的处理线程，因此Reactor模式也叫Dispatcher模式</li><li>Reactor模式使用IO复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li></ol><blockquote><p>Reactor模式中核心组成</p></blockquote><ol><li>Reactor：Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。他就像电话接线员，也像是外卖平台，处理线程像是外卖员，外卖平台负责接收请求并分发给外卖员。一个Reactor就相当于是一个eventDispatch</li><li>Handlers: 处理程序执行IO事件要完成的实际事件，类似于客户想要阈值交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应IO事件，处理程序执行非阻塞操作。</li></ol><blockquote><p>Reactor模式分类</p></blockquote><p>根据Reactor的数量和处理资源池线程的数量不同，有三种典型的实现</p><ol><li>单Reactor单线程</li><li>单Reactor多线程</li><li>主从Reactor多线程</li></ol><blockquote><p>单Reactor多线程</p></blockquote><p><strong>方案优缺点分析</strong></p><p><img src="19.png"></p><p><strong>优点</strong>：可以充分利用多核CPU的处理能力</p><p><strong>缺点</strong>：多线程数据共享和访问比较复杂，reactor处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</p><blockquote><p>主从Reactor多线程</p></blockquote><p>工作原理示意图：</p><p><img src="20.png"></p><p>针对单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor在多线程中运行</p><p><strong>方案说明</strong></p><ol><li>Reactor主线程MainReactor对象通过select监听连接事件，收到事件后，通过Acceptor处理连接事件</li><li>当Acceptor处理连接事件后，MainReactor将连接分配给SubReactor</li><li>subreactor将连接加入到连接队列进行监听，并创建handler进行各种事件处理</li><li>当有新的事件发生时，subreactor就会调用对应的handler进行处理</li><li>handler通过read读取数据，分发给后面worker线程处理</li><li>worker线程池分配独立的worker线程进行业务处理，并返回结果 </li><li>handler收到响应的结果后再通过send方法将结果返回给client</li><li>Reactor主线程可以对应多个Reactor子线程，即MainReactor可以关联多个subreactor</li></ol><h2 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h2><p>Netty主要基于<strong>主从Reactors多线程</strong>模型做了一定得改进，其中主从Reactor多线程模型有多个Reactor</p><p><img src="21.png"></p><p><img src="22.png" alt="image-20210829155652910"></p><p><strong>说明</strong>：</p><ol><li>netty抽象出两组线程池BossGroup专门负责接收客户端的连接，WorkerGroup专门负责网络的读写</li><li>Bossgroup 和Workergroup类型都是NIOEventLoopGroup </li><li>NioEventGroup相当于是一个事件循环组，这个组中包含多个事件循环。每一个事件循环是一个NioEventLoop。</li><li>NioEventLoop表示一个不断循环的执行处理任务的线程，每一 个NioEventLoop有一个selector，用于监听绑定在其上的socket的网路通讯。</li><li>NioEventGroup 可以有多个线程，即可以有多个NioEventLoop</li><li>每个boss NioEventLoopGroup循环执行的步骤有三步：<ol><li>轮询accept事件</li><li>处理accept事件，生成NioSocketChannel,并将其注册到Worker NioEventLoop上的selector</li><li>处理任务队列的任务，即runAllTask</li></ol></li><li>每个worker NioeventLoop循环执行的步骤<ol><li>轮询write、read事件</li><li>处理i/o事件，即read/write事件，在对应的NioSocketChannel上处理</li><li>处理任务队列的任务，即runAllTasks</li><li>每个work NioEventLoop处理业务时，会使用pipeline（管道）进行一系列的任务的处理。pipeline里面包含了channel，即可以通过pipeline获取到channel,管道中维护了很多的处理器。</li></ol></li></ol><h3 id="Channel-和-Pipeline"><a href="#Channel-和-Pipeline" class="headerlink" title="Channel 和 Pipeline"></a>Channel 和 Pipeline</h3><ol><li>Channel 是通讯的载体，而ChannelHandler是负责Channel中的逻辑处理</li><li>ChannelPipeline可以理解为ChannelHandler的容器ch.pipeline().addLast(new NettyClientHandler());一个Channel包含一个ChannelPipeline,所有的ChannelHandler都会注册到ChannelPipeline中，并按顺序组织起来。</li><li></li></ol><h3 id="TCP-模型"><a href="#TCP-模型" class="headerlink" title="TCP 模型"></a>TCP 模型</h3><p><strong>NettyServer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dean.netty.simple;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-comment">// 创建BossGroup 和 WorkerGroup</span><br>        <span class="hljs-comment">//1. 创建两个线程组 bossGroup和 workerGroup</span><br>        <span class="hljs-comment">//2. bossGroup只是处理连接请求，真正的客户端业务处理会交给workerGroup</span><br>        <span class="hljs-comment">//3. 两个都是无限循环</span><br>        <span class="hljs-comment">//4. bossGroup workerGroup 含有的子线程（NioEventLoop)的个数</span><br>        <span class="hljs-comment">//   默认是cpu的核数 * 2</span><br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 创建服务器端的启动对象，配置参数</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>            <span class="hljs-comment">// 使用链式编程来进行设置</span><br>            bootstrap.group(bossGroup,workerGroup)<br>                    .channel(NioServerSocketChannel.class)<span class="hljs-comment">// 使用NioServerSocketChannel作为服务器端的通道实现</span><br>                    .option(ChannelOption.SO_BACKLOG,<span class="hljs-number">128</span>)<span class="hljs-comment">// 设置线程队列得到的连接数</span><br>                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="hljs-literal">true</span>)<span class="hljs-comment">// 设置保持活跃连接状态</span><br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-comment">// 创建一个通道测试对象（匿名对象）</span><br>                        <span class="hljs-comment">// 给pipeline设置处理器</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>                        &#125;<br>                    &#125;);<span class="hljs-comment">// 给我们workerEvent对应的GroupEventLoop设置处理器</span><br>            System.out.println(<span class="hljs-string">&quot; server is ready! &quot;</span>);<br><br>            <span class="hljs-comment">// 绑定一个端口并且同步，生成了一个channelFuture对象</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">cf</span> <span class="hljs-operator">=</span> bootstrap.bind(<span class="hljs-number">6668</span>).sync();<br><br>            <span class="hljs-comment">// 对关闭通道进行监听</span><br>            cf.channel().closeFuture().sync();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>NettyServerHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dean.netty.simple;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *1. 我们需要自定义一个Handler，需要继承netty规定好的某个HandlerAdapter</span><br><span class="hljs-comment"> * 2. 这时我们自定义Handler，才能称为是一个Handler</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *读取数据（这里我们可以读取客户端发送的信息）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象 含有pipeline管道，通道，连接的地址</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 这个就是客户端发送的数据，默认是Object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;Server ctx=&quot;</span> + ctx);<br>        System.out.println(<span class="hljs-string">&quot;server read  thread&quot;</span> + Thread.currentThread().getName());<br><br>        <span class="hljs-comment">// 将msg转为ByteBuf</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;客户端发送的消息是：&quot;</span> + buf.toString(CharsetUtil.UTF_8));<br>        <span class="hljs-comment">// 从上下文对象中拿到通道，然后拿到通道对应的地址。</span><br>        System.out.println(<span class="hljs-string">&quot;客户端地址：&quot;</span> + ctx.channel().remoteAddress());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据读取完毕，把数据写到缓存并刷新缓存，一般来说我们对发送的数据进行编码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello client! &quot;</span>,CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理异常，一般是需要关闭通道</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>NettyClient</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dean.netty.simple;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-comment">// 客户端需要一个事件循环组</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventExecutors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 创建客户端启动对象</span><br>            <span class="hljs-comment">// 注意客户端不是ServerBootstrap 而是Bootstrap</span><br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br><br>            <span class="hljs-comment">// 设置相关参数</span><br>            bootstrap.group(eventExecutors)<span class="hljs-comment">// 设置线程组</span><br>                    .channel(NioSocketChannel.class)<span class="hljs-comment">// 设置客户端通道的实现类（反射）</span><br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">// 往pipeline里面添加handler</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;client is ok..&quot;</span>);<br><br>            <span class="hljs-comment">// 启动客户端去连接服务器</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6668</span>).sync();<br>            <span class="hljs-comment">// 给关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            eventExecutors.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>NettyClientHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dean.netty.simple;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当通道就绪时就会触发该方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;client &quot;</span> + ctx);<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello server &quot;</span> , CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当通道有读取事件时，会触发</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;服务器回复的消息是： &quot;</span>+ byteBuf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;服务器的地址是：&quot;</span> + ctx.channel().remoteAddress());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 捕获异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h2><blockquote><p>基本介绍</p></blockquote><ol><li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不会立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知、回调来通知调用者</li><li>Netty的I/O操作就是异步的，包括Bind、write、connect等操作会简单的返回一个ChannelFuture.</li><li>调用者不能立刻获得结果，而是通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得I/O操作结果。</li><li>Netty的异步模型是建立在future和callback之上的。callback就是回调。重点说future，他的核心思想是：假设一个方法fun，计算过程可能耗时，等待fun返回显然不合适，那么可以调用fun的时候，立马返回一个Feture，后续可以通过Future去监控方法fun的处理过程即Future-Listener机制</li></ol><blockquote><p>Future 说明</p></blockquote><ol><li>表示异步执行的结果，可以通过它提供的方法来检测执行是否结束，比如检索计算等</li><li>ChannelFuture是一个接口：public interface ChannelFuture extends Future<Void>我们可以添加监听器，当监听的事件发生时，就会通知监听器。</li></ol><blockquote><p>工作原理示意图</p></blockquote><p><img src="23.png" alt="image-20210907221508509"></p><p><strong>说明</strong></p><ol><li>在使用Netty进行编程时，拦截操作和转出入栈数据只需要提供callback或者利用future即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li><li>Netty框架的目标就是让你的业务逻辑从网络应用编码中分离出来</li></ol><blockquote><p> Future-Listener 机制</p></blockquote><ol><li>当Future对象杠创建的时候，处于非完成状态，调用者可以根据返回的ChannelFuture来获取操作执行的状态，注册监听函数来执行完成后的操作</li><li>常见的操作<ul><li>通过isDone方法 来判断当前操作是否完成；</li><li>通过isSucess方法来判断已完成的操作是否成功</li><li>通过getCause方法来获取已完成的当前操作失败的原因</li><li>通过isCancelled方法来判断当前已完成的操作被取消的原因</li><li>通过addListener方法来注册监听器，当前操作已完成（isDone方法返回完成），将会通知指定的监听器；如果Future对象已完成，则通知指定的监听器。</li></ul></li></ol><p><strong>小结</strong>：相比传统阻塞I/O，执行I/O操作后线程会被阻塞住，知道操作完成；异步处理的好处是不会造成线程阻塞，线程在I/O操作期间可以执行别的程序，在高并发的情形下会更加稳定和更高的吞吐量</p><h2 id="Http模型"><a href="#Http模型" class="headerlink" title="Http模型"></a>Http模型</h2><p><strong>TestServer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dean.netty.http;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            serverBootstrap.group(bossGroup,workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestServerInitializer</span>());<span class="hljs-comment">// childHandler是给worker加handler,handler是给boss加handler</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">6969</span>).sync();<br>            <span class="hljs-keyword">if</span> (channelFuture.isSuccess())&#123;<br>                System.out.println(<span class="hljs-string">&quot;绑定成功！&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;绑定失败！&quot;</span>);<br>            &#125;<br>            channelFuture.channel().closeFuture().sync();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>TestServerInitializer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dean.netty.http;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 向管道加入处理器</span><br><br>        <span class="hljs-comment">// 得到管道</span><br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>        <span class="hljs-comment">// 加入一个netty提供的处理Http的编解码器</span><br>        pipeline.addLast(<span class="hljs-string">&quot;myHttpServerCodec&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br>        <span class="hljs-comment">// 加入一个自定义的handler</span><br>        pipeline.addLast(<span class="hljs-string">&quot;MyHttpServerHandler&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestHttpServerHandler</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>TestHttpServerHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dean.netty.http;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.http.*;<br><span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<br><br><span class="hljs-keyword">import</span> java.net.URI;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 说明</span><br><span class="hljs-comment"> * 1. SimpleChannelInboundHandler 是ChannelInboundHandlerAdapter的子类</span><br><span class="hljs-comment"> * 2. HttpObject表示客户端与服务器通信的数据被封装成HttpObject</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestHttpServerHandler</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;HttpObject&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取客户端数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// 每刷新一次都会有一个新的pipeline</span><br>        System.out.println(ctx.pipeline().hashCode() + <span class="hljs-string">&quot;````````&quot;</span> + <span class="hljs-built_in">this</span>.hashCode());<br>        <span class="hljs-type">HttpRequest</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> (HttpRequest) msg;<br>        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(httpRequest.uri());<br>        <span class="hljs-keyword">if</span> (uri.getPath().equals(<span class="hljs-string">&quot;/favicon.ico&quot;</span>))&#123;<br>            System.out.println(<span class="hljs-string">&quot;过滤掉该请求 /favicon.ico&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断msg是不是HttpRequest请求</span><br>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> HttpRequest)&#123;<br>            System.out.println(<span class="hljs-string">&quot;msg 类型 = &quot;</span> + msg.getClass());<br>            System.out.println(<span class="hljs-string">&quot;客户端地址&quot;</span> + ctx.channel().remoteAddress());<br><br>            <span class="hljs-comment">// 回复消息给浏览器</span><br>            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> Unpooled.copiedBuffer(<span class="hljs-string">&quot;你好，我是服务器！&quot;</span>, CharsetUtil.UTF_8);<br>            <span class="hljs-comment">// 构造一个Http的响应，即HttpResponse</span><br>            <span class="hljs-type">DefaultFullHttpResponse</span> <span class="hljs-variable">httpResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,<br>                                                                               HttpResponseStatus.OK,<br>                                                                               content);<br>            httpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>);<br>            httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());<br><br>            <span class="hljs-comment">// 将构建好的HttpResponse返回</span><br>            ctx.writeAndFlush(httpResponse);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Unpooled类"><a href="#Unpooled类" class="headerlink" title="Unpooled类"></a>Unpooled类</h2><ol><li><p>Netty提供一个专门用来操作缓冲区（即netty的数据容器）的工具类</p></li><li><p>通过给定的数据和 字符编码返回一个ByteBuf对象，类似NIO的ByteBuffer但有区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuf <span class="hljs-title function_">copiedBuffer</span><span class="hljs-params">(CharSequence string , Charset charset)</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><blockquote><p>基本介绍</p></blockquote><p>procedure call—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员不需要额外的为这个交互作用编程</p><p>两个或多个应用程序都分布在不同的服务器上，他们之间的调用都像是本地方法一样</p><h3 id="自己实现-Dubbo-RPC"><a href="#自己实现-Dubbo-RPC" class="headerlink" title="自己实现 Dubbo RPC"></a>自己实现 Dubbo RPC</h3><blockquote><p>需求说明</p></blockquote><ol><li>dubbo底层 使用了Netty作为网络通讯框架，要求使用netty自己实现一个简单的RPC框架</li><li>模仿dubbo，消费者和提供者的约定和接口协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的字符串，底层网络通信采用Netty 4.1.20</li></ol><blockquote><p>设计说明</p></blockquote><ol><li>创建一个接口，定义抽像方法。用于消费者和提供者之间的约定。</li><li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据</li><li>创建一 个消费者，该类需要透明的调用自己不存在的方法。内部需要使用Netty请求提供者返回数据</li></ol><p><img src="25.png" alt="image-20210912121004804"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2022/03/12/Nginx/"/>
    <url>/2022/03/12/Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><img src="1.png" alt="1"></p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><blockquote><p>正向代理装在客户端</p></blockquote><p>在客户端配置代理服务器，通过代理服务器进行互联网访问！</p><p><img src="4.png" alt="4"></p><p>比如翻墙，在客户端装了一个VPN,你想翻墙的时候他会先访问香港的服务器，然后香港的服务器再去访问外网，香港的服务器得到数据后，再把数据转发给你，这就是正向代理</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><blockquote><p>反向代理装在后端</p></blockquote><p>反向代理其实客户端是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴漏的是代理服务器地址，隐藏了真实服务器IP地址。</p><p><img src="2.png" alt="2"></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p><p><img src="3.png" alt="3"></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs conf">#负载均衡<br>upstream dean&#123;<br>        server 127.0.0.1:8080 weight=2<br>        server 127.0.0.1:8081 weight=1<br>&#125;<br>server &#123;<br>        # 监听localhost:80/ 如果有人请求就会代理到dean，dean有两台服务器会根据配置的权重进行分配<br>        listen       80; #监听80端口，只要访问80端口就会被Nginx拦截<br>        server_name  localhost;<br><br>        #charset koi8-r;<br><br>        #access_log  logs/host.access.log  main;<br>         <br>        #首页的请求走dean服务器 `\`表示以\开头，因为url的开头都已/开始。但是！正则表达式规则和长的块规则将被优先匹配查询<br>        location / &#123;<br>            root   html;<br>            index  index.html index.htm;<br>            proxy_pass http://dean；<br>        &#125;<br>        <br>        #admin的请求走xxx服务器<br>        location /admin &#123;<br>            root   html;<br>            index  index.html index.htm;<br>            proxy_pass http://xxx；<br>        &#125;<br>        <br>        location ~*.(gif|jpg|jpeg)$&#123;<br>        # 表示匹配任何以.gif .jpg .jpeg结尾的请求且不区分大小写匹配<br>        &#125;<br>        <br></code></pre></td></tr></table></figure><p><code>注意</code></p><ol><li><p>=：用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功就停止向下搜索并立即处理该请求</p></li><li><p>~：用于表示uri包含正则表达式，区分大小写。</p></li><li><p>~*：用于表示uri包含正则表达式，并且不区分大小写</p></li><li><p>^~:用于不包含正则表达式的uri前，要求Nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不使用location块中的正则uri和请求字符串做匹配。</p><ul><li><p>例如：location ^~ /images/   location ~* .(gif|jpg|jpeg)$这样，如果有请求/images/1.jpg，nginx如何决</p><p>定去进行哪个location中的操作呢？结果取决于标识符^<del>，因为^</del>要求匹配到立马执行，所以匹配到/images/后会立马执行搜索，并不会接着匹配了！！</p></li></ul></li></ol><p><strong>注意：如果uri包含正则表达式，则必须要有~ 或者 ~* 标识</strong></p><h2 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h2><p>所有的Nginx内置变量都可以通过if指令和正则表达式来进行匹配，并且根据匹配结果进行一些操作，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">if($</span><span class="language-bash">http_user_agent~MSIE)&#123;</span><br>rewrite ^(.)$/msie/$1 break;<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">if($</span><span class="language-bash">http_cookie~* <span class="hljs-string">&quot;id=([^;]+)(?:;|$)&quot;</span>)&#123;</span><br>set $id $1;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维必会</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
