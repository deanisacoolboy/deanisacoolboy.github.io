

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/siteicon.jpg">
  <link rel="icon" href="/img/siteicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="最强分布式工具Redisson什么是Redisson？一个基于Redis实现的分布式工具，有基本分布式对象和高级又抽象的分布式服务，为每个试图再造分布式轮子的程序员带来了大部分分布式问题的解决办法。 Redisson和Jedis、Lettuce有什么区别？ Redisson和它俩的区别就像一个用鼠标操作图形化界面，一个用命令行操作文件。Redisson是更高层的抽象，Jedis和Lettuce是R">
<meta property="og:type" content="article">
<meta property="og:title" content="最强分布式工具Redisson">
<meta property="og:url" content="http://example.com/2022/11/05/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E5%85%B7Redisson/index.html">
<meta property="og:site_name" content="野草技术社区">
<meta property="og:description" content="最强分布式工具Redisson什么是Redisson？一个基于Redis实现的分布式工具，有基本分布式对象和高级又抽象的分布式服务，为每个试图再造分布式轮子的程序员带来了大部分分布式问题的解决办法。 Redisson和Jedis、Lettuce有什么区别？ Redisson和它俩的区别就像一个用鼠标操作图形化界面，一个用命令行操作文件。Redisson是更高层的抽象，Jedis和Lettuce是R">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/11/05/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E5%85%B7Redisson/image-20221109112420546.png">
<meta property="og:image" content="d:/personalcode/hexo-blog/hexo-blog/source_posts/assets/image-20221109112420546-16679642714553.png">
<meta property="article:published_time" content="2022-11-05T04:47:21.000Z">
<meta property="article:modified_time" content="2022-11-09T03:38:42.146Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java高阶">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/11/05/%E6%9C%80%E5%BC%BA%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E5%85%B7Redisson/image-20221109112420546.png">
  
  
  <title>最强分布式工具Redisson - 野草技术社区</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"nGD612Gu0HScFjNTtkQ975DQ-gzGzoHsz","app_key":"uQWFCWpfdpmUcF3iVKDcak3s","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>野草技术社区</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg01.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="最强分布式工具Redisson">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-11-05 12:47" pubdate>
        2022年11月5日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      135 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">最强分布式工具Redisson</h1>
            
            <div class="markdown-body">
              <h1 id="最强分布式工具Redisson"><a href="#最强分布式工具Redisson" class="headerlink" title="最强分布式工具Redisson"></a>最强分布式工具Redisson</h1><h2 id="什么是Redisson？"><a href="#什么是Redisson？" class="headerlink" title="什么是Redisson？"></a><strong>什么是Redisson？</strong></h2><p>一个基于Redis实现的分布式工具，有基本分布式对象和高级又抽象的分布式服务，为每个试图再造分布式轮子的程序员带来了大部分分布式问题的解决办法。</p>
<h2 id="Redisson和Jedis、Lettuce有什么区别？"><a href="#Redisson和Jedis、Lettuce有什么区别？" class="headerlink" title="Redisson和Jedis、Lettuce有什么区别？"></a><strong>Redisson和Jedis、Lettuce有什么区别？</strong></h2><ul>
<li><p>Redisson和它俩的区别就像一个用鼠标操作图形化界面，一个用命令行操作文件。Redisson是更高层的抽象，Jedis和Lettuce是Redis命令的封装。</p>
</li>
<li><p>Jedis是Redis官方推出的用于通过Java连接Redis客户端的一个工具包，提供了Redis的各种命令支持</p>
</li>
<li><p>Lettuce是一种可扩展的线程安全的 Redis 客户端，通讯框架基于Netty，支持高级的 Redis 特性，比如哨兵，集群，管道，自动重新连接和Redis数据模型。 Spring Boot 2.x 开始 Lettuce 已取代 Jedis 成为首选 Redis 的客户端。</p>
</li>
<li><p>Redisson是架设在Redis基础上，通讯基于Netty的综合的、新型的中间件，企业级开发中使用Redis的最佳范本</p>
</li>
</ul>
<p>Jedis把Redis命令封装好，Lettuce则进一步有了更丰富的Api，也支持集群等模式。但是两者也都点到为止，只给了你操作Redis数据库的脚手架，而Redisson则是基于Redis、Lua和Netty建立起了成熟的分布式解决方案，甚至redis官方都推荐的一种工具集。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="分布式锁怎么实现"><a href="#分布式锁怎么实现" class="headerlink" title="分布式锁怎么实现"></a><strong>分布式锁怎么实现</strong></h3><p>分布式锁是并发业务下的刚需，虽然实现五花八门：ZooKeeper有Znode顺序节点，数据库有表级锁和乐/悲观锁，Redis有setNx，但是殊途同归，最终还是要回到互斥上来，本篇介绍Redisson，那就以redis为例。</p>
<h3 id="怎么写一个简单的Redis分布式锁？"><a href="#怎么写一个简单的Redis分布式锁？" class="headerlink" title="怎么写一个简单的Redis分布式锁？"></a><strong>怎么写一个简单的Redis分布式锁？</strong></h3><p>以Spring Data Redis为例，用RedisTemplate来操作Redis（setIfAbsent已经是setNx + expire的合并命令），如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加锁</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key, String value, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>    <span class="hljs-keyword">return</span> redisTemplate.opsForValue().setIfAbsent(key, value, timeout, unit);<br>&#125;<br><span class="hljs-comment">// 解锁，防止删错别人的锁，以uuid为value校验是否自己的锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String lockName, String uuid)</span> &#123;<br>    <span class="hljs-keyword">if</span>(uuid.equals(redisTemplate.opsForValue().get(lockName))&#123;        redisTemplate.opsForValue().del(lockName);    &#125;<br>&#125;<br><br><span class="hljs-comment">// 结构</span><br><span class="hljs-keyword">if</span>(tryLock)&#123;<br>    <span class="hljs-comment">// todo</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    unlock;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure>

<p>简单1.0版本完成，聪明的小张一眼看出，这是锁没错，但get和del操作非原子性，并发一旦大了，无法保证进程安全。于是小张提议，用Lua脚本</p>
<h3 id="Lua脚本是什么？"><a href="#Lua脚本是什么？" class="headerlink" title="Lua脚本是什么？"></a><strong>Lua脚本是什么？</strong></h3><p>Lua脚本是redis已经内置的一种轻量小巧语言，其执行是通过redis的<strong>eval</strong>/<strong>evalsha</strong>命令来运行，把操作封装成一个Lua脚本，如论如何都是一次执行的原子操作。</p>
<p>于是2.0版本通过Lua脚本删除</p>
<p>lockDel.lua如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <br>    then <br>	-- 执行删除操作<br>        <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <br>    <span class="hljs-keyword">else</span> <br>	-- 不成功，返回<span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <br>end<br>Copy<br></code></pre></td></tr></table></figure>

<p>delete操作时执行Lua命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解锁脚本</span><br>DefaultRedisScript&lt;Object&gt; unlockScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>();<br>unlockScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;lockDel.lua&quot;</span>)));<br><br><span class="hljs-comment">// 执行lua脚本解锁</span><br>redisTemplate.execute(unlockScript, Collections.singletonList(keyName), value);<br>Copy<br></code></pre></td></tr></table></figure>

<p>2.0似乎更像一把锁，但好像又缺少了什么，小张一拍脑袋，synchronized和ReentrantLock都很丝滑，因为他们都是可重入锁，一个线程多次拿锁也不会死锁，我们需要可重入。</p>
<h3 id="怎么保证可重入？"><a href="#怎么保证可重入？" class="headerlink" title="怎么保证可重入？"></a><strong>怎么保证可重入？</strong></h3><p>重入就是，同一个线程多次获取同一把锁是允许的，不会造成死锁，这一点synchronized偏向锁提供了很好的思路，synchronized的实现重入是在JVM层面，JAVA对象头MARK WORD中便藏有线程ID和计数器来对当前线程做重入判断，避免每次CAS。</p>
<blockquote>
<p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁标志是否设置成1：没有则CAS竞争；设置了，则CAS将对象头偏向锁指向当前线程。</p>
<p>再维护一个计数器，同个线程进入则自增1，离开再减1，直到为0才能释放</p>
</blockquote>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>仿造该方案，我们需改造Lua脚本：</p>
<p>1.需要存储 锁名称<strong>lockName</strong>、获得该锁的<strong>线程id</strong>和对应线程的<strong>进入次数count</strong></p>
<p>2.加锁</p>
<p>每次线程获取锁时，判断是否已存在该锁</p>
<ul>
<li><p>不存在</p>
</li>
<li><p>设置hash的key为线程id，value初始化为1</p>
</li>
<li><p>设置过期时间</p>
</li>
<li><p>返回获取锁成功true</p>
</li>
<li><p>存在</p>
</li>
<li><p>继续判断是否存在当前线程id的hash key，存在线程key的value + 1，重入次数增加1，设置过期时间</p>
<p>不存在，返回加锁失败</p>
</li>
</ul>
<p>3.解锁</p>
<p>每次线程来解锁时，判断是否已存在该锁</p>
<ul>
<li>存在</li>
<li>是否有该线程的id的hash key，有则减1，无则返回解锁失败</li>
<li>减1后，判断剩余count是否为0，为0则说明不再需要这把锁，执行del命令删除</li>
</ul>
<blockquote>
<h4 id="解锁的判断-当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除"><a href="#解锁的判断-当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除" class="headerlink" title="解锁的判断,当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除"></a>解锁的判断,当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除</h4></blockquote>
<p>加锁 lock.lua</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">local</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> KEYS[<span class="hljs-number">1</span>];<br><span class="hljs-type">local</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ARGV[<span class="hljs-number">1</span>];<br><span class="hljs-type">local</span> <span class="hljs-variable">releaseTime</span> <span class="hljs-operator">=</span> ARGV[<span class="hljs-number">2</span>];<br><br>-- lockname不存在<br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, key) == <span class="hljs-number">0</span>) then<br>    redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, key, threadId, <span class="hljs-string">&#x27;1&#x27;</span>);<br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, key, releaseTime);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end;<br><br>-- 当前线程已id存在<br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="hljs-number">1</span>) then<br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="hljs-string">&#x27;1&#x27;</span>);<br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, key, releaseTime);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>Copy<br></code></pre></td></tr></table></figure>

<p>解锁 unlock.lua</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">local</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> KEYS[<span class="hljs-number">1</span>];<br><span class="hljs-type">local</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ARGV[<span class="hljs-number">1</span>];<br><br>-- lockname、threadId不存在<br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="hljs-number">0</span>) then<br>    <span class="hljs-keyword">return</span> nil;<br>end;<br><br>-- 计数器-<span class="hljs-number">1</span><br><span class="hljs-type">local</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, key, threadId, -<span class="hljs-number">1</span>);<br><br>-- 删除lock<br><span class="hljs-title function_">if</span> <span class="hljs-params">(count == <span class="hljs-number">0</span>)</span> then<br>    redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, key);<br>    <span class="hljs-keyword">return</span> nil;<br>end;<br>Copy<br></code></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 原生redis实现分布式锁</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/2/6 10:51 下午</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> DefaultRedisScript&lt;Long&gt; lockScript;<br>    <span class="hljs-keyword">private</span> DefaultRedisScript&lt;Object&gt; unlockScript;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLock</span><span class="hljs-params">(RedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-comment">// 加载加锁的脚本</span><br>        lockScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.lockScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;lock.lua&quot;</span>)));<br>        <span class="hljs-built_in">this</span>.lockScript.setResultType(Long.class);<br>        <span class="hljs-comment">// 加载释放锁的脚本</span><br>        unlockScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.unlockScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>)));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String lockName, <span class="hljs-type">long</span> releaseTime)</span> &#123;<br>        <span class="hljs-comment">// 存入的线程信息的前缀</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br><br>        <span class="hljs-comment">// 执行脚本</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Long) redisTemplate.execute(<br>                lockScript,<br>                Collections.singletonList(lockName),<br>                key + Thread.currentThread().getId(),<br>                releaseTime);<br><br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span> &amp;&amp; result.intValue() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解锁</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String lockName, String key)</span> &#123;<br>        redisTemplate.execute(unlockScript,<br>                Collections.singletonList(lockName),<br>                key + Thread.currentThread().getId()<br>                );<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure>

<p>严谨的小张觉得虽然当个普通互斥锁，已经稳稳够用，可是业务里总是又很多特殊情况的，<strong>比如A进程在获取到锁的时候，因业务操作时间太长，锁释放了但是业务还在执行，而此刻B进程又可以正常拿到锁做业务操作，两个进程操作就会存在依旧有共享资源的问题</strong>。</p>
<p>而且如果负责储存这个分布式锁的<strong>Redis节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态</strong>。</p>
<p>所以我们希望在这种情况时，可以延长锁的releaseTime延迟释放锁来直到完成业务期望结果，这种不断延长锁过期时间来保证业务执行完成的操作就是锁续约。</p>
<h2 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 原生，本章使用--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 另一种Spring集成starter，本章未使用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>Copy<br></code></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissionConfig</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String redisHost;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">6379</span>;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">getRedisson</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().<br>                setAddress(<span class="hljs-string">&quot;redis://&quot;</span> + redisHost + <span class="hljs-string">&quot;:&quot;</span> + port).<br>                setPassword(password);<br>        config.setCodec(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonJacksonCodec</span>());<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure>

<h3 id="启用分布式锁"><a href="#启用分布式锁" class="headerlink" title="启用分布式锁"></a>启用分布式锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-type">RLock</span> <span class="hljs-variable">rLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(lockName);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLocked</span> <span class="hljs-operator">=</span> rLock.tryLock(expireTime, TimeUnit.MILLISECONDS);<br>    <span class="hljs-keyword">if</span> (isLocked) &#123;<br>        <span class="hljs-comment">// TODO</span><br>                &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            rLock.unlock();<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure>

<h2 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h2><p>RLock是Redisson分布式锁的最核心接口，继承了concurrent包的Lock接口和自己的RLockAsync接口，RLockAsync的返回值都是RFuture，是Redisson执行异步实现的核心逻辑，也是Netty发挥的主要阵地。</p>
<h3 id="RLock如何加锁？"><a href="#RLock如何加锁？" class="headerlink" title="RLock如何加锁？"></a><strong>RLock如何加锁？</strong></h3><p>从RLock进入，找到RedissonLock类，找到tryLock方法再递进到干事的tryAcquireOnceAsync方法，这是加锁的主要代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RFuture&lt;Boolean&gt; <span class="hljs-title function_">tryAcquireOnceAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>        <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1L</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            RFuture&lt;Boolean&gt; ttlRemainingFuture = <span class="hljs-built_in">this</span>.tryLockInnerAsync(waitTime, <span class="hljs-built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);<br>            ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (ttlRemaining) &#123;<br>                        <span class="hljs-built_in">this</span>.scheduleExpirationRenewal(threadId);<br>                    &#125;<br><br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>        &#125;<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure>

<p>此处出现leaseTime时间判断的2个分支，实际上就是加锁时是否设置过期时间，未设置过期时间（-1）时则会有<strong>watchDog</strong>的<strong>锁续约</strong>（下文），一个注册了加锁事件的续约任务。我们先来看有过期时间<strong>tryLockInnerAsync</strong>部分，</p>
<p>evalWriteAsync是eval命令执行lua的入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; RFuture&lt;T&gt; <span class="hljs-title function_">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;<br>        <span class="hljs-built_in">this</span>.internalLockLeaseTime = unit.toMillis(leaseTime);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.commandExecutor.evalWriteAsync(<span class="hljs-built_in">this</span>.getName(), LongCodec.INSTANCE, command, <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, Collections.singletonList(<span class="hljs-built_in">this</span>.getName()), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-built_in">this</span>.internalLockLeaseTime, <span class="hljs-built_in">this</span>.getLockName(threadId)&#125;);<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure>

<p>这里揭开真面目，eval命令执行Lua脚本的地方，此处的Lua脚本展开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">-- 不存在该key时<br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>) then <br>  -- 新增该锁并且hash中该线程id对应的count置<span class="hljs-number">1</span><br>  redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>); <br>  -- 设置过期时间<br>  redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]); <br>  <span class="hljs-keyword">return</span> nil; <br>end; <br><br>-- 存在该key 并且 hash中线程id的key也存在<br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>) then <br>  -- 线程重入次数++<br>  redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>); <br>  redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]); <br>  <span class="hljs-keyword">return</span> nil; <br>end; <br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;pttl&#x27;</span>, KEYS[<span class="hljs-number">1</span>]);<br>Copy<br></code></pre></td></tr></table></figure>

<p>和前面我们写自定义的分布式锁的脚本几乎一致，看来redisson也是一样的实现，具体参数分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// keyName</span><br>KEYS[<span class="hljs-number">1</span>] = Collections.singletonList(<span class="hljs-built_in">this</span>.getName())<br><span class="hljs-comment">// leaseTime</span><br>ARGV[<span class="hljs-number">1</span>] = <span class="hljs-built_in">this</span>.internalLockLeaseTime<br><span class="hljs-comment">// uuid+threadId组合的唯一值</span><br>ARGV[<span class="hljs-number">2</span>] = <span class="hljs-built_in">this</span>.getLockName(threadId)<br>Copy<br></code></pre></td></tr></table></figure>

<p>总共3个参数完成了一段逻辑：</p>
<p>判断该锁是否已经有对应hash表存在，</p>
<p>• 没有对应的hash表：则set该hash表中一个entry的key为锁名称，value为1，之后设置该hash表失效时间为leaseTime</p>
<p>• 存在对应的hash表：则将该lockName的value执行+1操作，也就是计算进入次数，再设置失效时间leaseTime</p>
<p>• 最后返回这把锁的ttl剩余时间</p>
<p>既然如此，那解锁的步骤也肯定有对应的-1操作，再看unlock方法，同样查找方法名，一路到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> RFuture&lt;Boolean&gt; <span class="hljs-title function_">unlockInnerAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> threadId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.commandExecutor.evalWriteAsync(<span class="hljs-built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); if (counter &gt; 0) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); return 0; else redis.call(&#x27;del&#x27;, KEYS[1]); redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end; return nil;&quot;</span>, Arrays.asList(<span class="hljs-built_in">this</span>.getName(), <span class="hljs-built_in">this</span>.getChannelName()), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;LockPubSub.unlockMessage, <span class="hljs-built_in">this</span>.internalLockLeaseTime, <span class="hljs-built_in">this</span>.getLockName(threadId)&#125;);<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure>

<p>掏出Lua部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">-- 不存在key<br><span class="hljs-title function_">if</span> <span class="hljs-params">(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">3</span>])</span> == <span class="hljs-number">0</span>) then <br>  <span class="hljs-keyword">return</span> nil;<br>end;<br>-- 计数器 -<span class="hljs-number">1</span><br><span class="hljs-type">local</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">3</span>], -<span class="hljs-number">1</span>); <br><span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">0</span>) then <br>  -- 过期时间重设<br>  redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]); <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br><span class="hljs-keyword">else</span><br>  -- 删除并发布解锁消息<br>  redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]); <br>  redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>, KEYS[<span class="hljs-number">2</span>], ARGV[<span class="hljs-number">1</span>]); <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end; <br><span class="hljs-keyword">return</span> nil;<br>Copy<br></code></pre></td></tr></table></figure>

<p>该Lua KEYS有2个<code>Arrays.asList(getName(), getChannelName())</code></p>
<blockquote>
<p>name 锁名称 channelName，用于pubSub发布消息的channel名称</p>
</blockquote>
<p>ARGV变量有三个<code>LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId)</code></p>
<blockquote>
<p>LockPubSub.UNLOCK_MESSAGE，channel发送消息的类别，此处解锁为0 internalLockLeaseTime，watchDog配置的超时时间，默认为30s lockName 这里的lockName指的是uuid和threadId组合的唯一值</p>
</blockquote>
<p>步骤如下：</p>
<p>1.如果该锁不存在则返回nil；</p>
<p>2.如果该锁存在则将其线程的hash key计数器-1，</p>
<p>3.计数器counter&gt;0，重置下失效时间，返回0；否则，删除该锁，发布解锁消息unlockMessage，返回1；</p>
<p>其中unLock的时候使用到了Redis发布订阅PubSub完成消息通知。</p>
<p>而订阅的步骤就在RedissonLock的加锁入口的lock方法里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">ttl</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.tryAcquire(-<span class="hljs-number">1L</span>, leaseTime, unit, threadId);<br>        <span class="hljs-keyword">if</span> (ttl != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 订阅</span><br>            RFuture&lt;RedissonLockEntry&gt; future = <span class="hljs-built_in">this</span>.subscribe(threadId);<br>            <span class="hljs-keyword">if</span> (interruptibly) &#123;<br>                <span class="hljs-built_in">this</span>.commandExecutor.syncSubscriptionInterrupted(future);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.commandExecutor.syncSubscription(future);<br>            &#125;<br>            <span class="hljs-comment">// 省略</span><br>Copy<br></code></pre></td></tr></table></figure>

<p><strong>当锁被其他线程占用时，通过监听锁的释放通知（在其他线程通过RedissonLock释放锁时，会通过发布订阅pub/sub功能发起通知），等待锁被其他线程释放，也是为了避免自旋的一种常用效率手段。</strong></p>
<h3 id="解锁消息"><a href="#解锁消息" class="headerlink" title="解锁消息"></a>解锁消息</h3><p>为了一探究竟通知了什么，通知后又做了什么，进入LockPubSub。</p>
<p>这里只有一个明显的监听方法onMessage，其订阅和信号量的释放都在父类PublishSubscribe，我们只关注监听事件的实际操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(RedissonLockEntry value, Long message)</span> &#123;<br>        Runnable runnableToExecute;<br>        <span class="hljs-keyword">if</span> (message.equals(unlockMessage)) &#123;<br>            <span class="hljs-comment">// 从监听器队列取监听线程执行监听回调</span><br>            runnableToExecute = (Runnable)value.getListeners().poll();<br>            <span class="hljs-keyword">if</span> (runnableToExecute != <span class="hljs-literal">null</span>) &#123;<br>                runnableToExecute.run();<br>            &#125;<br>            <span class="hljs-comment">// getLatch()返回的是Semaphore，信号量，此处是释放信号量</span><br>            <span class="hljs-comment">// 释放信号量后会唤醒等待的entry.getLatch().tryAcquire去再次尝试申请锁</span><br>            value.getLatch().release();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.equals(readUnlockMessage)) &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                runnableToExecute = (Runnable)value.getListeners().poll();<br>                <span class="hljs-keyword">if</span> (runnableToExecute == <span class="hljs-literal">null</span>) &#123;<br>                    value.getLatch().release(value.getLatch().getQueueLength());<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                runnableToExecute.run();<br>            &#125;<br>        &#125;<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure>

<p>发现一个是<strong>默认解锁消息</strong>，一个是*<em>读锁解锁消息*</em>**，**因为redisson是有提供读写锁的，而读写锁读读情况和读写、写写情况互斥情况不同，我们只看上面的默认解锁消息unlockMessage分支</p>
<p>LockPubSub监听最终执行了2件事</p>
<ol>
<li>runnableToExecute.run() 执行监听回调</li>
<li>value.getLatch().release(); 释放信号量</li>
</ol>
<p>Redisson通过<strong>LockPubSub</strong>监听解锁消息，执行监听回调和释放信号量通知等待线程可以重新抢锁。</p>
<p>这时再回来看tryAcquireOnceAsync另一分支</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RFuture&lt;Boolean&gt; <span class="hljs-title function_">tryAcquireOnceAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>        <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1L</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            RFuture&lt;Boolean&gt; ttlRemainingFuture = <span class="hljs-built_in">this</span>.tryLockInnerAsync(waitTime, <span class="hljs-built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);<br>            ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (ttlRemaining) &#123;<br>                        <span class="hljs-built_in">this</span>.scheduleExpirationRenewal(threadId);<br>                    &#125;<br><br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">return</span> ttlRemainingFuture;<br>        &#125;<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure>

<p>可以看到，无超时时间时，在执行加锁操作后，还执行了一段费解的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (ttlRemaining) &#123;<br>                        <span class="hljs-built_in">this</span>.scheduleExpirationRenewal(threadId);<br>                    &#125;<br><br>                &#125;<br>            &#125;)<br>Copy<br></code></pre></td></tr></table></figure>

<p>此处涉及到Netty的Future/Promise-Listener模型（参考<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/rickiyang/p/12742091.html">Netty中的异步编程</a>），Redisson中几乎全部以这种方式通信（所以说Redisson是基于Netty通信机制实现的），理解这段逻辑可以试着先理解</p>
<blockquote>
<p>在 Java 的 Future 中，业务逻辑为一个 Callable 或 Runnable 实现类，该类的 call()或 run()执行完毕意味着业务逻辑的完结，在 Promise 机制中，可以在业务逻辑中人工设置业务逻辑的成功与失败，这样更加方便的监控自己的业务逻辑。</p>
</blockquote>
<p>这块代码的表面意义就是，在执行异步加锁的操作后，加锁成功则根据加锁完成返回的ttl是否过期来确认是否执行一段定时任务。</p>
<p>这段定时任务的就是watchDog的核心。</p>
<h3 id="锁续约"><a href="#锁续约" class="headerlink" title="锁续约"></a>锁续约</h3><p>查看RedissonLock.this.scheduleExpirationRenewal(threadId)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleExpirationRenewal</span><span class="hljs-params">(<span class="hljs-type">long</span> threadId)</span> &#123;<br>        RedissonLock.<span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedissonLock</span>.ExpirationEntry();<br>        RedissonLock.<span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">oldEntry</span> <span class="hljs-operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(<span class="hljs-built_in">this</span>.getEntryName(), entry);<br>        <span class="hljs-keyword">if</span> (oldEntry != <span class="hljs-literal">null</span>) &#123;<br>            oldEntry.addThreadId(threadId);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            entry.addThreadId(threadId);<br>            <span class="hljs-built_in">this</span>.renewExpiration();<br>        &#125;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renewExpiration</span><span class="hljs-params">()</span> &#123;<br>        RedissonLock.<span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ee</span> <span class="hljs-operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="hljs-built_in">this</span>.getEntryName());<br>        <span class="hljs-keyword">if</span> (ee != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Timeout</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.commandExecutor.getConnectionManager().newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    RedissonLock.<span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ent</span> <span class="hljs-operator">=</span> (RedissonLock.ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.<span class="hljs-built_in">this</span>.getEntryName());<br>                    <span class="hljs-keyword">if</span> (ent != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">Long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ent.getFirstThreadId();<br>                        <span class="hljs-keyword">if</span> (threadId != <span class="hljs-literal">null</span>) &#123;<br>                            RFuture&lt;Boolean&gt; future = RedissonLock.<span class="hljs-built_in">this</span>.renewExpirationAsync(threadId);<br>                            future.onComplete((res, e) -&gt; &#123;<br>                                <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                                    RedissonLock.log.error(<span class="hljs-string">&quot;Can&#x27;t update lock &quot;</span> + RedissonLock.<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; expiration&quot;</span>, e);<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    <span class="hljs-keyword">if</span> (res) &#123;<br>                                        RedissonLock.<span class="hljs-built_in">this</span>.renewExpiration();<br>                                    &#125;<br><br>                                &#125;<br>                            &#125;);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;, <span class="hljs-built_in">this</span>.internalLockLeaseTime / <span class="hljs-number">3L</span>, TimeUnit.MILLISECONDS);<br>            ee.setTimeout(task);<br>        &#125;<br>    &#125;<br>Copy<br></code></pre></td></tr></table></figure>

<p>拆分来看，这段连续嵌套且冗长的代码实际上做了几步</p>
<p>• 添加一个netty的Timeout回调任务，每（internalLockLeaseTime / 3）毫秒执行一次，执行的方法是renewExpirationAsync</p>
<p>• renewExpirationAsync重置了锁超时时间，又注册一个监听器，监听回调又执行了renewExpiration</p>
<p>renewExpirationAsync 的Lua如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> RFuture&lt;Boolean&gt; <span class="hljs-title function_">renewExpirationAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> threadId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.commandExecutor.evalWriteAsync(<span class="hljs-built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return 1; end; return 0;&quot;</span>, Collections.singletonList(<span class="hljs-built_in">this</span>.getName()), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-built_in">this</span>.internalLockLeaseTime, <span class="hljs-built_in">this</span>.getLockName(threadId)&#125;);<br>    &#125;<br><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>) then <br>  redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]); <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>end; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>Copy<br></code></pre></td></tr></table></figure>

<p>重新设置了超时时间。</p>
<p><strong>Redisson加这段逻辑的目的是什么？</strong></p>
<p>目的是为了某种场景下保证业务不影响，如任务执行超时但未结束，锁已经释放的问题。</p>
<p><strong>当一个线程持有了一把锁，由于并未设置超时时间leaseTime，Redisson默认配置了30S，开启watchDog，每10S对该锁进行一次续约，维持30S的超时时间，直到任务完成再删除锁。</strong></p>
<p>这就是Redisson的<strong>锁续约</strong>，也就是<strong>WatchDog</strong>实现的基本思路。</p>
<h3 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h3><p>通过整体的介绍，流程简单概括：</p>
<ol>
<li>A、B线程争抢一把锁，A获取到后，B阻塞</li>
<li>B线程阻塞时并非主动CAS，而是PubSub方式订阅该锁的广播消息</li>
<li>A操作完成释放了锁，B线程收到订阅消息通知</li>
<li>B被唤醒开始继续抢锁，拿到锁</li>
</ol>
<p>详细加锁解锁流程总结如下图：</p>
<p><img src="image-20221109112420546.png" srcset="/img/loading.gif" lazyload alt="image-20221109112420546"></p>
<p><img src="D:\personalcode\hexo-blog\hexo-blog\source_posts\assets\image-20221109112420546-16679642714553.png" srcset="/img/loading.gif" lazyload alt="image-20221109112420546"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redisson整体实现分布式加解锁流程的实现稍显复杂，作者Rui Gu对Netty和JUC、Redis研究深入，利用了很多高级特性和语义，值得深入学习，本次介绍也只是单机Redis下锁实现，Redisson也提供了多机情况下的联锁（<a href="https://link.juejin.cn/?target=https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8%2381-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81reentrant-lock">MultiLock</a>)和官方推荐的红锁（<a href="https://link.juejin.cn/?target=https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8%2384-%E7%BA%A2%E9%94%81redlock">RedLock</a>），下一章再详细介绍。</p>
<p>所以，当你真的需要分布式锁时，不妨先来Redisson里找找。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java%E9%AB%98%E9%98%B6/">java高阶</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/09/%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%8F%91%E9%80%81email%E3%80%81%E7%9F%AD%E4%BF%A1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">基于事件驱动发送email、短信</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/14/%E5%BC%95%E7%94%A8/">
                        <span class="hidden-mobile">引用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"nGD612Gu0HScFjNTtkQ975DQ-gzGzoHsz","appKey":"uQWFCWpfdpmUcF3iVKDcak3s","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
